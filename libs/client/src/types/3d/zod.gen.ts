// This file is auto-generated by @hey-api/openapi-ts

import { z } from "zod";

/**
 * File
 */
export const zFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The size of the file in bytes.",
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "The name of the file. It will be auto-generated if not provided.",
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The mime type of the file.",
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: "The URL where the file can be downloaded from.",
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: "File data",
    }),
  ),
});

/**
 * ModelUrls
 *
 * 3D model files in various formats
 */
export const zModelUrlsType3 = z
  .object({
    usdz: z.optional(zFile),
    fbx: z.optional(zFile),
    blend: z.optional(zFile),
    stl: z.optional(zFile),
    glb: z.optional(zFile),
    obj: z.optional(zFile),
  })
  .register(z.globalRegistry, {
    description: "3D model files in various formats",
  });

/**
 * TextureFiles
 *
 * Texture files downloaded and uploaded to CDN
 */
export const zTextureFiles = z
  .object({
    base_color: zFile,
    normal: z.optional(zFile),
    roughness: z.optional(zFile),
    metallic: z.optional(zFile),
  })
  .register(z.globalRegistry, {
    description: "Texture files downloaded and uploaded to CDN",
  });

/**
 * TextTo3DOutput
 *
 * Output for Text to 3D generation
 */
export const zMeshyV6PreviewTextTo3dOutput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: "The text prompt used for generation",
    }),
    thumbnail: z.optional(zFile),
    actual_prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description: "The actual prompt used if prompt expansion was enabled",
      }),
    ),
    texture_urls: z.optional(
      z.array(zTextureFiles).register(z.globalRegistry, {
        description: "Array of texture file objects",
      }),
    ),
    model_glb: zFile,
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: "The seed used for generation",
      }),
    ),
    model_urls: zModelUrlsType3,
  })
  .register(z.globalRegistry, {
    description: "Output for Text to 3D generation",
  });

/**
 * TextTo3DInput
 *
 * Input for Text to 3D conversion
 */
export const zMeshyV6PreviewTextTo3dInput = z
  .object({
    prompt: z.string().max(600).register(z.globalRegistry, {
      description:
        "Describe what kind of object the 3D model is. Maximum 600 characters.",
    }),
    enable_pbr: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Generate PBR Maps (metallic, roughness, normal) in addition to base color. Should be false for sculpture style.",
        }),
      )
      .default(false),
    target_polycount: z
      .optional(
        z.int().gte(100).lte(300000).register(z.globalRegistry, {
          description: "Target number of polygons in the generated model",
        }),
      )
      .default(30000),
    art_style: z.optional(
      z.enum(["realistic", "sculpture"]).register(z.globalRegistry, {
        description:
          "Desired art style of the object. Note: enable_pbr should be false for sculpture style.",
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If set to true, input data will be checked for safety before processing.",
        }),
      )
      .default(true),
    mode: z.optional(
      z.enum(["preview", "full"]).register(z.globalRegistry, {
        description:
          "Generation mode. 'preview' returns untextured geometry only, 'full' returns textured model (preview + refine).",
      }),
    ),
    symmetry_mode: z.optional(
      z.enum(["off", "auto", "on"]).register(z.globalRegistry, {
        description: "Controls symmetry behavior during model generation.",
      }),
    ),
    should_remesh: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the remesh phase. When false, returns unprocessed triangular mesh.",
        }),
      )
      .default(true),
    texture_image_url: z.optional(z.union([z.string(), z.string()])),
    topology: z.optional(
      z.enum(["quad", "triangle"]).register(z.globalRegistry, {
        description:
          "Specify the topology of the generated model. Quad for smooth surfaces, Triangle for detailed geometry.",
      }),
    ),
    enable_prompt_expansion: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.",
        }),
      )
      .default(false),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          "Seed for reproducible results. Same prompt and seed usually generate the same result.",
      }),
    ),
    is_a_t_pose: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether to generate the model in an A/T pose",
        }),
      )
      .default(false),
    texture_prompt: z.optional(
      z.string().max(600).register(z.globalRegistry, {
        description:
          "Additional text prompt to guide the texturing process (only used in 'full' mode)",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "Input for Text to 3D conversion",
  });

/**
 * ModelUrls
 */
export const zModelUrlsType2 = z.object({
  fbx: z.optional(zFile),
  usdz: z.optional(zFile),
  glb: z.optional(zFile),
  obj: z.optional(zFile),
});

/**
 * TextTo3DOutput
 */
export const zHunyuan3dV3TextTo3dOutput = z.object({
  model_urls: zModelUrlsType2,
  thumbnail: z.optional(zFile),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The seed used for generation",
    }),
  ),
  model_glb: zFile,
});

/**
 * TextTo3DInput
 */
export const zHunyuan3dV3TextTo3dInput = z.object({
  enable_pbr: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enable PBR material generation",
      }),
    )
    .default(false),
  polygon_type: z.optional(
    z.enum(["triangle", "quadrilateral"]).register(z.globalRegistry, {
      description:
        "Polygon type. Only takes effect when GenerateType is LowPoly.",
    }),
  ),
  face_count: z
    .optional(
      z.int().gte(40000).lte(1500000).register(z.globalRegistry, {
        description: "Target face count. Range: 40000-1500000",
      }),
    )
    .default(500000),
  prompt: z.string().max(1024).register(z.globalRegistry, {
    description:
      "Text description of the 3D content to generate. Supports up to 1024 UTF-8 characters.",
  }),
  generate_type: z.optional(
    z.enum(["Normal", "LowPoly", "Geometry"]).register(z.globalRegistry, {
      description:
        "Generation type. Normal: textured model. LowPoly: polygon reduction. Geometry: white model without texture.",
    }),
  ),
});

/**
 * HYMotionOutput
 */
export const zHunyuanMotionOutput = z.object({
  fbx_file: z.optional(zFile),
  motion_json: z.optional(zFile),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for generation.",
  }),
});

/**
 * HYMotionInput
 */
export const zHunyuanMotionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "Text prompt describing the motion to generate.",
  }),
  duration: z
    .optional(
      z.number().gte(0.5).lte(12).register(z.globalRegistry, {
        description: "Motion duration in seconds (0.5-12.0).",
      }),
    )
    .default(5),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "Classifier-free guidance scale. Higher = more faithful to prompt.",
      }),
    )
    .default(5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Random seed for reproducible generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["fbx", "dict"]).register(z.globalRegistry, {
      description:
        "Output format: 'fbx' for animation files, 'dict' for raw JSON.",
    }),
  ),
});

/**
 * HYMotionOutput
 */
export const zHunyuanMotionFastOutput = z.object({
  fbx_file: z.optional(zFile),
  motion_json: z.optional(zFile),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for generation.",
  }),
});

/**
 * HYMotionInput
 */
export const zHunyuanMotionFastInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "Text prompt describing the motion to generate.",
  }),
  duration: z
    .optional(
      z.number().gte(0.5).lte(12).register(z.globalRegistry, {
        description: "Motion duration in seconds (0.5-12.0).",
      }),
    )
    .default(5),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "Classifier-free guidance scale. Higher = more faithful to prompt.",
      }),
    )
    .default(5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Random seed for reproducible generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["fbx", "dict"]).register(z.globalRegistry, {
      description:
        "Output format: 'fbx' for animation files, 'dict' for raw JSON.",
    }),
  ),
});

/**
 * ModelUrls
 */
export const zModelUrls = z.object({
  texture: z.optional(zFile),
  fbx: z.optional(zFile),
  mtl: z.optional(zFile),
  usdz: z.optional(zFile),
  obj: z.optional(zFile),
  glb: z.optional(zFile),
});

/**
 * ProTextTo3DOutput
 */
export const zHunyuan3dV31ProTextTo3dOutput = z.object({
  model_urls: zModelUrls,
  thumbnail: z.optional(zFile),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The seed used for generation",
    }),
  ),
  model_glb: zFile,
});

/**
 * ProTextTo3DInput
 */
export const zHunyuan3dV31ProTextTo3dInput = z.object({
  prompt: z.string().max(1024).register(z.globalRegistry, {
    description:
      "Text description of the 3D content to generate. Max 1024 UTF-8 characters.",
  }),
  enable_pbr: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Enable PBR material generation (metallic, roughness, normal textures). Ignored when generate_type is Geometry.",
      }),
    )
    .default(false),
  face_count: z
    .optional(
      z.int().gte(40000).lte(1500000).register(z.globalRegistry, {
        description:
          "Target polygon face count. Range: 40,000-1,500,000. Default: 500,000.",
      }),
    )
    .default(500000),
  generate_type: z.optional(
    z.enum(["Normal", "Geometry"]).register(z.globalRegistry, {
      description:
        "Generation task type. Normal: textured model. Geometry: geometry-only white model (no textures). LowPoly/Sketch are not available in v3.1.",
    }),
  ),
});

/**
 * RapidTextTo3DOutput
 */
export const zHunyuan3dV31RapidTextTo3dOutput = z.object({
  model_obj: z.optional(zFile),
  texture: z.optional(zFile),
  thumbnail: z.optional(zFile),
  material_mtl: z.optional(zFile),
  model_urls: zModelUrls,
});

/**
 * RapidTextTo3DInput
 */
export const zHunyuan3dV31RapidTextTo3dInput = z.object({
  prompt: z.string().max(200).register(z.globalRegistry, {
    description:
      "Text description of the 3D content to generate. Max 200 UTF-8 characters.",
  }),
  enable_pbr: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Enable PBR material generation (metallic, roughness, normal textures). Does not take effect when enable_geometry is True.",
      }),
    )
    .default(false),
  enable_geometry: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Generate geometry-only white model without textures. When enabled, enable_pbr is ignored and OBJ is not supported (default output is GLB).",
      }),
    )
    .default(false),
});

/**
 * ObjectOutput
 */
export const zTriposrOutput = z.object({
  remeshing_dir: z.optional(zFile),
  model_mesh: zFile,
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: "Inference timings.",
  }),
});

/**
 * TripoSRInput
 */
export const zTriposrInput = z.object({
  mc_resolution: z
    .optional(
      z.int().gte(32).lte(1024).register(z.globalRegistry, {
        description:
          "Resolution of the marching cubes. Above 512 is not recommended.",
      }),
    )
    .default(256),
  do_remove_background: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to remove the background from the input image.",
      }),
    )
    .default(true),
  foreground_ratio: z
    .optional(
      z.number().gte(0.5).lte(1).register(z.globalRegistry, {
        description: "Ratio of the foreground image to the original image.",
      }),
    )
    .default(0.9),
  output_format: z.optional(
    z.enum(["glb", "obj"]).register(z.globalRegistry, {
      description: "Output format for the 3D model.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * File
 */
export const zFileType2 = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: "The URL where the file can be downloaded from.",
  }),
});

/**
 * ObjectOutput
 */
export const zTrellisOutput = z.object({
  model_mesh: zFileType2,
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: "Processing timings",
  }),
});

/**
 * InputModel
 */
export const zTrellisInput = z.object({
  slat_sampling_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Sampling steps for structured latent generation",
      }),
    )
    .default(12),
  ss_sampling_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Sampling steps for sparse structure generation",
      }),
    )
    .default(12),
  image_url: z.union([z.string(), z.string()]),
  slat_guidance_strength: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: "Guidance strength for structured latent generation",
      }),
    )
    .default(3),
  ss_guidance_strength: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: "Guidance strength for sparse structure generation",
      }),
    )
    .default(7.5),
  mesh_simplify: z
    .optional(
      z.number().gte(0.9).lte(0.98).register(z.globalRegistry, {
        description: "Mesh simplification factor",
      }),
    )
    .default(0.95),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  texture_size: z.optional(
    z
      .union([z.literal(512), z.literal(1024), z.literal(2048)])
      .register(z.globalRegistry, {
        description: "Texture resolution",
      }),
  ),
});

/**
 * Image
 *
 * Represents an image file.
 */
export const zImage = z
  .object({
    height: z.optional(
      z.int().register(z.globalRegistry, {
        description: "The height of the image in pixels.",
      }),
    ),
    file_size: z.optional(
      z.int().register(z.globalRegistry, {
        description: "The size of the file in bytes.",
      }),
    ),
    url: z.string().register(z.globalRegistry, {
      description: "The URL where the file can be downloaded from.",
    }),
    width: z.optional(
      z.int().register(z.globalRegistry, {
        description: "The width of the image in pixels.",
      }),
    ),
    file_name: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          "The name of the file. It will be auto-generated if not provided.",
      }),
    ),
    content_type: z.optional(
      z.string().register(z.globalRegistry, {
        description: "The mime type of the file.",
      }),
    ),
    file_data: z.optional(
      z.string().register(z.globalRegistry, {
        description: "File data",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "Represents an image file.",
  });

/**
 * ObjectOutput
 */
export const zHyper3dRodinOutput = z.object({
  model_mesh: zFile,
  seed: z.int().register(z.globalRegistry, {
    description: "Seed value used for generation.",
  }),
  textures: z.array(zImage).register(z.globalRegistry, {
    description: "Generated textures for the 3D object.",
  }),
});

/**
 * Rodin3DInput
 */
export const zHyper3dRodinInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "A textual prompt to guide model generation. Required for Text-to-3D mode. Optional for Image-to-3D mode.",
      }),
    )
    .default(""),
  condition_mode: z.optional(
    z.enum(["fuse", "concat"]).register(z.globalRegistry, {
      description:
        "For fuse mode, One or more images are required.It will generate a model by extracting and fusing features of objects from multiple images.For concat mode, need to upload multiple multi-view images of the same object and generate the model. (You can upload multi-view images in any order, regardless of the order of view.)",
    }),
  ),
  bbox_condition: z.optional(
    z.array(z.int()).register(z.globalRegistry, {
      description:
        "An array that specifies the dimensions and scaling factor of the bounding box. Typically, this array contains 3 elements, Length(X-axis), Width(Y-axis) and Height(Z-axis).",
    }),
  ),
  tier: z.optional(
    z.enum(["Regular", "Sketch"]).register(z.globalRegistry, {
      description:
        "Tier of generation. For Rodin Sketch, set to Sketch. For Rodin Regular, set to Regular.",
    }),
  ),
  quality: z.optional(
    z.enum(["high", "medium", "low", "extra-low"]).register(z.globalRegistry, {
      description:
        "Generation quality. Possible values: high, medium, low, extra-low. Default is medium.",
    }),
  ),
  TAPose: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "When generating the human-like model, this parameter control the generation result to T/A Pose.",
      }),
    )
    .default(false),
  input_image_urls: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        "URL of images to use while generating the 3D model. Required for Image-to-3D mode. Optional for Text-to-3D mode.",
    }),
  ),
  geometry_file_format: z.optional(
    z.enum(["glb", "usdz", "fbx", "obj", "stl"]).register(z.globalRegistry, {
      description:
        "Format of the geometry file. Possible values: glb, usdz, fbx, obj, stl. Default is glb.",
    }),
  ),
  use_hyper: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to export the model using hyper mode. Default is false.",
      }),
    )
    .default(false),
  addons: z.optional(
    z.enum(["HighPack"]).register(z.globalRegistry, {
      description:
        "Generation add-on features. Default is []. Possible values are HighPack. The HighPack option will provide 4K resolution textures instead of the default 1K, as well as models with high-poly. It will cost triple the billable units.",
    }),
  ),
  seed: z.optional(
    z.int().gte(0).lte(65535).register(z.globalRegistry, {
      description:
        "Seed value for randomization, ranging from 0 to 65535. Optional.",
    }),
  ),
  material: z.optional(
    z.enum(["PBR", "Shaded"]).register(z.globalRegistry, {
      description:
        "Material type. Possible values: PBR, Shaded. Default is PBR.",
    }),
  ),
});

/**
 * MultiViewObjectOutput
 */
export const zHunyuan3dV2MultiViewTurboOutput = z.object({
  model_mesh: zFile,
  seed: z.int().register(z.globalRegistry, {
    description: "Seed value used for generation.",
  }),
});

/**
 * Hunyuan3DInputMultiView
 */
export const zHunyuan3dV2MultiViewTurboInput = z.object({
  front_image_url: z.union([z.string(), z.string()]),
  octree_resolution: z
    .optional(
      z.int().gte(1).lte(1024).register(z.globalRegistry, {
        description: "Octree resolution for the model.",
      }),
    )
    .default(256),
  back_image_url: z.union([z.string(), z.string()]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "Guidance scale for the model.",
      }),
    )
    .default(7.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps to perform.",
      }),
    )
    .default(50),
  textured_mesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set true, textured mesh will be generated and the price charged would be 3 times that of white mesh.",
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  left_image_url: z.union([z.string(), z.string()]),
});

/**
 * ObjectOutput
 */
export const zHunyuan3dV2Output = z.object({
  model_mesh: zFile,
  seed: z.int().register(z.globalRegistry, {
    description: "Seed value used for generation.",
  }),
});

/**
 * Hunyuan3DInput
 */
export const zHunyuan3dV2Input = z.object({
  input_image_url: z.union([z.string(), z.string()]),
  octree_resolution: z
    .optional(
      z.int().gte(1).lte(1024).register(z.globalRegistry, {
        description: "Octree resolution for the model.",
      }),
    )
    .default(256),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "Guidance scale for the model.",
      }),
    )
    .default(7.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps to perform.",
      }),
    )
    .default(50),
  textured_mesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set true, textured mesh will be generated and the price charged would be 3 times that of white mesh.",
      }),
    )
    .default(false),
});

/**
 * ObjectOutput
 */
export const zHunyuan3dV2MiniTurboOutput = z.object({
  model_mesh: zFile,
  seed: z.int().register(z.globalRegistry, {
    description: "Seed value used for generation.",
  }),
});

/**
 * Hunyuan3DInput
 */
export const zHunyuan3dV2MiniTurboInput = z.object({
  input_image_url: z.union([z.string(), z.string()]),
  octree_resolution: z
    .optional(
      z.int().gte(1).lte(1024).register(z.globalRegistry, {
        description: "Octree resolution for the model.",
      }),
    )
    .default(256),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "Guidance scale for the model.",
      }),
    )
    .default(7.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps to perform.",
      }),
    )
    .default(50),
  textured_mesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set true, textured mesh will be generated and the price charged would be 3 times that of white mesh.",
      }),
    )
    .default(false),
});

/**
 * ObjectOutput
 */
export const zHunyuan3dV2TurboOutput = z.object({
  model_mesh: zFile,
  seed: z.int().register(z.globalRegistry, {
    description: "Seed value used for generation.",
  }),
});

/**
 * Hunyuan3DInput
 */
export const zHunyuan3dV2TurboInput = z.object({
  input_image_url: z.union([z.string(), z.string()]),
  octree_resolution: z
    .optional(
      z.int().gte(1).lte(1024).register(z.globalRegistry, {
        description: "Octree resolution for the model.",
      }),
    )
    .default(256),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "Guidance scale for the model.",
      }),
    )
    .default(7.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps to perform.",
      }),
    )
    .default(50),
  textured_mesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set true, textured mesh will be generated and the price charged would be 3 times that of white mesh.",
      }),
    )
    .default(false),
});

/**
 * ObjectOutput
 */
export const zHunyuan3dV2MiniOutput = z.object({
  model_mesh: zFile,
  seed: z.int().register(z.globalRegistry, {
    description: "Seed value used for generation.",
  }),
});

/**
 * Hunyuan3DInput
 */
export const zHunyuan3dV2MiniInput = z.object({
  input_image_url: z.union([z.string(), z.string()]),
  octree_resolution: z
    .optional(
      z.int().gte(1).lte(1024).register(z.globalRegistry, {
        description: "Octree resolution for the model.",
      }),
    )
    .default(256),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "Guidance scale for the model.",
      }),
    )
    .default(7.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps to perform.",
      }),
    )
    .default(50),
  textured_mesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set true, textured mesh will be generated and the price charged would be 3 times that of white mesh.",
      }),
    )
    .default(false),
});

/**
 * MultiViewObjectOutput
 */
export const zHunyuan3dV2MultiViewOutput = z.object({
  model_mesh: zFile,
  seed: z.int().register(z.globalRegistry, {
    description: "Seed value used for generation.",
  }),
});

/**
 * Hunyuan3DInputMultiView
 */
export const zHunyuan3dV2MultiViewInput = z.object({
  front_image_url: z.union([z.string(), z.string()]),
  octree_resolution: z
    .optional(
      z.int().gte(1).lte(1024).register(z.globalRegistry, {
        description: "Octree resolution for the model.",
      }),
    )
    .default(256),
  back_image_url: z.union([z.string(), z.string()]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "Guidance scale for the model.",
      }),
    )
    .default(7.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps to perform.",
      }),
    )
    .default(50),
  textured_mesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set true, textured mesh will be generated and the price charged would be 3 times that of white mesh.",
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  left_image_url: z.union([z.string(), z.string()]),
});

/**
 * Tripo3dOutput
 */
export const zTripoV25ImageTo3dOutput = z.object({
  base_model: z.optional(zFile),
  task_id: z.string().register(z.globalRegistry, {
    description: "The task id of the 3D model generation.",
  }),
  rendered_image: z.optional(zFile),
  model_mesh: z.optional(zFile),
  pbr_model: z.optional(zFile),
});

/**
 * ImageTo3dInput
 */
export const zTripoV25ImageTo3dInput = z.object({
  face_limit: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Limits the number of faces on the output model. If this option is not set, the face limit will be adaptively determined.",
    }),
  ),
  style: z.optional(
    z
      .enum([
        "person:person2cartoon",
        "object:clay",
        "object:steampunk",
        "animal:venom",
        "object:barbie",
        "object:christmas",
        "gold",
        "ancient_bronze",
      ])
      .register(z.globalRegistry, {
        description:
          "[DEPRECATED] Defines the artistic style or transformation to be applied to the 3D model, altering its appearance according to preset options (extra $0.05 per generation). Omit this option to keep the original style and apperance.",
      }),
  ),
  pbr: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "A boolean option to enable pbr. The default value is True, set False to get a model without pbr. If this option is set to True, texture will be ignored and used as True.",
      }),
    )
    .default(false),
  texture_alignment: z.optional(
    z.enum(["original_image", "geometry"]).register(z.globalRegistry, {
      description:
        "Determines the prioritization of texture alignment in the 3D model. The default value is original_image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  texture: z.optional(
    z.enum(["no", "standard", "HD"]).register(z.globalRegistry, {
      description:
        "An option to enable texturing. Default is 'standard', set 'no' to get a model without any textures, and set 'HD' to get a model with hd quality textures.",
    }),
  ),
  auto_size: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Automatically scale the model to real-world dimensions, with the unit in meters. The default value is False.",
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "This is the random seed for model generation. The seed controls the geometry generation process, ensuring identical models when the same seed is used. This parameter is an integer and is randomly chosen if not set.",
    }),
  ),
  quad: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Set True to enable quad mesh output (extra $0.05 per generation). If quad=True and face_limit is not set, the default face_limit will be 10000. Note: Enabling this option will force the output to be an FBX model.",
      }),
    )
    .default(false),
  orientation: z.optional(
    z.enum(["default", "align_image"]).register(z.globalRegistry, {
      description:
        "Set orientation=align_image to automatically rotate the model to align the original image. The default value is default.",
    }),
  ),
  texture_seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "This is the random seed for texture generation. Using the same seed will produce identical textures. This parameter is an integer and is randomly chosen if not set. If you want a model with different textures, please use same seed and different texture_seed.",
    }),
  ),
});

/**
 * ObjectOutput
 */
export const zTrellisMultiOutput = z.object({
  model_mesh: zFileType2,
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: "Processing timings",
  }),
});

/**
 * MultiImageInputModel
 */
export const zTrellisMultiInput = z.object({
  multiimage_algo: z.optional(
    z.enum(["stochastic", "multidiffusion"]).register(z.globalRegistry, {
      description: "Algorithm for multi-image generation",
    }),
  ),
  slat_sampling_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Sampling steps for structured latent generation",
      }),
    )
    .default(12),
  ss_sampling_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Sampling steps for sparse structure generation",
      }),
    )
    .default(12),
  ss_guidance_strength: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: "Guidance strength for sparse structure generation",
      }),
    )
    .default(7.5),
  slat_guidance_strength: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: "Guidance strength for structured latent generation",
      }),
    )
    .default(3),
  mesh_simplify: z
    .optional(
      z.number().gte(0.9).lte(0.98).register(z.globalRegistry, {
        description: "Mesh simplification factor",
      }),
    )
    .default(0.95),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  texture_size: z.optional(
    z
      .union([z.literal(512), z.literal(1024), z.literal(2048)])
      .register(z.globalRegistry, {
        description: "Texture resolution",
      }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: "List of URLs of input images to convert to 3D",
  }),
});

/**
 * ObjectOutput
 */
export const zHunyuan3dV21Output = z.object({
  model_glb_pbr: z.optional(zFile),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed value used for generation.",
  }),
  model_mesh: zFile,
  model_glb: zFile,
});

/**
 * Hunyuan3DInput
 */
export const zHunyuan3dV21Input = z.object({
  input_image_url: z.union([z.string(), z.string()]),
  octree_resolution: z
    .optional(
      z.int().gte(1).lte(1024).register(z.globalRegistry, {
        description: "Octree resolution for the model.",
      }),
    )
    .default(256),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "Guidance scale for the model.",
      }),
    )
    .default(7.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps to perform.",
      }),
    )
    .default(50),
  textured_mesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set true, textured mesh will be generated and the price charged would be 3 times that of white mesh.",
      }),
    )
    .default(false),
});

/**
 * Tripo3dOutput
 */
export const zTripoV25MultiviewTo3dOutput = z.object({
  base_model: z.optional(zFile),
  task_id: z.string().register(z.globalRegistry, {
    description: "The task id of the 3D model generation.",
  }),
  rendered_image: z.optional(zFile),
  model_mesh: z.optional(zFile),
  pbr_model: z.optional(zFile),
});

/**
 * MultiviewTo3dInput
 */
export const zTripoV25MultiviewTo3dInput = z.object({
  face_limit: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Limits the number of faces on the output model. If this option is not set, the face limit will be adaptively determined.",
    }),
  ),
  right_image_url: z.optional(z.union([z.string(), z.string()])),
  style: z.optional(
    z
      .enum([
        "person:person2cartoon",
        "object:clay",
        "object:steampunk",
        "animal:venom",
        "object:barbie",
        "object:christmas",
        "gold",
        "ancient_bronze",
      ])
      .register(z.globalRegistry, {
        description:
          "[DEPRECATED] Defines the artistic style or transformation to be applied to the 3D model, altering its appearance according to preset options (extra $0.05 per generation). Omit this option to keep the original style and apperance.",
      }),
  ),
  quad: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Set True to enable quad mesh output (extra $0.05 per generation). If quad=True and face_limit is not set, the default face_limit will be 10000. Note: Enabling this option will force the output to be an FBX model.",
      }),
    )
    .default(false),
  front_image_url: z.union([z.string(), z.string()]),
  texture_seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "This is the random seed for texture generation. Using the same seed will produce identical textures. This parameter is an integer and is randomly chosen if not set. If you want a model with different textures, please use same seed and different texture_seed.",
    }),
  ),
  back_image_url: z.optional(z.union([z.string(), z.string()])),
  pbr: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "A boolean option to enable pbr. The default value is True, set False to get a model without pbr. If this option is set to True, texture will be ignored and used as True.",
      }),
    )
    .default(false),
  texture_alignment: z.optional(
    z.enum(["original_image", "geometry"]).register(z.globalRegistry, {
      description:
        "Determines the prioritization of texture alignment in the 3D model. The default value is original_image.",
    }),
  ),
  texture: z.optional(
    z.enum(["no", "standard", "HD"]).register(z.globalRegistry, {
      description:
        "An option to enable texturing. Default is 'standard', set 'no' to get a model without any textures, and set 'HD' to get a model with hd quality textures.",
    }),
  ),
  auto_size: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Automatically scale the model to real-world dimensions, with the unit in meters. The default value is False.",
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "This is the random seed for model generation. The seed controls the geometry generation process, ensuring identical models when the same seed is used. This parameter is an integer and is randomly chosen if not set.",
    }),
  ),
  orientation: z.optional(
    z.enum(["default", "align_image"]).register(z.globalRegistry, {
      description:
        "Set orientation=align_image to automatically rotate the model to align the original image. The default value is default.",
    }),
  ),
  left_image_url: z.optional(z.union([z.string(), z.string()])),
});

/**
 * ImageToWorldResponse
 */
export const zHunyuanWorldImageToWorldOutput = z.object({
  world_file: zFile,
});

/**
 * ImageToWorldRequest
 */
export const zHunyuanWorldImageToWorldInput = z.object({
  classes: z.string().register(z.globalRegistry, {
    description: "Classes to use for the world generation.",
  }),
  export_drc: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to export DRC (Dynamic Resource Configuration).",
      }),
    )
    .default(false),
  labels_fg1: z.string().register(z.globalRegistry, {
    description: "Labels for the first foreground object.",
  }),
  labels_fg2: z.string().register(z.globalRegistry, {
    description: "Labels for the second foreground object.",
  }),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * PSHumanResponse
 */
export const zPshumanOutput = z.object({
  model_obj: zFile,
  preview_image: zFile,
});

/**
 * PSHumanRequest
 */
export const zPshumanInput = z.object({
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "Guidance scale for the diffusion process. Controls how much the output adheres to the generated views.",
      }),
    )
    .default(4),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Seed for reproducibility. If None, a random seed will be used.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * ObjectOutputv2
 */
export const zHyper3dRodinV2Output = z.object({
  model_mesh: zFile,
  seed: z.int().register(z.globalRegistry, {
    description: "Seed value used for generation.",
  }),
  textures: z.array(zImage).register(z.globalRegistry, {
    description: "Generated textures for the 3D object.",
  }),
});

/**
 * RodinGen2Input
 */
export const zHyper3dRodinV2Input = z.object({
  quality_mesh_option: z.optional(
    z
      .enum([
        "4K Quad",
        "8K Quad",
        "18K Quad",
        "50K Quad",
        "2K Triangle",
        "20K Triangle",
        "150K Triangle",
        "500K Triangle",
      ])
      .register(z.globalRegistry, {
        description:
          "Combined quality and mesh type selection. Quad = smooth surfaces, Triangle = detailed geometry. These corresponds to `mesh_mode` (if the option contains 'Triangle', mesh_mode is 'Raw', otherwise 'Quad') and `quality_override` (the numeric part of the option) parameters in Hyper3D API.",
      }),
  ),
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "A textual prompt to guide model generation. Optional for Image-to-3D mode - if empty, AI will generate a prompt based on your images.",
      }),
    )
    .default(""),
  preview_render: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Generate a preview render image of the 3D model along with the model files.",
      }),
    )
    .default(false),
  bbox_condition: z.optional(
    z.array(z.int()).register(z.globalRegistry, {
      description:
        "An array that specifies the bounding box dimensions [width, height, length].",
    }),
  ),
  TAPose: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Generate characters in T-pose or A-pose format, making them easier to rig and animate in 3D software.",
      }),
    )
    .default(false),
  input_image_urls: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        "URL of images to use while generating the 3D model. Required for Image-to-3D mode. Up to 5 images allowed.",
    }),
  ),
  use_original_alpha: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "When enabled, preserves the transparency channel from input images during 3D generation.",
      }),
    )
    .default(false),
  geometry_file_format: z.optional(
    z.enum(["glb", "usdz", "fbx", "obj", "stl"]).register(z.globalRegistry, {
      description:
        "Format of the geometry file. Possible values: glb, usdz, fbx, obj, stl. Default is glb.",
    }),
  ),
  addons: z.optional(
    z.enum(["HighPack"]).register(z.globalRegistry, {
      description:
        "The HighPack option will provide 4K resolution textures instead of the default 1K, as well as models with high-poly. It will cost **triple the billable units**.",
    }),
  ),
  seed: z.optional(
    z.int().gte(0).lte(65535).register(z.globalRegistry, {
      description:
        "Seed value for randomization, ranging from 0 to 65535. Optional.",
    }),
  ),
  material: z.optional(
    z.enum(["PBR", "Shaded", "All"]).register(z.globalRegistry, {
      description:
        "Material type. PBR: Physically-based materials with realistic lighting. Shaded: Simple materials with baked lighting. All: Both types included.",
    }),
  ),
});

/**
 * ImageTo3DOutput
 *
 * Output for Image to 3D conversion
 */
export const zMeshyV6PreviewImageTo3dOutput = z
  .object({
    model_urls: zModelUrlsType3,
    texture_urls: z.optional(
      z.array(zTextureFiles).register(z.globalRegistry, {
        description:
          "Array of texture file objects, matching Meshy API structure",
      }),
    ),
    thumbnail: z.optional(zFile),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: "The seed used for generation (if available)",
      }),
    ),
    model_glb: zFile,
  })
  .register(z.globalRegistry, {
    description: "Output for Image to 3D conversion",
  });

/**
 * ImageTo3DInput
 *
 * Input for Image to 3D conversion
 */
export const zMeshyV6PreviewImageTo3dInput = z
  .object({
    enable_pbr: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Generate PBR Maps (metallic, roughness, normal) in addition to base color",
        }),
      )
      .default(false),
    is_a_t_pose: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether to generate the model in an A/T pose",
        }),
      )
      .default(false),
    target_polycount: z
      .optional(
        z.int().gte(100).lte(300000).register(z.globalRegistry, {
          description: "Target number of polygons in the generated model",
        }),
      )
      .default(30000),
    should_texture: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether to generate textures",
        }),
      )
      .default(true),
    texture_image_url: z.optional(z.union([z.string(), z.string()])),
    topology: z.optional(
      z.enum(["quad", "triangle"]).register(z.globalRegistry, {
        description:
          "Specify the topology of the generated model. Quad for smooth surfaces, Triangle for detailed geometry.",
      }),
    ),
    image_url: z.union([z.string(), z.string()]),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If set to true, input data will be checked for safety before processing.",
        }),
      )
      .default(true),
    symmetry_mode: z.optional(
      z.enum(["off", "auto", "on"]).register(z.globalRegistry, {
        description:
          "Controls symmetry behavior during model generation. Off disables symmetry, Auto determines it automatically, On enforces symmetry.",
      }),
    ),
    texture_prompt: z.optional(
      z.string().max(600).register(z.globalRegistry, {
        description: "Text prompt to guide the texturing process",
      }),
    ),
    should_remesh: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether to enable the remesh phase",
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: "Input for Image to 3D conversion",
  });

/**
 * MultiImageTo3DOutput
 *
 * Output for Multi-Image to 3D conversion
 */
export const zMeshyV5MultiImageTo3dOutput = z
  .object({
    model_urls: zModelUrlsType3,
    texture_urls: z.optional(
      z.array(zTextureFiles).register(z.globalRegistry, {
        description: "Array of texture file objects",
      }),
    ),
    thumbnail: z.optional(zFile),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: "The seed used for generation (if available)",
      }),
    ),
    model_glb: zFile,
  })
  .register(z.globalRegistry, {
    description: "Output for Multi-Image to 3D conversion",
  });

/**
 * MultiImageTo3DInput
 *
 * Input for Multi-Image to 3D conversion
 */
export const zMeshyV5MultiImageTo3dInput = z
  .object({
    enable_pbr: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Generate PBR Maps (metallic, roughness, normal) in addition to base color. Requires should_texture to be true.",
        }),
      )
      .default(false),
    should_texture: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to generate textures. False provides mesh without textures for 5 credits, True adds texture generation for additional 10 credits.",
        }),
      )
      .default(true),
    target_polycount: z
      .optional(
        z.int().gte(100).lte(300000).register(z.globalRegistry, {
          description: "Target number of polygons in the generated model",
        }),
      )
      .default(30000),
    is_a_t_pose: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether to generate the model in an A/T pose",
        }),
      )
      .default(false),
    texture_image_url: z.optional(z.union([z.string(), z.string()])),
    topology: z.optional(
      z.enum(["quad", "triangle"]).register(z.globalRegistry, {
        description:
          "Specify the topology of the generated model. Quad for smooth surfaces, Triangle for detailed geometry.",
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If set to true, input data will be checked for safety before processing.",
        }),
      )
      .default(true),
    symmetry_mode: z.optional(
      z.enum(["off", "auto", "on"]).register(z.globalRegistry, {
        description: "Controls symmetry behavior during model generation.",
      }),
    ),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        "1 to 4 images for 3D model creation. All images should depict the same object from different angles. Supports .jpg, .jpeg, .png formats, and AVIF/HEIF which will be automatically converted. If more than 4 images are provided, only the first 4 will be used.",
    }),
    texture_prompt: z.optional(
      z.string().max(600).register(z.globalRegistry, {
        description:
          "Text prompt to guide the texturing process. Requires should_texture to be true.",
      }),
    ),
    should_remesh: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the remesh phase. When false, returns triangular mesh ignoring topology and target_polycount.",
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: "Input for Multi-Image to 3D conversion",
  });

/**
 * Seed3DImageTo3DOutput
 */
export const zBytedanceSeed3dImageTo3dOutput = z.object({
  model: zFile,
  usage_tokens: z.int().register(z.globalRegistry, {
    description: "The number of tokens used for the 3D model generation",
  }),
});

/**
 * Seed3DImageTo3DInput
 */
export const zBytedanceSeed3dImageTo3dInput = z.object({
  image_url: z.union([z.string(), z.string()]),
});

/**
 * MultiViewObjectOutput
 */
export const zOmnipartOutput = z.object({
  full_model_mesh: zFileType2,
  output_zip: zFileType2,
  seed: z.int().register(z.globalRegistry, {
    description: "Seed value used for generation.",
  }),
  model_mesh: zFileType2,
});

/**
 * OmnipartInput
 */
export const zOmnipartInput = z.object({
  input_image_url: z.union([z.string(), z.string()]),
  parts: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Specify which segments to merge (e.g., '0,1;3,4' merges segments 0&1 together and 3&4 together)",
      }),
    )
    .default(""),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description:
          "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
      }),
    )
    .default(765464),
  minimum_segment_size: z
    .optional(
      z.int().gte(1).lte(10000).register(z.globalRegistry, {
        description: "Minimum segment size (pixels) for the model.",
      }),
    )
    .default(2000),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "Guidance scale for the model.",
      }),
    )
    .default(7.5),
});

/**
 * SAM3DObjectMetadata
 *
 * Per-object metadata for 3D reconstruction.
 */
export const zSam3dObjectMetadata = z
  .object({
    rotation: z.optional(
      z.array(z.array(z.number())).register(z.globalRegistry, {
        description: "Rotation quaternion [x, y, z, w]",
      }),
    ),
    translation: z.optional(
      z.array(z.array(z.number())).register(z.globalRegistry, {
        description: "Translation [tx, ty, tz]",
      }),
    ),
    object_index: z.int().register(z.globalRegistry, {
      description: "Index of the object in the scene",
    }),
    scale: z.optional(
      z.array(z.array(z.number())).register(z.globalRegistry, {
        description: "Scale factors [sx, sy, sz]",
      }),
    ),
    camera_pose: z.optional(
      z.array(z.array(z.number())).register(z.globalRegistry, {
        description: "Camera pose matrix",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "Per-object metadata for 3D reconstruction.",
  });

/**
 * PointPromptBase
 */
export const zPointPromptBase = z.object({
  y: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Y Coordinate of the prompt",
    }),
  ),
  x: z.optional(
    z.int().register(z.globalRegistry, {
      description: "X Coordinate of the prompt",
    }),
  ),
  object_id: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Optional object identifier. Prompts sharing an object id refine the same object.",
    }),
  ),
  label: z.optional(
    z.union([z.literal(0), z.literal(1)]).register(z.globalRegistry, {
      description: "1 for foreground, 0 for background",
    }),
  ),
});

/**
 * BoxPromptBase
 */
export const zBoxPromptBase = z.object({
  y_min: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Y Min Coordinate of the box",
    }),
  ),
  object_id: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Optional object identifier. Boxes sharing an object id refine the same object.",
    }),
  ),
  x_max: z.optional(
    z.int().register(z.globalRegistry, {
      description: "X Max Coordinate of the box",
    }),
  ),
  x_min: z.optional(
    z.int().register(z.globalRegistry, {
      description: "X Min Coordinate of the box",
    }),
  ),
  y_max: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Y Max Coordinate of the box",
    }),
  ),
});

/**
 * SAM3DObjectOutput
 */
export const zSam33dObjectsOutput = z.object({
  model_glb: z.optional(zFile),
  metadata: z.array(zSam3dObjectMetadata).register(z.globalRegistry, {
    description: "Per-object metadata (rotation/translation/scale)",
  }),
  gaussian_splat: zFile,
  artifacts_zip: z.optional(zFile),
  individual_glbs: z.optional(
    z.array(zFile).register(z.globalRegistry, {
      description:
        "Individual GLB mesh files per object (only for multi-object scenes)",
    }),
  ),
  individual_splats: z.optional(
    z.array(zFile).register(z.globalRegistry, {
      description:
        "Individual Gaussian splat files per object (only for multi-object scenes)",
    }),
  ),
});

/**
 * SAM3DObjectInput
 */
export const zSam33dObjectsInput = z.object({
  pointmap_url: z.optional(z.union([z.string(), z.string()])),
  export_textured_glb: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If True, exports GLB with baked texture and UVs instead of vertex colors.",
      }),
    )
    .default(false),
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Text prompt for auto-segmentation when no masks provided (e.g., 'chair', 'lamp')",
      }),
    )
    .default("car"),
  box_prompts: z
    .optional(
      z.array(zBoxPromptBase).register(z.globalRegistry, {
        description:
          "Box prompts for auto-segmentation when no masks provided. Multiple boxes supported - each produces a separate object mask for 3D reconstruction.",
      }),
    )
    .default([]),
  image_url: z.union([z.string(), z.string()]),
  mask_urls: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        "Optional list of mask URLs (one per object). If not provided, use prompt/point_prompts/box_prompts to auto-segment, or entire image will be used.",
    }),
  ),
  point_prompts: z
    .optional(
      z.array(zPointPromptBase).register(z.globalRegistry, {
        description:
          "Point prompts for auto-segmentation when no masks provided",
      }),
    )
    .default([]),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Random seed for reproducibility",
    }),
  ),
});

/**
 * SAM3DBodyPersonMetadata
 *
 * Per-person metadata for body reconstruction.
 */
export const zSam3dBodyPersonMetadata = z
  .object({
    pred_cam_t: z.array(z.number()).register(z.globalRegistry, {
      description: "Predicted camera translation [tx, ty, tz]",
    }),
    person_id: z.int().register(z.globalRegistry, {
      description: "Index of the person in the scene",
    }),
    focal_length: z.number().register(z.globalRegistry, {
      description: "Estimated focal length",
    }),
    keypoints_3d: z.optional(
      z.array(z.array(z.number())).register(z.globalRegistry, {
        description:
          "3D keypoints [[x, y, z], ...] - 70 body keypoints in camera space",
      }),
    ),
    keypoints_2d: z.array(z.array(z.number())).register(z.globalRegistry, {
      description: "2D keypoints [[x, y], ...] - 70 body keypoints",
    }),
    bbox: z.array(z.number()).register(z.globalRegistry, {
      description: "Bounding box [x_min, y_min, x_max, y_max]",
    }),
  })
  .register(z.globalRegistry, {
    description: "Per-person metadata for body reconstruction.",
  });

/**
 * SAM3DBodyMetadata
 *
 * Metadata for body reconstruction output.
 */
export const zSam3dBodyMetadata = z
  .object({
    people: z.array(zSam3dBodyPersonMetadata).register(z.globalRegistry, {
      description: "Per-person metadata",
    }),
    num_people: z.int().register(z.globalRegistry, {
      description: "Number of people detected",
    }),
  })
  .register(z.globalRegistry, {
    description: "Metadata for body reconstruction output.",
  });

/**
 * SAM3DBodyOutput
 */
export const zSam33dBodyOutput = z.object({
  visualization: zFile,
  metadata: zSam3dBodyMetadata,
  meshes: z.optional(
    z.array(zFile).register(z.globalRegistry, {
      description:
        "Individual mesh files (.ply), one per detected person (when export_meshes=True)",
    }),
  ),
  model_glb: zFile,
});

/**
 * SAM3DBodyInput
 */
export const zSam33dBodyInput = z.object({
  include_3d_keypoints: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Include 3D keypoint markers (spheres) in the GLB mesh for visualization",
      }),
    )
    .default(true),
  export_meshes: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Export individual mesh files (.ply) per person",
      }),
    )
    .default(true),
  mask_url: z.optional(z.union([z.string(), z.string()])),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * ImageTo3DOutput
 */
export const zHunyuan3dV3ImageTo3dOutput = z.object({
  model_urls: zModelUrlsType2,
  thumbnail: z.optional(zFile),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The seed used for generation",
    }),
  ),
  model_glb: zFile,
});

/**
 * ImageTo3DInput
 */
export const zHunyuan3dV3ImageTo3dInput = z.object({
  input_image_url: z.union([z.string(), z.string()]),
  polygon_type: z.optional(
    z.enum(["triangle", "quadrilateral"]).register(z.globalRegistry, {
      description:
        "Polygon type. Only takes effect when GenerateType is LowPoly.",
    }),
  ),
  face_count: z
    .optional(
      z.int().gte(40000).lte(1500000).register(z.globalRegistry, {
        description: "Target face count. Range: 40000-1500000",
      }),
    )
    .default(500000),
  right_image_url: z.optional(z.union([z.string(), z.string()])),
  back_image_url: z.optional(z.union([z.string(), z.string()])),
  enable_pbr: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to enable PBR material generation. Does not take effect when generate_type is Geometry.",
      }),
    )
    .default(false),
  generate_type: z.optional(
    z.enum(["Normal", "LowPoly", "Geometry"]).register(z.globalRegistry, {
      description:
        "Generation type. Normal: textured model. LowPoly: polygon reduction. Geometry: white model without texture.",
    }),
  ),
  left_image_url: z.optional(z.union([z.string(), z.string()])),
});

/**
 * SketchTo3DOutput
 */
export const zHunyuan3dV3SketchTo3dOutput = z.object({
  model_urls: zModelUrlsType2,
  thumbnail: z.optional(zFile),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The seed used for generation",
    }),
  ),
  model_glb: zFile,
});

/**
 * SketchTo3DInput
 */
export const zHunyuan3dV3SketchTo3dInput = z.object({
  input_image_url: z.union([z.string(), z.string()]),
  prompt: z.string().max(1024).register(z.globalRegistry, {
    description:
      "Text prompt describing the 3D content attributes such as color, category, and material.",
  }),
  face_count: z
    .optional(
      z.int().gte(40000).lte(1500000).register(z.globalRegistry, {
        description: "Target face count. Range: 40000-1500000",
      }),
    )
    .default(500000),
  enable_pbr: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enable PBR material generation.",
      }),
    )
    .default(false),
});

/**
 * ObjectOutput
 */
export const zTrellis2Output = z.object({
  model_glb: zFile,
});

/**
 * SingleImageInputModel
 */
export const zTrellis2Input = z.object({
  remesh_band: z.optional(z.number().gte(0).lte(4)).default(1),
  ss_guidance_rescale: z.optional(z.number().gte(0).lte(1)).default(0.7),
  ss_rescale_t: z.optional(z.number().gte(1).lte(6)).default(5),
  shape_slat_sampling_steps: z.optional(z.int().gte(1).lte(50)).default(12),
  tex_slat_rescale_t: z.optional(z.number().gte(1).lte(6)).default(3),
  ss_guidance_strength: z.optional(z.number().gte(0).lte(10)).default(7.5),
  ss_sampling_steps: z.optional(z.int().gte(1).lte(50)).default(12),
  tex_slat_sampling_steps: z.optional(z.int().gte(1).lte(50)).default(12),
  remesh_project: z.optional(z.number().gte(0).lte(1)).default(0),
  texture_size: z.optional(
    z
      .union([z.literal(1024), z.literal(2048), z.literal(4096)])
      .register(z.globalRegistry, {
        description: "Texture resolution",
      }),
  ),
  shape_slat_rescale_t: z.optional(z.number().gte(1).lte(6)).default(3),
  resolution: z.optional(
    z
      .union([z.literal(512), z.literal(1024), z.literal(1536)])
      .register(z.globalRegistry, {
        description: "Output resolution; higher is slower but more detailed",
      }),
  ),
  remesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Run remeshing (slower; often improves topology)",
      }),
    )
    .default(true),
  tex_slat_guidance_rescale: z.optional(z.number().gte(0).lte(1)).default(0),
  shape_slat_guidance_rescale: z
    .optional(z.number().gte(0).lte(1))
    .default(0.5),
  image_url: z.union([z.string(), z.string()]),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Random seed for reproducibility",
    }),
  ),
  shape_slat_guidance_strength: z
    .optional(z.number().gte(0).lte(10))
    .default(7.5),
  tex_slat_guidance_strength: z.optional(z.number().gte(0).lte(10)).default(1),
  decimation_target: z
    .optional(
      z.int().gte(100000).lte(2000000).register(z.globalRegistry, {
        description:
          "Target vertex count for mesh simplification during export",
      }),
    )
    .default(500000),
});

/**
 * ProImageTo3DOutput
 */
export const zHunyuan3dV31ProImageTo3dOutput = z.object({
  model_urls: zModelUrls,
  thumbnail: z.optional(zFile),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The seed used for generation",
    }),
  ),
  model_glb: zFile,
});

/**
 * ProImageTo3DInput
 */
export const zHunyuan3dV31ProImageTo3dInput = z.object({
  input_image_url: z.union([z.string(), z.string()]),
  enable_pbr: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Enable PBR material generation (metallic, roughness, normal textures). Ignored when generate_type is Geometry.",
      }),
    )
    .default(false),
  back_image_url: z.optional(z.union([z.string(), z.string()])),
  right_front_image_url: z.optional(z.union([z.string(), z.string()])),
  right_image_url: z.optional(z.union([z.string(), z.string()])),
  bottom_image_url: z.optional(z.union([z.string(), z.string()])),
  face_count: z
    .optional(
      z.int().gte(40000).lte(1500000).register(z.globalRegistry, {
        description:
          "Target polygon face count. Range: 40,000-1,500,000. Default: 500,000.",
      }),
    )
    .default(500000),
  top_image_url: z.optional(z.union([z.string(), z.string()])),
  left_front_image_url: z.optional(z.union([z.string(), z.string()])),
  generate_type: z.optional(
    z.enum(["Normal", "Geometry"]).register(z.globalRegistry, {
      description:
        "Generation task type. Normal: textured model. Geometry: geometry-only white model (no textures). LowPoly/Sketch are not available in v3.1.",
    }),
  ),
  left_image_url: z.optional(z.union([z.string(), z.string()])),
});

/**
 * RapidImageTo3DOutput
 */
export const zHunyuan3dV31RapidImageTo3dOutput = z.object({
  model_urls: zModelUrls,
  texture: z.optional(zFile),
  thumbnail: z.optional(zFile),
  material_mtl: z.optional(zFile),
  model_glb: z.optional(zFile),
});

/**
 * RapidImageTo3DInput
 */
export const zHunyuan3dV31RapidImageTo3dInput = z.object({
  input_image_url: z.union([z.string(), z.string()]),
  enable_pbr: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Enable PBR material generation (metallic, roughness, normal textures). Does not take effect when enable_geometry is True.",
      }),
    )
    .default(false),
  enable_geometry: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Generate geometry-only white model without textures. When enabled, enable_pbr is ignored and OBJ is not supported (default output is GLB).",
      }),
    )
    .default(false),
});

/**
 * SmartTopologyOutput
 */
export const zHunyuan3dV31SmartTopologyOutput = z.object({
  model_urls: zModelUrls,
  model_glb: zFile,
});

/**
 * SmartTopologyInput
 */
export const zHunyuan3dV31SmartTopologyInput = z.object({
  polygon_type: z.optional(
    z.enum(["triangle", "quadrilateral"]).register(z.globalRegistry, {
      description:
        "Output polygon type. triangle: triangular faces only. quadrilateral: mixed quad and triangle faces.",
    }),
  ),
  face_level: z.optional(
    z.enum(["high", "medium", "low"]).register(z.globalRegistry, {
      description:
        "Target polygon density. high: more detail/polygons, medium: balanced, low: fewer polygons.",
    }),
  ),
  input_file_url: z.optional(z.union([z.string(), z.string()])),
  input_file_type: z.optional(
    z.enum(["glb", "obj"]).register(z.globalRegistry, {
      description: "Input 3D file format.",
    }),
  ),
});

export const zQueueStatus = z.object({
  status: z.enum(["IN_QUEUE", "IN_PROGRESS", "COMPLETED"]),
  request_id: z.string().register(z.globalRegistry, {
    description: "The request id.",
  }),
  response_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The response url.",
    }),
  ),
  status_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The status url.",
    }),
  ),
  cancel_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The cancel url.",
    }),
  ),
  logs: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: "The logs.",
    }),
  ),
  metrics: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: "The metrics.",
    }),
  ),
  queue_position: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The queue position.",
    }),
  ),
});

export const zGetFalAiHunyuan3dV31SmartTopologyRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV31SmartTopologyRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuan3dV31SmartTopologyRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV31SmartTopologyRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiHunyuan3dV31SmartTopologyData = z.object({
  body: zHunyuan3dV31SmartTopologyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV31SmartTopologyResponse = zQueueStatus;

export const zGetFalAiHunyuan3dV31SmartTopologyRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV31SmartTopologyRequestsByRequestIdResponse =
  zHunyuan3dV31SmartTopologyOutput;

export const zGetFalAiHunyuan3dV31RapidImageTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV31RapidImageTo3dRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuan3dV31RapidImageTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV31RapidImageTo3dRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiHunyuan3dV31RapidImageTo3dData = z.object({
  body: zHunyuan3dV31RapidImageTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV31RapidImageTo3dResponse = zQueueStatus;

export const zGetFalAiHunyuan3dV31RapidImageTo3dRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV31RapidImageTo3dRequestsByRequestIdResponse =
  zHunyuan3dV31RapidImageTo3dOutput;

export const zGetFalAiHunyuan3dV31ProImageTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV31ProImageTo3dRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuan3dV31ProImageTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV31ProImageTo3dRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiHunyuan3dV31ProImageTo3dData = z.object({
  body: zHunyuan3dV31ProImageTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV31ProImageTo3dResponse = zQueueStatus;

export const zGetFalAiHunyuan3dV31ProImageTo3dRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV31ProImageTo3dRequestsByRequestIdResponse =
  zHunyuan3dV31ProImageTo3dOutput;

export const zGetFalAiTrellis2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiTrellis2RequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiTrellis2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiTrellis2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiTrellis2Data = z.object({
  body: zTrellis2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiTrellis2Response = zQueueStatus;

export const zGetFalAiTrellis2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiTrellis2RequestsByRequestIdResponse = zTrellis2Output;

export const zGetFalAiHunyuan3dV3SketchTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV3SketchTo3dRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuan3dV3SketchTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV3SketchTo3dRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiHunyuan3dV3SketchTo3dData = z.object({
  body: zHunyuan3dV3SketchTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV3SketchTo3dResponse = zQueueStatus;

export const zGetFalAiHunyuan3dV3SketchTo3dRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV3SketchTo3dRequestsByRequestIdResponse =
  zHunyuan3dV3SketchTo3dOutput;

export const zGetFalAiHunyuan3dV3ImageTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV3ImageTo3dRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuan3dV3ImageTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV3ImageTo3dRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiHunyuan3dV3ImageTo3dData = z.object({
  body: zHunyuan3dV3ImageTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV3ImageTo3dResponse = zQueueStatus;

export const zGetFalAiHunyuan3dV3ImageTo3dRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV3ImageTo3dRequestsByRequestIdResponse =
  zHunyuan3dV3ImageTo3dOutput;

export const zGetFalAiSam33dBodyRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiSam33dBodyRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiSam33dBodyRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiSam33dBodyRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiSam33dBodyData = z.object({
  body: zSam33dBodyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiSam33dBodyResponse = zQueueStatus;

export const zGetFalAiSam33dBodyRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiSam33dBodyRequestsByRequestIdResponse = zSam33dBodyOutput;

export const zGetFalAiSam33dObjectsRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiSam33dObjectsRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiSam33dObjectsRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiSam33dObjectsRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiSam33dObjectsData = z.object({
  body: zSam33dObjectsInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiSam33dObjectsResponse = zQueueStatus;

export const zGetFalAiSam33dObjectsRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiSam33dObjectsRequestsByRequestIdResponse =
  zSam33dObjectsOutput;

export const zGetFalAiOmnipartRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiOmnipartRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiOmnipartRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiOmnipartRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiOmnipartData = z.object({
  body: zOmnipartInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiOmnipartResponse = zQueueStatus;

export const zGetFalAiOmnipartRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiOmnipartRequestsByRequestIdResponse = zOmnipartOutput;

export const zGetFalAiBytedanceSeed3dImageTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiBytedanceSeed3dImageTo3dRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiBytedanceSeed3dImageTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiBytedanceSeed3dImageTo3dRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiBytedanceSeed3dImageTo3dData = z.object({
  body: zBytedanceSeed3dImageTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiBytedanceSeed3dImageTo3dResponse = zQueueStatus;

export const zGetFalAiBytedanceSeed3dImageTo3dRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiBytedanceSeed3dImageTo3dRequestsByRequestIdResponse =
  zBytedanceSeed3dImageTo3dOutput;

export const zGetFalAiMeshyV5MultiImageTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiMeshyV5MultiImageTo3dRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiMeshyV5MultiImageTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiMeshyV5MultiImageTo3dRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiMeshyV5MultiImageTo3dData = z.object({
  body: zMeshyV5MultiImageTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiMeshyV5MultiImageTo3dResponse = zQueueStatus;

export const zGetFalAiMeshyV5MultiImageTo3dRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiMeshyV5MultiImageTo3dRequestsByRequestIdResponse =
  zMeshyV5MultiImageTo3dOutput;

export const zGetFalAiMeshyV6PreviewImageTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiMeshyV6PreviewImageTo3dRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiMeshyV6PreviewImageTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiMeshyV6PreviewImageTo3dRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiMeshyV6PreviewImageTo3dData = z.object({
  body: zMeshyV6PreviewImageTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiMeshyV6PreviewImageTo3dResponse = zQueueStatus;

export const zGetFalAiMeshyV6PreviewImageTo3dRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * Result of the request.
 */
export const zGetFalAiMeshyV6PreviewImageTo3dRequestsByRequestIdResponse =
  zMeshyV6PreviewImageTo3dOutput;

export const zGetFalAiHyper3dRodinV2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiHyper3dRodinV2RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHyper3dRodinV2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiHyper3dRodinV2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiHyper3dRodinV2Data = z.object({
  body: zHyper3dRodinV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHyper3dRodinV2Response = zQueueStatus;

export const zGetFalAiHyper3dRodinV2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiHyper3dRodinV2RequestsByRequestIdResponse =
  zHyper3dRodinV2Output;

export const zGetFalAiPshumanRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiPshumanRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiPshumanRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiPshumanRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiPshumanData = z.object({
  body: zPshumanInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPshumanResponse = zQueueStatus;

export const zGetFalAiPshumanRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiPshumanRequestsByRequestIdResponse = zPshumanOutput;

export const zGetFalAiHunyuanWorldImageToWorldRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiHunyuanWorldImageToWorldRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuanWorldImageToWorldRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuanWorldImageToWorldRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiHunyuanWorldImageToWorldData = z.object({
  body: zHunyuanWorldImageToWorldInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuanWorldImageToWorldResponse = zQueueStatus;

export const zGetFalAiHunyuanWorldImageToWorldRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiHunyuanWorldImageToWorldRequestsByRequestIdResponse =
  zHunyuanWorldImageToWorldOutput;

export const zGetTripo3dTripoV25MultiviewTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetTripo3dTripoV25MultiviewTo3dRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutTripo3dTripoV25MultiviewTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutTripo3dTripoV25MultiviewTo3dRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostTripo3dTripoV25MultiviewTo3dData = z.object({
  body: zTripoV25MultiviewTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostTripo3dTripoV25MultiviewTo3dResponse = zQueueStatus;

export const zGetTripo3dTripoV25MultiviewTo3dRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * Result of the request.
 */
export const zGetTripo3dTripoV25MultiviewTo3dRequestsByRequestIdResponse =
  zTripoV25MultiviewTo3dOutput;

export const zGetFalAiHunyuan3dV21RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV21RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuan3dV21RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV21RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiHunyuan3dV21Data = z.object({
  body: zHunyuan3dV21Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV21Response = zQueueStatus;

export const zGetFalAiHunyuan3dV21RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV21RequestsByRequestIdResponse =
  zHunyuan3dV21Output;

export const zGetFalAiTrellisMultiRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiTrellisMultiRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiTrellisMultiRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiTrellisMultiRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiTrellisMultiData = z.object({
  body: zTrellisMultiInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiTrellisMultiResponse = zQueueStatus;

export const zGetFalAiTrellisMultiRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiTrellisMultiRequestsByRequestIdResponse =
  zTrellisMultiOutput;

export const zGetTripo3dTripoV25ImageTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetTripo3dTripoV25ImageTo3dRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutTripo3dTripoV25ImageTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutTripo3dTripoV25ImageTo3dRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostTripo3dTripoV25ImageTo3dData = z.object({
  body: zTripoV25ImageTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostTripo3dTripoV25ImageTo3dResponse = zQueueStatus;

export const zGetTripo3dTripoV25ImageTo3dRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetTripo3dTripoV25ImageTo3dRequestsByRequestIdResponse =
  zTripoV25ImageTo3dOutput;

export const zGetFalAiHunyuan3dV2MultiViewRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV2MultiViewRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuan3dV2MultiViewRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV2MultiViewRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiHunyuan3dV2MultiViewData = z.object({
  body: zHunyuan3dV2MultiViewInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV2MultiViewResponse = zQueueStatus;

export const zGetFalAiHunyuan3dV2MultiViewRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV2MultiViewRequestsByRequestIdResponse =
  zHunyuan3dV2MultiViewOutput;

export const zGetFalAiHunyuan3dV2MiniRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV2MiniRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuan3dV2MiniRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV2MiniRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiHunyuan3dV2MiniData = z.object({
  body: zHunyuan3dV2MiniInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV2MiniResponse = zQueueStatus;

export const zGetFalAiHunyuan3dV2MiniRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV2MiniRequestsByRequestIdResponse =
  zHunyuan3dV2MiniOutput;

export const zGetFalAiHunyuan3dV2TurboRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV2TurboRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuan3dV2TurboRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV2TurboRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiHunyuan3dV2TurboData = z.object({
  body: zHunyuan3dV2TurboInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV2TurboResponse = zQueueStatus;

export const zGetFalAiHunyuan3dV2TurboRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV2TurboRequestsByRequestIdResponse =
  zHunyuan3dV2TurboOutput;

export const zGetFalAiHunyuan3dV2MiniTurboRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV2MiniTurboRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuan3dV2MiniTurboRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV2MiniTurboRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiHunyuan3dV2MiniTurboData = z.object({
  body: zHunyuan3dV2MiniTurboInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV2MiniTurboResponse = zQueueStatus;

export const zGetFalAiHunyuan3dV2MiniTurboRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV2MiniTurboRequestsByRequestIdResponse =
  zHunyuan3dV2MiniTurboOutput;

export const zGetFalAiHunyuan3dV2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV2RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuan3dV2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiHunyuan3dV2Data = z.object({
  body: zHunyuan3dV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV2Response = zQueueStatus;

export const zGetFalAiHunyuan3dV2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV2RequestsByRequestIdResponse =
  zHunyuan3dV2Output;

export const zGetFalAiHunyuan3dV2MultiViewTurboRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV2MultiViewTurboRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuan3dV2MultiViewTurboRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV2MultiViewTurboRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiHunyuan3dV2MultiViewTurboData = z.object({
  body: zHunyuan3dV2MultiViewTurboInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV2MultiViewTurboResponse = zQueueStatus;

export const zGetFalAiHunyuan3dV2MultiViewTurboRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV2MultiViewTurboRequestsByRequestIdResponse =
  zHunyuan3dV2MultiViewTurboOutput;

export const zGetFalAiHyper3dRodinRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiHyper3dRodinRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHyper3dRodinRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiHyper3dRodinRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiHyper3dRodinData = z.object({
  body: zHyper3dRodinInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHyper3dRodinResponse = zQueueStatus;

export const zGetFalAiHyper3dRodinRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiHyper3dRodinRequestsByRequestIdResponse =
  zHyper3dRodinOutput;

export const zGetFalAiTrellisRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiTrellisRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiTrellisRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiTrellisRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiTrellisData = z.object({
  body: zTrellisInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiTrellisResponse = zQueueStatus;

export const zGetFalAiTrellisRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiTrellisRequestsByRequestIdResponse = zTrellisOutput;

export const zGetFalAiTriposrRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiTriposrRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiTriposrRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiTriposrRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiTriposrData = z.object({
  body: zTriposrInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiTriposrResponse = zQueueStatus;

export const zGetFalAiTriposrRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiTriposrRequestsByRequestIdResponse = zTriposrOutput;

export const zGetFalAiHunyuan3dV31RapidTextTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV31RapidTextTo3dRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuan3dV31RapidTextTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV31RapidTextTo3dRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiHunyuan3dV31RapidTextTo3dData = z.object({
  body: zHunyuan3dV31RapidTextTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV31RapidTextTo3dResponse = zQueueStatus;

export const zGetFalAiHunyuan3dV31RapidTextTo3dRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV31RapidTextTo3dRequestsByRequestIdResponse =
  zHunyuan3dV31RapidTextTo3dOutput;

export const zGetFalAiHunyuan3dV31ProTextTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV31ProTextTo3dRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuan3dV31ProTextTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV31ProTextTo3dRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiHunyuan3dV31ProTextTo3dData = z.object({
  body: zHunyuan3dV31ProTextTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV31ProTextTo3dResponse = zQueueStatus;

export const zGetFalAiHunyuan3dV31ProTextTo3dRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV31ProTextTo3dRequestsByRequestIdResponse =
  zHunyuan3dV31ProTextTo3dOutput;

export const zGetFalAiHunyuanMotionFastRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiHunyuanMotionFastRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuanMotionFastRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuanMotionFastRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiHunyuanMotionFastData = z.object({
  body: zHunyuanMotionFastInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuanMotionFastResponse = zQueueStatus;

export const zGetFalAiHunyuanMotionFastRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiHunyuanMotionFastRequestsByRequestIdResponse =
  zHunyuanMotionFastOutput;

export const zGetFalAiHunyuanMotionRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiHunyuanMotionRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuanMotionRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuanMotionRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiHunyuanMotionData = z.object({
  body: zHunyuanMotionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuanMotionResponse = zQueueStatus;

export const zGetFalAiHunyuanMotionRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiHunyuanMotionRequestsByRequestIdResponse =
  zHunyuanMotionOutput;

export const zGetFalAiHunyuan3dV3TextTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV3TextTo3dRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuan3dV3TextTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV3TextTo3dRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiHunyuan3dV3TextTo3dData = z.object({
  body: zHunyuan3dV3TextTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV3TextTo3dResponse = zQueueStatus;

export const zGetFalAiHunyuan3dV3TextTo3dRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV3TextTo3dRequestsByRequestIdResponse =
  zHunyuan3dV3TextTo3dOutput;

export const zGetFalAiMeshyV6PreviewTextTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiMeshyV6PreviewTextTo3dRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiMeshyV6PreviewTextTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiMeshyV6PreviewTextTo3dRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiMeshyV6PreviewTextTo3dData = z.object({
  body: zMeshyV6PreviewTextTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiMeshyV6PreviewTextTo3dResponse = zQueueStatus;

export const zGetFalAiMeshyV6PreviewTextTo3dRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiMeshyV6PreviewTextTo3dRequestsByRequestIdResponse =
  zMeshyV6PreviewTextTo3dOutput;
