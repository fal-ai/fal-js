// This file is auto-generated by @hey-api/openapi-ts

import { z } from "zod";

/**
 * File
 */
export const zFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The size of the file in bytes.",
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "The name of the file. It will be auto-generated if not provided.",
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The mime type of the file.",
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: "The URL where the file can be downloaded from.",
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: "File data",
    }),
  ),
});

/**
 * Image
 *
 * Represents an image file.
 */
export const zImage = z
  .object({
    file_size: z.optional(
      z.int().register(z.globalRegistry, {
        description: "The size of the file in bytes.",
      }),
    ),
    height: z.optional(
      z.int().register(z.globalRegistry, {
        description: "The height of the image in pixels.",
      }),
    ),
    url: z.string().register(z.globalRegistry, {
      description: "The URL where the file can be downloaded from.",
    }),
    width: z.optional(
      z.int().register(z.globalRegistry, {
        description: "The width of the image in pixels.",
      }),
    ),
    file_name: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          "The name of the file. It will be auto-generated if not provided.",
      }),
    ),
    content_type: z.optional(
      z.string().register(z.globalRegistry, {
        description: "The mime type of the file.",
      }),
    ),
    file_data: z.optional(
      z.string().register(z.globalRegistry, {
        description: "File data",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "Represents an image file.",
  });

/**
 * OutputParameters
 */
export const zLoraOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  debug_latents: z.optional(zFile),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  debug_per_pass_latents: z.optional(zFile),
});

/**
 * ControlNet
 */
export const zControlNetType2 = z.object({
  conditioning_scale: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description:
          "\n            The scale of the control net weight. This is used to scale the control net weight\n            before merging it with the base model.\n        ",
      }),
    )
    .default(1),
  path: z.string().register(z.globalRegistry, {
    description: "URL or the path to the control net weights.",
  }),
  ip_adapter_index: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The index of the IP adapter to be applied to the controlnet. This is only needed for InstantID ControlNets.\n        ",
    }),
  ),
  end_percentage: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            The percentage of the image to end applying the controlnet in terms of the total timesteps.\n        ",
      }),
    )
    .default(1),
  config_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: "optional URL to the controlnet config.json file.",
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: "URL of the image to be used as the control net.",
  }),
  variant: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The optional variant if a Hugging Face repo key is used.",
    }),
  ),
  mask_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "\n            The mask to use for the controlnet. When using a mask, the control image size and the mask size must be the same and divisible by 32.\n        ",
    }),
  ),
  start_percentage: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            The percentage of the image to start applying the controlnet in terms of the total timesteps.\n        ",
      }),
    )
    .default(0),
});

/**
 * TimestepsInput
 */
export const zTimestepsInput = z.object({
  method: z.optional(
    z.enum(["default", "array"]).register(z.globalRegistry, {
      description:
        "\n            The method to use for the timesteps. If set to 'array', the timesteps will be set based\n            on the provided timesteps schedule in the `array` field.\n            Defaults to 'default' which means the scheduler will use the `num_inference_steps` parameter.\n        ",
    }),
  ),
  array: z
    .optional(
      z.array(z.int()).register(z.globalRegistry, {
        description:
          "\n           Timesteps schedule to be used if 'custom' method is selected.\n        ",
      }),
    )
    .default([]),
});

/**
 * SigmasInput
 */
export const zSigmasInput = z.object({
  method: z.optional(
    z.enum(["default", "array"]).register(z.globalRegistry, {
      description:
        "\n            The method to use for the sigmas. If set to 'custom', the sigmas will be set based\n            on the provided sigmas schedule in the `array` field.\n            Defaults to 'default' which means the scheduler will use the sigmas of the scheduler.\n        ",
    }),
  ),
  array: z
    .optional(
      z.array(z.number()).register(z.globalRegistry, {
        description:
          "\n           Sigmas schedule to be used if 'custom' method is selected.\n        ",
      }),
    )
    .default([]),
});

/**
 * LoraWeight
 */
export const zLoraWeight = z.object({
  path: z.string().register(z.globalRegistry, {
    description: "URL or the path to the LoRA weights.",
  }),
  scale: z
    .optional(
      z.number().gte(0).lte(4).register(z.globalRegistry, {
        description:
          "\n            The scale of the LoRA weight. This is used to scale the LoRA weight\n            before merging it with the base model.\n        ",
      }),
    )
    .default(1),
});

/**
 * IPAdapter
 */
export const zIpAdapterType2 = z.object({
  unconditional_noising_factor: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "The factor to apply to the unconditional noising of the IP adapter.",
      }),
    )
    .default(0),
  ip_adapter_image_url: z.union([z.string(), z.array(z.string())]),
  path: z.string().register(z.globalRegistry, {
    description: "URL or the path to the IP adapter weights.",
  }),
  image_projection_shortcut: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            The value to set the image projection shortcut to. For FaceID plus V1 models,\n            this should be set to False. For FaceID plus V2 models, this should be set to True.\n            Default is True.\n        ",
      }),
    )
    .default(true),
  scale_json: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description:
        "\n            The scale of the IP adapter weight. This is used to scale the IP adapter weight\n            before merging it with the base model.\n        ",
    }),
  ),
  ip_adapter_mask_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "\n            The mask to use for the IP adapter. When using a mask, the ip-adapter image size and the mask size must be the same\n        ",
    }),
  ),
  model_subfolder: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "Subfolder in the model directory where the IP adapter weights are stored.",
    }),
  ),
  scale: z
    .optional(
      z.number().gte(0).register(z.globalRegistry, {
        description:
          "\n            The scale of the IP adapter weight. This is used to scale the IP adapter weight\n            before merging it with the base model.\n        ",
      }),
    )
    .default(1),
  insight_face_model_path: z.optional(
    z.string().register(z.globalRegistry, {
      description: "URL or the path to the InsightFace model weights.",
    }),
  ),
  weight_name: z.optional(
    z.string().register(z.globalRegistry, {
      description: "Name of the weight file.",
    }),
  ),
});

/**
 * Embedding
 */
export const zEmbedding = z.object({
  tokens: z
    .optional(
      z.array(z.string()).register(z.globalRegistry, {
        description: "The list of tokens to use for the embedding.",
      }),
    )
    .default(["<s0>", "<s1>"]),
  path: z.string().register(z.globalRegistry, {
    description: "URL or the path to the embedding weights.",
  }),
});

/**
 * ImageSize
 */
export const zImageSize = z.object({
  height: z
    .optional(
      z.int().lte(14142).register(z.globalRegistry, {
        description: "The height of the generated image.",
      }),
    )
    .default(512),
  width: z
    .optional(
      z.int().lte(14142).register(z.globalRegistry, {
        description: "The width of the generated image.",
      }),
    )
    .default(512),
});

/**
 * TextToImageInput
 */
export const zLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  tile_height: z
    .optional(
      z.int().gte(128).lte(4096).register(z.globalRegistry, {
        description:
          "The size of the tiles to be used for the image generation.",
      }),
    )
    .default(4096),
  embeddings: z
    .optional(
      z.array(zEmbedding).register(z.globalRegistry, {
        description:
          "\n            The embeddings to use for the image generation. Only a single embedding is supported at the moment.\n            The embeddings will be used to map the tokens in the prompt to the embedding weights.\n        ",
      }),
    )
    .default([]),
  ic_light_model_url: z.optional(z.union([z.string(), z.string()])),
  image_encoder_weight_name: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The weight name of the image encoder model to use for the image generation.\n        ",
      }),
    )
    .default("pytorch_model.bin"),
  ip_adapter: z
    .optional(
      z.array(zIpAdapterType2).register(z.globalRegistry, {
        description:
          "\n            The IP adapter to use for the image generation.\n        ",
      }),
    )
    .default([]),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  scheduler: z.optional(
    z
      .enum([
        "DPM++ 2M",
        "DPM++ 2M Karras",
        "DPM++ 2M SDE",
        "DPM++ 2M SDE Karras",
        "Euler",
        "Euler A",
        "Euler (trailing timesteps)",
        "LCM",
        "LCM (trailing timesteps)",
        "DDIM",
        "TCD",
      ])
      .register(z.globalRegistry, {
        description:
          "Scheduler / sampler to use for the image denoising process.",
      }),
  ),
  sigmas: z.optional(zSigmasInput),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(7.5),
  tile_stride_width: z
    .optional(
      z.int().gte(64).lte(2048).register(z.globalRegistry, {
        description:
          "The stride of the tiles to be used for the image generation.",
      }),
    )
    .default(2048),
  debug_per_pass_latents: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the latents will be saved for debugging per pass.",
      }),
    )
    .default(false),
  timesteps: z.optional(zTimestepsInput),
  image_encoder_subfolder: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "\n            The subfolder of the image encoder model to use for the image generation.\n        ",
    }),
  ),
  prompt_weighting: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the prompt weighting syntax will be used.\n            Additionally, this will lift the 77 token limit by averaging embeddings.\n        ",
      }),
    )
    .default(false),
  variant: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "The variant of the model to use for huggingface models, e.g. 'fp16'.",
    }),
  ),
  model_name: z.string().register(z.globalRegistry, {
    description:
      "URL or HuggingFace ID of the base model to generate the image.",
  }),
  controlnet_guess_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the controlnet will be applied to only the conditional predictions.\n        ",
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  ic_light_model_background_image_url: z.optional(
    z.union([z.string(), z.string()]),
  ),
  rescale_betas_snr_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            Whether to set the rescale_betas_snr_zero option or not for the sampler\n        ",
      }),
    )
    .default(false),
  tile_width: z
    .optional(
      z.int().gte(128).lte(4096).register(z.globalRegistry, {
        description:
          "The size of the tiles to be used for the image generation.",
      }),
    )
    .default(4096),
  prediction_type: z.optional(
    z.enum(["v_prediction", "epsilon"]).register(z.globalRegistry, {
      description:
        "\n            The type of prediction to use for the image generation.\n            The `epsilon` is the default.\n        ",
    }),
  ),
  eta: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The eta value to be used for the image generation.",
      }),
    )
    .default(0),
  image_encoder_path: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "\n            The path to the image encoder model to use for the image generation.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  image_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description:
          "\n            Number of images to generate in one request. Note that the higher the batch size,\n            the longer it will take to generate the images.\n        ",
      }),
    )
    .default(1),
  debug_latents: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the latents will be saved for debugging.",
      }),
    )
    .default(false),
  ic_light_image_url: z.optional(z.union([z.string(), z.string()])),
  unet_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "URL or HuggingFace ID of the custom U-Net model to use for the image generation.",
    }),
  ),
  clip_skip: z
    .optional(
      z.int().gte(0).lte(2).register(z.globalRegistry, {
        description:
          "\n            Skips part of the image generation process, leading to slightly different results.\n            This means the image renders faster, too.\n        ",
      }),
    )
    .default(0),
  tile_stride_height: z
    .optional(
      z.int().gte(64).lte(2048).register(z.globalRegistry, {
        description:
          "The stride of the tiles to be used for the image generation.",
      }),
    )
    .default(2048),
  controlnets: z
    .optional(
      z.array(zControlNetType2).register(z.globalRegistry, {
        description:
          "\n            The control nets to use for the image generation. You can use any number of control nets\n            and they will be applied to the image at the specified timesteps.\n        ",
      }),
    )
    .default([]),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(150).register(z.globalRegistry, {
        description:
          "\n            Increasing the amount of steps tells Stable Diffusion that it should take more steps\n            to generate your final result which can increase the amount of detail in your image.\n        ",
      }),
    )
    .default(30),
});

/**
 * FooocusOutput
 */
export const zFooocusOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated image file info.",
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: "The time taken for the generation process.",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
});

/**
 * FooocusLegacyInput
 */
export const zFooocusInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The prompt to use for generating the image. Be as descriptive as possible for best results.",
      }),
    )
    .default(""),
  performance: z.optional(
    z
      .enum(["Speed", "Quality", "Extreme Speed", "Lightning"])
      .register(z.globalRegistry, {
        description: "\n            You can choose Speed or Quality\n        ",
      }),
  ),
  styles: z
    .optional(
      z
        .array(
          z.enum([
            "Fooocus V2",
            "Fooocus Enhance",
            "Fooocus Sharp",
            "Fooocus Semi Realistic",
            "Fooocus Masterpiece",
            "Fooocus Photograph",
            "Fooocus Negative",
            "Fooocus Cinematic",
            "SAI 3D Model",
            "SAI Analog Film",
            "SAI Anime",
            "SAI Cinematic",
            "SAI Comic Book",
            "SAI Craft Clay",
            "SAI Digital Art",
            "SAI Enhance",
            "SAI Fantasy Art",
            "SAI Isometric",
            "SAI Line Art",
            "SAI Lowpoly",
            "SAI Neonpunk",
            "SAI Origami",
            "SAI Photographic",
            "SAI Pixel Art",
            "SAI Texture",
            "MRE Cinematic Dynamic",
            "MRE Spontaneous Picture",
            "MRE Artistic Vision",
            "MRE Dark Dream",
            "MRE Gloomy Art",
            "MRE Bad Dream",
            "MRE Underground",
            "MRE Surreal Painting",
            "MRE Dynamic Illustration",
            "MRE Undead Art",
            "MRE Elemental Art",
            "MRE Space Art",
            "MRE Ancient Illustration",
            "MRE Brave Art",
            "MRE Heroic Fantasy",
            "MRE Dark Cyberpunk",
            "MRE Lyrical Geometry",
            "MRE Sumi E Symbolic",
            "MRE Sumi E Detailed",
            "MRE Manga",
            "MRE Anime",
            "MRE Comic",
            "Ads Advertising",
            "Ads Automotive",
            "Ads Corporate",
            "Ads Fashion Editorial",
            "Ads Food Photography",
            "Ads Gourmet Food Photography",
            "Ads Luxury",
            "Ads Real Estate",
            "Ads Retail",
            "Artstyle Abstract",
            "Artstyle Abstract Expressionism",
            "Artstyle Art Deco",
            "Artstyle Art Nouveau",
            "Artstyle Constructivist",
            "Artstyle Cubist",
            "Artstyle Expressionist",
            "Artstyle Graffiti",
            "Artstyle Hyperrealism",
            "Artstyle Impressionist",
            "Artstyle Pointillism",
            "Artstyle Pop Art",
            "Artstyle Psychedelic",
            "Artstyle Renaissance",
            "Artstyle Steampunk",
            "Artstyle Surrealist",
            "Artstyle Typography",
            "Artstyle Watercolor",
            "Futuristic Biomechanical",
            "Futuristic Biomechanical Cyberpunk",
            "Futuristic Cybernetic",
            "Futuristic Cybernetic Robot",
            "Futuristic Cyberpunk Cityscape",
            "Futuristic Futuristic",
            "Futuristic Retro Cyberpunk",
            "Futuristic Retro Futurism",
            "Futuristic Sci Fi",
            "Futuristic Vaporwave",
            "Game Bubble Bobble",
            "Game Cyberpunk Game",
            "Game Fighting Game",
            "Game Gta",
            "Game Mario",
            "Game Minecraft",
            "Game Pokemon",
            "Game Retro Arcade",
            "Game Retro Game",
            "Game Rpg Fantasy Game",
            "Game Strategy Game",
            "Game Streetfighter",
            "Game Zelda",
            "Misc Architectural",
            "Misc Disco",
            "Misc Dreamscape",
            "Misc Dystopian",
            "Misc Fairy Tale",
            "Misc Gothic",
            "Misc Grunge",
            "Misc Horror",
            "Misc Kawaii",
            "Misc Lovecraftian",
            "Misc Macabre",
            "Misc Manga",
            "Misc Metropolis",
            "Misc Minimalist",
            "Misc Monochrome",
            "Misc Nautical",
            "Misc Space",
            "Misc Stained Glass",
            "Misc Techwear Fashion",
            "Misc Tribal",
            "Misc Zentangle",
            "Papercraft Collage",
            "Papercraft Flat Papercut",
            "Papercraft Kirigami",
            "Papercraft Paper Mache",
            "Papercraft Paper Quilling",
            "Papercraft Papercut Collage",
            "Papercraft Papercut Shadow Box",
            "Papercraft Stacked Papercut",
            "Papercraft Thick Layered Papercut",
            "Photo Alien",
            "Photo Film Noir",
            "Photo Glamour",
            "Photo Hdr",
            "Photo Iphone Photographic",
            "Photo Long Exposure",
            "Photo Neon Noir",
            "Photo Silhouette",
            "Photo Tilt Shift",
            "Cinematic Diva",
            "Abstract Expressionism",
            "Academia",
            "Action Figure",
            "Adorable 3D Character",
            "Adorable Kawaii",
            "Art Deco",
            "Art Nouveau",
            "Astral Aura",
            "Avant Garde",
            "Baroque",
            "Bauhaus Style Poster",
            "Blueprint Schematic Drawing",
            "Caricature",
            "Cel Shaded Art",
            "Character Design Sheet",
            "Classicism Art",
            "Color Field Painting",
            "Colored Pencil Art",
            "Conceptual Art",
            "Constructivism",
            "Cubism",
            "Dadaism",
            "Dark Fantasy",
            "Dark Moody Atmosphere",
            "Dmt Art Style",
            "Doodle Art",
            "Double Exposure",
            "Dripping Paint Splatter Art",
            "Expressionism",
            "Faded Polaroid Photo",
            "Fauvism",
            "Flat 2d Art",
            "Fortnite Art Style",
            "Futurism",
            "Glitchcore",
            "Glo Fi",
            "Googie Art Style",
            "Graffiti Art",
            "Harlem Renaissance Art",
            "High Fashion",
            "Idyllic",
            "Impressionism",
            "Infographic Drawing",
            "Ink Dripping Drawing",
            "Japanese Ink Drawing",
            "Knolling Photography",
            "Light Cheery Atmosphere",
            "Logo Design",
            "Luxurious Elegance",
            "Macro Photography",
            "Mandola Art",
            "Marker Drawing",
            "Medievalism",
            "Minimalism",
            "Neo Baroque",
            "Neo Byzantine",
            "Neo Futurism",
            "Neo Impressionism",
            "Neo Rococo",
            "Neoclassicism",
            "Op Art",
            "Ornate And Intricate",
            "Pencil Sketch Drawing",
            "Pop Art 2",
            "Rococo",
            "Silhouette Art",
            "Simple Vector Art",
            "Sketchup",
            "Steampunk 2",
            "Surrealism",
            "Suprematism",
            "Terragen",
            "Tranquil Relaxing Atmosphere",
            "Sticker Designs",
            "Vibrant Rim Light",
            "Volumetric Lighting",
            "Watercolor 2",
            "Whimsical And Playful",
            "Mk Chromolithography",
            "Mk Cross Processing Print",
            "Mk Dufaycolor Photograph",
            "Mk Herbarium",
            "Mk Punk Collage",
            "Mk Mosaic",
            "Mk Van Gogh",
            "Mk Coloring Book",
            "Mk Singer Sargent",
            "Mk Pollock",
            "Mk Basquiat",
            "Mk Andy Warhol",
            "Mk Halftone Print",
            "Mk Gond Painting",
            "Mk Albumen Print",
            "Mk Aquatint Print",
            "Mk Anthotype Print",
            "Mk Inuit Carving",
            "Mk Bromoil Print",
            "Mk Calotype Print",
            "Mk Color Sketchnote",
            "Mk Cibulak Porcelain",
            "Mk Alcohol Ink Art",
            "Mk One Line Art",
            "Mk Blacklight Paint",
            "Mk Carnival Glass",
            "Mk Cyanotype Print",
            "Mk Cross Stitching",
            "Mk Encaustic Paint",
            "Mk Embroidery",
            "Mk Gyotaku",
            "Mk Luminogram",
            "Mk Lite Brite Art",
            "Mk Mokume Gane",
            "Pebble Art",
            "Mk Palekh",
            "Mk Suminagashi",
            "Mk Scrimshaw",
            "Mk Shibori",
            "Mk Vitreous Enamel",
            "Mk Ukiyo E",
            "Mk Vintage Airline Poster",
            "Mk Vintage Travel Poster",
            "Mk Bauhaus Style",
            "Mk Afrofuturism",
            "Mk Atompunk",
            "Mk Constructivism",
            "Mk Chicano Art",
            "Mk De Stijl",
            "Mk Dayak Art",
            "Mk Fayum Portrait",
            "Mk Illuminated Manuscript",
            "Mk Kalighat Painting",
            "Mk Madhubani Painting",
            "Mk Pictorialism",
            "Mk Pichwai Painting",
            "Mk Patachitra Painting",
            "Mk Samoan Art Inspired",
            "Mk Tlingit Art",
            "Mk Adnate Style",
            "Mk Ron English Style",
            "Mk Shepard Fairey Style",
          ]),
        )
        .register(z.globalRegistry, {
          description: "\n            The style to use.\n        ",
        }),
    )
    .default(["Fooocus Enhance", "Fooocus V2", "Fooocus Sharp"]),
  control_type: z.optional(
    z
      .enum(["ImagePrompt", "PyraCanny", "CPDS", "FaceSwap"])
      .register(z.globalRegistry, {
        description: "The type of image control",
      }),
  ),
  mask_image_url: z.optional(z.union([z.string(), z.string(), z.null()])),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use up to 5 LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([
      {
        path: "https://huggingface.co/stabilityai/stable-diffusion-xl-base-1.0/resolve/main/sd_xl_offset_example-lora_1.0.safetensors",
        scale: 0.1,
      },
    ]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to false, the safety checker will be disabled.",
      }),
    )
    .default(true),
  sharpness: z
    .optional(
      z.number().gte(0).lte(30).register(z.globalRegistry, {
        description:
          "\n            The sharpness of the generated image. Use it to control how sharp the generated\n            image should be. Higher value means image and texture are sharper.\n        ",
      }),
    )
    .default(2),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(30).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(4),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  inpaint_image_url: z.optional(z.union([z.string(), z.string(), z.null()])),
  mixing_image_prompt_and_inpaint: z.optional(z.boolean()).default(false),
  aspect_ratio: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The size of the generated image. You can choose between some presets or\n            custom height and width that **must be multiples of 8**.\n        ",
      }),
    )
    .default("1024x1024"),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "\n            Number of images to generate in one request\n        ",
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  refiner_model: z.optional(
    z
      .enum(["None", "realisticVisionV60B1_v51VAE.safetensors"])
      .register(z.globalRegistry, {
        description: "Refiner (SDXL or SD 1.5)",
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  control_image_url: z.optional(z.union([z.string(), z.string(), z.null()])),
  seed: z.optional(z.union([z.int(), z.null()])),
  refiner_switch: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            Use 0.4 for SD1.5 realistic models; 0.667 for SD1.5 anime models\n            0.8 for XL-refiners; or any value for switching two SDXL models.\n        ",
      }),
    )
    .default(0.8),
  control_image_weight: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description:
          "\n            The strength of the control image. Use it to control how much the generated image\n            should look like the control image.\n        ",
      }),
    )
    .default(1),
  control_image_stop_at: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            The stop at value of the control image. Use it to control how much the generated image\n            should look like the control image.\n        ",
      }),
    )
    .default(1),
});

/**
 * Image
 *
 * Represents an image file.
 */
export const zImageType4 = z
  .object({
    file_size: z.int().register(z.globalRegistry, {
      description: "The size of the file in bytes.",
    }),
    height: z.optional(
      z.int().register(z.globalRegistry, {
        description: "The height of the image in pixels.",
      }),
    ),
    file_name: z.string().register(z.globalRegistry, {
      description:
        "The name of the file. It will be auto-generated if not provided.",
    }),
    content_type: z.string().register(z.globalRegistry, {
      description: "The mime type of the file.",
    }),
    url: z.string().register(z.globalRegistry, {
      description: "The URL where the file can be downloaded from.",
    }),
    width: z.optional(
      z.int().register(z.globalRegistry, {
        description: "The width of the image in pixels.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "Represents an image file.",
  });

/**
 * DiffusionEdgeOutput
 */
export const zDiffusionEdgeOutput = z.object({
  image: zImageType4,
});

/**
 * DiffusionEdgeInput
 */
export const zDiffusionEdgeInput = z.object({
  image_url: z.union([z.string(), z.string()]),
});

/**
 * Image
 */
export const zImageType2 = z.object({
  height: z.int(),
  content_type: z.optional(z.string()).default("image/jpeg"),
  url: z.string(),
  width: z.int(),
});

/**
 * LCMOutput
 */
export const zLcmOutput = z.object({
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ",
      }),
    )
    .default(""),
  timings: z.record(z.string(), z.number()),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  num_inference_steps: z
    .optional(
      z.int().register(z.globalRegistry, {
        description:
          "\n            Number of inference steps used to generate the image. It will be the same value of the one passed in the\n            input or the default one in case none was passed.\n        ",
      }),
    )
    .default(4),
  nsfw_content_detected: z.array(z.boolean()).register(z.globalRegistry, {
    description:
      "\n            A list of booleans indicating whether the generated image contains any\n            potentially unsafe content. If the safety check is disabled, this field\n            will all will be false.\n        ",
  }),
});

/**
 * LCMInput
 */
export const zLcmInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  controlnet_inpaint: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the inpainting pipeline will use controlnet inpainting.\n            Only effective for inpainting pipelines.\n        ",
      }),
    )
    .default(false),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  enable_safety_checks: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the resulting image will be checked whether it includes any\n            potentially unsafe content. If it does, it will be replaced with a black\n            image.\n        ",
      }),
    )
    .default(true),
  model: z.optional(
    z.enum(["sdxl", "sdv1-5"]).register(z.globalRegistry, {
      description: "The model to use for generating the image.",
    }),
  ),
  lora_url: z.optional(z.union([z.string(), z.string()])),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(8).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(1),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  inpaint_mask_only: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the inpainting pipeline will only inpaint the provided mask\n            area. Only effective for inpainting pipelines.\n        ",
      }),
    )
    .default(false),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description:
          "\n            The number of images to generate. The function will return a list of images\n            with the same prompt and negative prompt but different seeds.\n        ",
      }),
    )
    .default(1),
  lora_scale: z
    .optional(
      z.number().register(z.globalRegistry, {
        description:
          "\n            The scale of the lora server to use for image generation.\n        ",
      }),
    )
    .default(1),
  image_url: z.optional(z.union([z.string(), z.string()])),
  strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n        The strength of the image that is passed as `image_url`. The strength\n        determines how much the generated image will be similar to the image passed as\n        `image_url`. The higher the strength the more model gets \"creative\" and\n        generates an image that's different from the initial image. A strength of 1.0\n        means that the initial image is more or less ignored and the model will try to\n        generate an image that's as close as possible to the prompt.\n        ",
      }),
    )
    .default(0.8),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ",
      }),
    )
    .default(""),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  mask_url: z.optional(z.union([z.string(), z.string()])),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(12).register(z.globalRegistry, {
        description:
          "\n            The number of inference steps to use for generating the image. The more steps\n            the better the image will be but it will also take longer to generate.\n        ",
      }),
    )
    .default(4),
});

/**
 * FooocusOutput
 */
export const zFooocusInpaintOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated image file info.",
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: "The time taken for the generation process.",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
});

/**
 * ImagePrompt
 */
export const zImagePrompt = z.object({
  weight: z.optional(z.number().gte(0).lte(2)).default(1),
  stop_at: z.optional(z.number().gte(0).lte(1)).default(0.5),
  type: z.optional(z.enum(["ImagePrompt", "PyraCanny", "CPDS", "FaceSwap"])),
  image_url: z.optional(z.string()),
});

/**
 * FooocusInpaintInput
 */
export const zFooocusInpaintInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The prompt to use for generating the image. Be as descriptive as possible for best results.",
      }),
    )
    .default(""),
  performance: z.optional(
    z
      .enum(["Speed", "Quality", "Extreme Speed", "Lightning"])
      .register(z.globalRegistry, {
        description: "\n            You can choose Speed or Quality\n        ",
      }),
  ),
  styles: z
    .optional(
      z
        .array(
          z.enum([
            "Fooocus V2",
            "Fooocus Enhance",
            "Fooocus Sharp",
            "Fooocus Semi Realistic",
            "Fooocus Masterpiece",
            "Fooocus Photograph",
            "Fooocus Negative",
            "Fooocus Cinematic",
            "SAI 3D Model",
            "SAI Analog Film",
            "SAI Anime",
            "SAI Cinematic",
            "SAI Comic Book",
            "SAI Craft Clay",
            "SAI Digital Art",
            "SAI Enhance",
            "SAI Fantasy Art",
            "SAI Isometric",
            "SAI Line Art",
            "SAI Lowpoly",
            "SAI Neonpunk",
            "SAI Origami",
            "SAI Photographic",
            "SAI Pixel Art",
            "SAI Texture",
            "MRE Cinematic Dynamic",
            "MRE Spontaneous Picture",
            "MRE Artistic Vision",
            "MRE Dark Dream",
            "MRE Gloomy Art",
            "MRE Bad Dream",
            "MRE Underground",
            "MRE Surreal Painting",
            "MRE Dynamic Illustration",
            "MRE Undead Art",
            "MRE Elemental Art",
            "MRE Space Art",
            "MRE Ancient Illustration",
            "MRE Brave Art",
            "MRE Heroic Fantasy",
            "MRE Dark Cyberpunk",
            "MRE Lyrical Geometry",
            "MRE Sumi E Symbolic",
            "MRE Sumi E Detailed",
            "MRE Manga",
            "MRE Anime",
            "MRE Comic",
            "Ads Advertising",
            "Ads Automotive",
            "Ads Corporate",
            "Ads Fashion Editorial",
            "Ads Food Photography",
            "Ads Gourmet Food Photography",
            "Ads Luxury",
            "Ads Real Estate",
            "Ads Retail",
            "Artstyle Abstract",
            "Artstyle Abstract Expressionism",
            "Artstyle Art Deco",
            "Artstyle Art Nouveau",
            "Artstyle Constructivist",
            "Artstyle Cubist",
            "Artstyle Expressionist",
            "Artstyle Graffiti",
            "Artstyle Hyperrealism",
            "Artstyle Impressionist",
            "Artstyle Pointillism",
            "Artstyle Pop Art",
            "Artstyle Psychedelic",
            "Artstyle Renaissance",
            "Artstyle Steampunk",
            "Artstyle Surrealist",
            "Artstyle Typography",
            "Artstyle Watercolor",
            "Futuristic Biomechanical",
            "Futuristic Biomechanical Cyberpunk",
            "Futuristic Cybernetic",
            "Futuristic Cybernetic Robot",
            "Futuristic Cyberpunk Cityscape",
            "Futuristic Futuristic",
            "Futuristic Retro Cyberpunk",
            "Futuristic Retro Futurism",
            "Futuristic Sci Fi",
            "Futuristic Vaporwave",
            "Game Bubble Bobble",
            "Game Cyberpunk Game",
            "Game Fighting Game",
            "Game Gta",
            "Game Mario",
            "Game Minecraft",
            "Game Pokemon",
            "Game Retro Arcade",
            "Game Retro Game",
            "Game Rpg Fantasy Game",
            "Game Strategy Game",
            "Game Streetfighter",
            "Game Zelda",
            "Misc Architectural",
            "Misc Disco",
            "Misc Dreamscape",
            "Misc Dystopian",
            "Misc Fairy Tale",
            "Misc Gothic",
            "Misc Grunge",
            "Misc Horror",
            "Misc Kawaii",
            "Misc Lovecraftian",
            "Misc Macabre",
            "Misc Manga",
            "Misc Metropolis",
            "Misc Minimalist",
            "Misc Monochrome",
            "Misc Nautical",
            "Misc Space",
            "Misc Stained Glass",
            "Misc Techwear Fashion",
            "Misc Tribal",
            "Misc Zentangle",
            "Papercraft Collage",
            "Papercraft Flat Papercut",
            "Papercraft Kirigami",
            "Papercraft Paper Mache",
            "Papercraft Paper Quilling",
            "Papercraft Papercut Collage",
            "Papercraft Papercut Shadow Box",
            "Papercraft Stacked Papercut",
            "Papercraft Thick Layered Papercut",
            "Photo Alien",
            "Photo Film Noir",
            "Photo Glamour",
            "Photo Hdr",
            "Photo Iphone Photographic",
            "Photo Long Exposure",
            "Photo Neon Noir",
            "Photo Silhouette",
            "Photo Tilt Shift",
            "Cinematic Diva",
            "Abstract Expressionism",
            "Academia",
            "Action Figure",
            "Adorable 3D Character",
            "Adorable Kawaii",
            "Art Deco",
            "Art Nouveau",
            "Astral Aura",
            "Avant Garde",
            "Baroque",
            "Bauhaus Style Poster",
            "Blueprint Schematic Drawing",
            "Caricature",
            "Cel Shaded Art",
            "Character Design Sheet",
            "Classicism Art",
            "Color Field Painting",
            "Colored Pencil Art",
            "Conceptual Art",
            "Constructivism",
            "Cubism",
            "Dadaism",
            "Dark Fantasy",
            "Dark Moody Atmosphere",
            "Dmt Art Style",
            "Doodle Art",
            "Double Exposure",
            "Dripping Paint Splatter Art",
            "Expressionism",
            "Faded Polaroid Photo",
            "Fauvism",
            "Flat 2d Art",
            "Fortnite Art Style",
            "Futurism",
            "Glitchcore",
            "Glo Fi",
            "Googie Art Style",
            "Graffiti Art",
            "Harlem Renaissance Art",
            "High Fashion",
            "Idyllic",
            "Impressionism",
            "Infographic Drawing",
            "Ink Dripping Drawing",
            "Japanese Ink Drawing",
            "Knolling Photography",
            "Light Cheery Atmosphere",
            "Logo Design",
            "Luxurious Elegance",
            "Macro Photography",
            "Mandola Art",
            "Marker Drawing",
            "Medievalism",
            "Minimalism",
            "Neo Baroque",
            "Neo Byzantine",
            "Neo Futurism",
            "Neo Impressionism",
            "Neo Rococo",
            "Neoclassicism",
            "Op Art",
            "Ornate And Intricate",
            "Pencil Sketch Drawing",
            "Pop Art 2",
            "Rococo",
            "Silhouette Art",
            "Simple Vector Art",
            "Sketchup",
            "Steampunk 2",
            "Surrealism",
            "Suprematism",
            "Terragen",
            "Tranquil Relaxing Atmosphere",
            "Sticker Designs",
            "Vibrant Rim Light",
            "Volumetric Lighting",
            "Watercolor 2",
            "Whimsical And Playful",
            "Mk Chromolithography",
            "Mk Cross Processing Print",
            "Mk Dufaycolor Photograph",
            "Mk Herbarium",
            "Mk Punk Collage",
            "Mk Mosaic",
            "Mk Van Gogh",
            "Mk Coloring Book",
            "Mk Singer Sargent",
            "Mk Pollock",
            "Mk Basquiat",
            "Mk Andy Warhol",
            "Mk Halftone Print",
            "Mk Gond Painting",
            "Mk Albumen Print",
            "Mk Aquatint Print",
            "Mk Anthotype Print",
            "Mk Inuit Carving",
            "Mk Bromoil Print",
            "Mk Calotype Print",
            "Mk Color Sketchnote",
            "Mk Cibulak Porcelain",
            "Mk Alcohol Ink Art",
            "Mk One Line Art",
            "Mk Blacklight Paint",
            "Mk Carnival Glass",
            "Mk Cyanotype Print",
            "Mk Cross Stitching",
            "Mk Encaustic Paint",
            "Mk Embroidery",
            "Mk Gyotaku",
            "Mk Luminogram",
            "Mk Lite Brite Art",
            "Mk Mokume Gane",
            "Pebble Art",
            "Mk Palekh",
            "Mk Suminagashi",
            "Mk Scrimshaw",
            "Mk Shibori",
            "Mk Vitreous Enamel",
            "Mk Ukiyo E",
            "Mk Vintage Airline Poster",
            "Mk Vintage Travel Poster",
            "Mk Bauhaus Style",
            "Mk Afrofuturism",
            "Mk Atompunk",
            "Mk Constructivism",
            "Mk Chicano Art",
            "Mk De Stijl",
            "Mk Dayak Art",
            "Mk Fayum Portrait",
            "Mk Illuminated Manuscript",
            "Mk Kalighat Painting",
            "Mk Madhubani Painting",
            "Mk Pictorialism",
            "Mk Pichwai Painting",
            "Mk Patachitra Painting",
            "Mk Samoan Art Inspired",
            "Mk Tlingit Art",
            "Mk Adnate Style",
            "Mk Ron English Style",
            "Mk Shepard Fairey Style",
          ]),
        )
        .register(z.globalRegistry, {
          description: "\n            The style to use.\n        ",
        }),
    )
    .default(["Fooocus Enhance", "Fooocus V2", "Fooocus Sharp"]),
  image_prompt_3: z.optional(zImagePrompt),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use up to 5 LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([
      {
        path: "https://huggingface.co/stabilityai/stable-diffusion-xl-base-1.0/resolve/main/sd_xl_offset_example-lora_1.0.safetensors",
        scale: 0.1,
      },
    ]),
  image_prompt_4: z.optional(zImagePrompt),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(30).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(4),
  sharpness: z
    .optional(
      z.number().gte(0).lte(30).register(z.globalRegistry, {
        description:
          "\n            The sharpness of the generated image. Use it to control how sharp the generated\n            image should be. Higher value means image and texture are sharper.\n        ",
      }),
    )
    .default(2),
  mixing_image_prompt_and_inpaint: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Mixing Image Prompt and Inpaint",
      }),
    )
    .default(false),
  outpaint_selections: z
    .optional(
      z
        .array(z.enum(["Left", "Right", "Top", "Bottom"]))
        .register(z.globalRegistry, {
          description: "The directions to outpaint.",
        }),
    )
    .default([]),
  inpaint_image_url: z.union([z.string(), z.string()]),
  refiner_model: z.optional(
    z
      .enum(["None", "realisticVisionV60B1_v51VAE.safetensors"])
      .register(z.globalRegistry, {
        description: "Refiner (SDXL or SD 1.5)",
      }),
  ),
  output_format: z.optional(
    z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_prompt_2: z.optional(zImagePrompt),
  inpaint_respective_field: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The area to inpaint. Value 0 is same as "Only Masked" in A1111. Value 1 is\n            same as "Whole Image" in A1111. Only used in inpaint, not used in outpaint.\n            (Outpaint always use 1.0)\n        ',
      }),
    )
    .default(0.618),
  inpaint_mode: z.optional(
    z
      .enum([
        "Inpaint or Outpaint (default)",
        "Improve Detail (face, hand, eyes, etc.)",
        "Modify Content (add objects, change background, etc.)",
      ])
      .register(z.globalRegistry, {
        description: "The mode to use for inpainting.",
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.null()])),
  refiner_switch: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            Use 0.4 for SD1.5 realistic models; 0.667 for SD1.5 anime models\n            0.8 for XL-refiners; or any value for switching two SDXL models.\n        ",
      }),
    )
    .default(0.8),
  inpaint_disable_initial_latent: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the initial preprocessing will be disabled.",
      }),
    )
    .default(false),
  mask_image_url: z.optional(z.union([z.string(), z.string()])),
  invert_mask: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the mask will be inverted.",
      }),
    )
    .default(false),
  image_prompt_1: z.optional(zImagePrompt),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to false, the safety checker will be disabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "\n            Number of images to generate in one request\n        ",
      }),
    )
    .default(1),
  aspect_ratio: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The size of the generated image. You can choose between some presets or\n            custom height and width that **must be multiples of 8**.\n        ",
      }),
    )
    .default("1024x1024"),
  inpaint_additional_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Describe what you want to inpaint.",
      }),
    )
    .default(""),
  inpaint_strength: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description:
          "\n            Same as the denoising strength in A1111 inpaint. Only used in inpaint, not\n            used in outpaint. (Outpaint always use 1.0)\n        ",
      }),
    )
    .default(1),
  override_inpaint_options: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the advanced inpaint options ('inpaint_disable_initial_latent',\n            'inpaint_engine', 'inpaint_strength', 'inpaint_respective_field',\n            'inpaint_erode_or_dilate') will be overridden.\n            Otherwise, the default values will be used.\n        ",
      }),
    )
    .default(false),
  inpaint_engine: z.optional(
    z.enum(["None", "v1", "v2.5", "v2.6"]).register(z.globalRegistry, {
      description: "Version of Fooocus inpaint model",
    }),
  ),
  inpaint_erode_or_dilate: z
    .optional(
      z.number().gte(-64).lte(64).register(z.globalRegistry, {
        description:
          "\n            Positive value will make white area in the mask larger, negative value will\n            make white area smaller. (default is 0, always process before any mask\n            invert)\n        ",
      }),
    )
    .default(0),
});

/**
 * FooocusOutput
 */
export const zFooocusImagePromptOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated image file info.",
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: "The time taken for the generation process.",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
});

/**
 * FooocusImagePromptInput
 */
export const zFooocusImagePromptInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The prompt to use for generating the image. Be as descriptive as possible for best results.",
      }),
    )
    .default(""),
  uov_image_url: z.optional(z.union([z.string(), z.string()])),
  performance: z.optional(
    z
      .enum(["Speed", "Quality", "Extreme Speed", "Lightning"])
      .register(z.globalRegistry, {
        description: "\n            You can choose Speed or Quality\n        ",
      }),
  ),
  image_prompt_3: z.optional(zImagePrompt),
  styles: z
    .optional(
      z
        .array(
          z.enum([
            "Fooocus V2",
            "Fooocus Enhance",
            "Fooocus Sharp",
            "Fooocus Semi Realistic",
            "Fooocus Masterpiece",
            "Fooocus Photograph",
            "Fooocus Negative",
            "Fooocus Cinematic",
            "SAI 3D Model",
            "SAI Analog Film",
            "SAI Anime",
            "SAI Cinematic",
            "SAI Comic Book",
            "SAI Craft Clay",
            "SAI Digital Art",
            "SAI Enhance",
            "SAI Fantasy Art",
            "SAI Isometric",
            "SAI Line Art",
            "SAI Lowpoly",
            "SAI Neonpunk",
            "SAI Origami",
            "SAI Photographic",
            "SAI Pixel Art",
            "SAI Texture",
            "MRE Cinematic Dynamic",
            "MRE Spontaneous Picture",
            "MRE Artistic Vision",
            "MRE Dark Dream",
            "MRE Gloomy Art",
            "MRE Bad Dream",
            "MRE Underground",
            "MRE Surreal Painting",
            "MRE Dynamic Illustration",
            "MRE Undead Art",
            "MRE Elemental Art",
            "MRE Space Art",
            "MRE Ancient Illustration",
            "MRE Brave Art",
            "MRE Heroic Fantasy",
            "MRE Dark Cyberpunk",
            "MRE Lyrical Geometry",
            "MRE Sumi E Symbolic",
            "MRE Sumi E Detailed",
            "MRE Manga",
            "MRE Anime",
            "MRE Comic",
            "Ads Advertising",
            "Ads Automotive",
            "Ads Corporate",
            "Ads Fashion Editorial",
            "Ads Food Photography",
            "Ads Gourmet Food Photography",
            "Ads Luxury",
            "Ads Real Estate",
            "Ads Retail",
            "Artstyle Abstract",
            "Artstyle Abstract Expressionism",
            "Artstyle Art Deco",
            "Artstyle Art Nouveau",
            "Artstyle Constructivist",
            "Artstyle Cubist",
            "Artstyle Expressionist",
            "Artstyle Graffiti",
            "Artstyle Hyperrealism",
            "Artstyle Impressionist",
            "Artstyle Pointillism",
            "Artstyle Pop Art",
            "Artstyle Psychedelic",
            "Artstyle Renaissance",
            "Artstyle Steampunk",
            "Artstyle Surrealist",
            "Artstyle Typography",
            "Artstyle Watercolor",
            "Futuristic Biomechanical",
            "Futuristic Biomechanical Cyberpunk",
            "Futuristic Cybernetic",
            "Futuristic Cybernetic Robot",
            "Futuristic Cyberpunk Cityscape",
            "Futuristic Futuristic",
            "Futuristic Retro Cyberpunk",
            "Futuristic Retro Futurism",
            "Futuristic Sci Fi",
            "Futuristic Vaporwave",
            "Game Bubble Bobble",
            "Game Cyberpunk Game",
            "Game Fighting Game",
            "Game Gta",
            "Game Mario",
            "Game Minecraft",
            "Game Pokemon",
            "Game Retro Arcade",
            "Game Retro Game",
            "Game Rpg Fantasy Game",
            "Game Strategy Game",
            "Game Streetfighter",
            "Game Zelda",
            "Misc Architectural",
            "Misc Disco",
            "Misc Dreamscape",
            "Misc Dystopian",
            "Misc Fairy Tale",
            "Misc Gothic",
            "Misc Grunge",
            "Misc Horror",
            "Misc Kawaii",
            "Misc Lovecraftian",
            "Misc Macabre",
            "Misc Manga",
            "Misc Metropolis",
            "Misc Minimalist",
            "Misc Monochrome",
            "Misc Nautical",
            "Misc Space",
            "Misc Stained Glass",
            "Misc Techwear Fashion",
            "Misc Tribal",
            "Misc Zentangle",
            "Papercraft Collage",
            "Papercraft Flat Papercut",
            "Papercraft Kirigami",
            "Papercraft Paper Mache",
            "Papercraft Paper Quilling",
            "Papercraft Papercut Collage",
            "Papercraft Papercut Shadow Box",
            "Papercraft Stacked Papercut",
            "Papercraft Thick Layered Papercut",
            "Photo Alien",
            "Photo Film Noir",
            "Photo Glamour",
            "Photo Hdr",
            "Photo Iphone Photographic",
            "Photo Long Exposure",
            "Photo Neon Noir",
            "Photo Silhouette",
            "Photo Tilt Shift",
            "Cinematic Diva",
            "Abstract Expressionism",
            "Academia",
            "Action Figure",
            "Adorable 3D Character",
            "Adorable Kawaii",
            "Art Deco",
            "Art Nouveau",
            "Astral Aura",
            "Avant Garde",
            "Baroque",
            "Bauhaus Style Poster",
            "Blueprint Schematic Drawing",
            "Caricature",
            "Cel Shaded Art",
            "Character Design Sheet",
            "Classicism Art",
            "Color Field Painting",
            "Colored Pencil Art",
            "Conceptual Art",
            "Constructivism",
            "Cubism",
            "Dadaism",
            "Dark Fantasy",
            "Dark Moody Atmosphere",
            "Dmt Art Style",
            "Doodle Art",
            "Double Exposure",
            "Dripping Paint Splatter Art",
            "Expressionism",
            "Faded Polaroid Photo",
            "Fauvism",
            "Flat 2d Art",
            "Fortnite Art Style",
            "Futurism",
            "Glitchcore",
            "Glo Fi",
            "Googie Art Style",
            "Graffiti Art",
            "Harlem Renaissance Art",
            "High Fashion",
            "Idyllic",
            "Impressionism",
            "Infographic Drawing",
            "Ink Dripping Drawing",
            "Japanese Ink Drawing",
            "Knolling Photography",
            "Light Cheery Atmosphere",
            "Logo Design",
            "Luxurious Elegance",
            "Macro Photography",
            "Mandola Art",
            "Marker Drawing",
            "Medievalism",
            "Minimalism",
            "Neo Baroque",
            "Neo Byzantine",
            "Neo Futurism",
            "Neo Impressionism",
            "Neo Rococo",
            "Neoclassicism",
            "Op Art",
            "Ornate And Intricate",
            "Pencil Sketch Drawing",
            "Pop Art 2",
            "Rococo",
            "Silhouette Art",
            "Simple Vector Art",
            "Sketchup",
            "Steampunk 2",
            "Surrealism",
            "Suprematism",
            "Terragen",
            "Tranquil Relaxing Atmosphere",
            "Sticker Designs",
            "Vibrant Rim Light",
            "Volumetric Lighting",
            "Watercolor 2",
            "Whimsical And Playful",
            "Mk Chromolithography",
            "Mk Cross Processing Print",
            "Mk Dufaycolor Photograph",
            "Mk Herbarium",
            "Mk Punk Collage",
            "Mk Mosaic",
            "Mk Van Gogh",
            "Mk Coloring Book",
            "Mk Singer Sargent",
            "Mk Pollock",
            "Mk Basquiat",
            "Mk Andy Warhol",
            "Mk Halftone Print",
            "Mk Gond Painting",
            "Mk Albumen Print",
            "Mk Aquatint Print",
            "Mk Anthotype Print",
            "Mk Inuit Carving",
            "Mk Bromoil Print",
            "Mk Calotype Print",
            "Mk Color Sketchnote",
            "Mk Cibulak Porcelain",
            "Mk Alcohol Ink Art",
            "Mk One Line Art",
            "Mk Blacklight Paint",
            "Mk Carnival Glass",
            "Mk Cyanotype Print",
            "Mk Cross Stitching",
            "Mk Encaustic Paint",
            "Mk Embroidery",
            "Mk Gyotaku",
            "Mk Luminogram",
            "Mk Lite Brite Art",
            "Mk Mokume Gane",
            "Pebble Art",
            "Mk Palekh",
            "Mk Suminagashi",
            "Mk Scrimshaw",
            "Mk Shibori",
            "Mk Vitreous Enamel",
            "Mk Ukiyo E",
            "Mk Vintage Airline Poster",
            "Mk Vintage Travel Poster",
            "Mk Bauhaus Style",
            "Mk Afrofuturism",
            "Mk Atompunk",
            "Mk Constructivism",
            "Mk Chicano Art",
            "Mk De Stijl",
            "Mk Dayak Art",
            "Mk Fayum Portrait",
            "Mk Illuminated Manuscript",
            "Mk Kalighat Painting",
            "Mk Madhubani Painting",
            "Mk Pictorialism",
            "Mk Pichwai Painting",
            "Mk Patachitra Painting",
            "Mk Samoan Art Inspired",
            "Mk Tlingit Art",
            "Mk Adnate Style",
            "Mk Ron English Style",
            "Mk Shepard Fairey Style",
          ]),
        )
        .register(z.globalRegistry, {
          description: "\n            The style to use.\n        ",
        }),
    )
    .default(["Fooocus Enhance", "Fooocus V2", "Fooocus Sharp"]),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use up to 5 LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([
      {
        path: "https://huggingface.co/stabilityai/stable-diffusion-xl-base-1.0/resolve/main/sd_xl_offset_example-lora_1.0.safetensors",
        scale: 0.1,
      },
    ]),
  image_prompt_4: z.optional(zImagePrompt),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(30).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(4),
  sharpness: z
    .optional(
      z.number().gte(0).lte(30).register(z.globalRegistry, {
        description:
          "\n            The sharpness of the generated image. Use it to control how sharp the generated\n            image should be. Higher value means image and texture are sharper.\n        ",
      }),
    )
    .default(2),
  mixing_image_prompt_and_inpaint: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Mixing Image Prompt and Inpaint",
      }),
    )
    .default(false),
  outpaint_selections: z
    .optional(
      z
        .array(z.enum(["Left", "Right", "Top", "Bottom"]))
        .register(z.globalRegistry, {
          description: "The directions to outpaint.",
        }),
    )
    .default([]),
  inpaint_image_url: z.optional(z.union([z.string(), z.string()])),
  output_format: z.optional(
    z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  refiner_model: z.optional(
    z
      .enum(["None", "realisticVisionV60B1_v51VAE.safetensors"])
      .register(z.globalRegistry, {
        description: "Refiner (SDXL or SD 1.5)",
      }),
  ),
  image_prompt_2: z.optional(zImagePrompt),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  inpaint_mode: z.optional(
    z
      .enum([
        "Inpaint or Outpaint (default)",
        "Improve Detail (face, hand, eyes, etc.)",
        "Modify Content (add objects, change background, etc.)",
      ])
      .register(z.globalRegistry, {
        description: "The mode to use for inpainting.",
      }),
  ),
  uov_method: z.optional(
    z
      .enum([
        "Disabled",
        "Vary (Subtle)",
        "Vary (Strong)",
        "Upscale (1.5x)",
        "Upscale (2x)",
        "Upscale (Fast 2x)",
      ])
      .register(z.globalRegistry, {
        description: "The method to use for upscaling or varying.",
      }),
  ),
  seed: z.optional(z.union([z.int(), z.null()])),
  refiner_switch: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            Use 0.4 for SD1.5 realistic models; 0.667 for SD1.5 anime models\n            0.8 for XL-refiners; or any value for switching two SDXL models.\n        ",
      }),
    )
    .default(0.8),
  mixing_image_prompt_and_vary_upscale: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Mixing Image Prompt and Vary/Upscale",
      }),
    )
    .default(false),
  mask_image_url: z.optional(z.union([z.string(), z.string()])),
  image_prompt_1: zImagePrompt,
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to false, the safety checker will be disabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "\n            Number of images to generate in one request\n        ",
      }),
    )
    .default(1),
  aspect_ratio: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The size of the generated image. You can choose between some presets or\n            custom height and width that **must be multiples of 8**.\n        ",
      }),
    )
    .default("1024x1024"),
  inpaint_additional_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Describe what you want to inpaint.",
      }),
    )
    .default(""),
});

/**
 * IllusionDiffusionOutput
 */
export const zIllusionDiffusionOutput = z.object({
  image: zImage,
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * IllusionDiffusionInput
 */
export const zIllusionDiffusionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  controlnet_conditioning_scale: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: "The scale of the ControlNet.",
      }),
    )
    .default(1),
  image_url: z.union([z.string(), z.string()]),
  scheduler: z.optional(
    z.enum(["DPM++ Karras SDE", "Euler"]).register(z.globalRegistry, {
      description:
        "Scheduler / sampler to use for the image denoising process.",
    }),
  ),
  control_guidance_start: z.optional(z.number().gte(0).lte(1)).default(0),
  guidance_scale: z
    .optional(
      z.number().lte(50).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(7.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
    }),
  ),
  control_guidance_end: z.optional(z.number().gte(0).lte(1)).default(1),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  num_inference_steps: z
    .optional(
      z.int().gte(0).lte(80).register(z.globalRegistry, {
        description:
          "\n            Increasing the amount of steps tells Stable Diffusion that it should take more steps\n            to generate your final result which can increase the amount of detail in your image.\n        ",
      }),
    )
    .default(40),
});

/**
 * Output
 */
export const zFastFooocusSdxlOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageFooocusInput
 */
export const zFastFooocusSdxlInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  enable_refiner: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, a smaller model will try to refine the output after it was processed.",
      }),
    )
    .default(true),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zEmbedding).register(z.globalRegistry, {
        description: "The list of embeddings to use.",
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(true),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The rescale factor for the CFG.",
      }),
    )
    .default(0),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(2),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  safety_checker_version: z.optional(
    z.enum(["v1", "v2"]).register(z.globalRegistry, {
      description:
        "The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(24).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(8),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * Output
 */
export const zFastLcmDiffusionOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageLCMInput
 */
export const zFastLcmDiffusionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The rescale factor for the CFG.",
      }),
    )
    .default(0),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(1.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  model_name: z.optional(
    z
      .enum([
        "stabilityai/stable-diffusion-xl-base-1.0",
        "runwayml/stable-diffusion-v1-5",
      ])
      .register(z.globalRegistry, {
        description: "The name of the model to use.",
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(true),
  safety_checker_version: z.optional(
    z.enum(["v1", "v2"]).register(z.globalRegistry, {
      description:
        "The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.",
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ",
      }),
    )
    .default(""),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(32).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(6),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * Output
 */
export const zFastSdxlControlnetCannyOutput = z.object({
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageControlNetInput
 */
export const zFastSdxlControlnetCannyInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
      z.null(),
    ]),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description: "The list of LoRA weights to use.",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(7.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  controlnet_conditioning_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The scale of the controlnet conditioning.",
      }),
    )
    .default(0.5),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  control_image_url: z.union([z.string(), z.string()]),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(25),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  enable_deep_cache: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, DeepCache will be enabled. TBD\n        ",
      }),
    )
    .default(false),
});

/**
 * Output
 */
export const zFastFooocusSdxlImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * ImageToImageFooocusInput
 */
export const zFastFooocusSdxlImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  enable_refiner: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, a smaller model will try to refine the output after it was processed.",
      }),
    )
    .default(true),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
      z.null(),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zEmbedding).register(z.globalRegistry, {
        description: "The list of embeddings to use.",
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(true),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The rescale factor for the CFG.",
      }),
    )
    .default(0),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(2),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_url: z.union([z.string(), z.string()]),
  strength: z
    .optional(
      z.number().gte(0.05).lte(1).register(z.globalRegistry, {
        description:
          "determines how much the generated image resembles the initial image",
      }),
    )
    .default(0.95),
  safety_checker_version: z.optional(
    z.enum(["v1", "v2"]).register(z.globalRegistry, {
      description:
        "The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(24).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(8),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * Output
 */
export const zFastLightningSdxlOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageLightningInput
 */
export const zFastLightningSdxlInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  embeddings: z
    .optional(
      z.array(zEmbedding).register(z.globalRegistry, {
        description: "The list of embeddings to use.",
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The rescale factor for the CFG.",
      }),
    )
    .default(0),
  safety_checker_version: z.optional(
    z.enum(["v1", "v2"]).register(z.globalRegistry, {
      description:
        "The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z.optional(
    z.enum(["1", "2", "4", "8"]).register(z.globalRegistry, {
      description: "The number of inference steps to perform.",
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ",
      }),
    )
    .default(""),
});

/**
 * Image
 *
 * Represents an image file.
 */
export const zImageType3 = z
  .object({
    file_size: z.optional(z.union([z.int(), z.unknown()])),
    height: z.optional(z.union([z.int(), z.unknown()])),
    file_name: z.optional(z.union([z.string(), z.unknown()])),
    content_type: z.optional(z.union([z.string(), z.unknown()])),
    url: z.string().register(z.globalRegistry, {
      description: "The URL where the file can be downloaded from.",
    }),
    width: z.optional(z.union([z.int(), z.unknown()])),
  })
  .register(z.globalRegistry, {
    description: "Represents an image file.",
  });

/**
 * Output
 */
export const zLayerDiffusionOutput = z.object({
  image: zImageType3,
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used to generate the image.",
  }),
});

/**
 * Input
 */
export const zLayerDiffusionInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The prompt to use for generating the image. Be as descriptive as possible for best results.",
      }),
    )
    .default(""),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "The guidance scale for the model.",
      }),
    )
    .default(8),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(40).register(z.globalRegistry, {
        description: "The number of inference steps for the model.",
      }),
    )
    .default(20),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The prompt to use for generating the negative image. Be as descriptive as possible for best results.",
      }),
    )
    .default("text, watermark"),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to false, the safety checker will be disabled.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zStableDiffusionV15Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * LoraWeight
 */
export const zLoraWeightType2 = z.object({
  path: z.string().register(z.globalRegistry, {
    description: "URL or the path to the LoRA weights. Or HF model name.",
  }),
  scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            The scale of the LoRA weight. This is used to scale the LoRA weight\n            before merging it with the base model.\n        ",
      }),
    )
    .default(1),
  force: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the embedding will be forced to be used.",
      }),
    )
    .default(false),
});

/**
 * TextToImageSD15Input
 */
export const zStableDiffusionV15Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zEmbedding).register(z.globalRegistry, {
        description: "The list of embeddings to use.",
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoraWeightType2).register(z.globalRegistry, {
        description: "The list of LoRA weights to use.",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(7.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_checker_version: z.optional(
    z.enum(["v1", "v2"]).register(z.globalRegistry, {
      description:
        "The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.",
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ",
      }),
    )
    .default(""),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(25),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * Output
 */
export const zDreamshaperOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * DreamshaperTextToImageInput
 */
export const zDreamshaperInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zEmbedding).register(z.globalRegistry, {
        description: "The list of embeddings to use.",
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoraWeightType2).register(z.globalRegistry, {
        description: "The list of LoRA weights to use.",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The negative prompt to use. Use it to address details that you don't want in the image.",
      }),
    )
    .default(
      "(worst quality, low quality, normal quality, lowres, low details, oversaturated, undersaturated, overexposed, underexposed, grayscale, bw, bad photo, bad photography, bad art:1.4), (watermark, signature, text font, username, error, logo, words, letters, digits, autograph, trademark, name:1.2), (blur, blurry, grainy), morbid, ugly, asymmetrical, mutated malformed, mutilated, poorly lit, bad shadow, draft, cropped, out of frame, cut off, censored, jpeg artifacts, out of focus, glitch, duplicate, (airbrushed, cartoon, anime, semi-realistic, cgi, render, blender, digital art, manga, amateur:1.3), (3D ,3D Game, 3D Game Scene, 3D Character:1.1), (bad hands, bad anatomy, bad body, bad face, bad teeth, bad arms, bad legs, deformities:1.3)",
    ),
  format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  model_name: z.optional(
    z
      .enum([
        "Lykon/dreamshaper-xl-1-0",
        "Lykon/dreamshaper-xl-v2-turbo",
        "Lykon/dreamshaper-8",
      ])
      .register(z.globalRegistry, {
        description: "The Dreamshaper model to use.",
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  safety_checker_version: z.optional(
    z.enum(["v1", "v2"]).register(z.globalRegistry, {
      description:
        "The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(70).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(35),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * Output
 */
export const zRealisticVisionOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * RealisticVisionTextToImageInput
 */
export const zRealisticVisionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zEmbedding).register(z.globalRegistry, {
        description: "The list of embeddings to use.",
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoraWeightType2).register(z.globalRegistry, {
        description: "The list of LoRA weights to use.",
      }),
    )
    .default([]),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The rescale factor for the CFG.",
      }),
    )
    .default(0),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The negative prompt to use. Use it to address details that you don't want in the image.",
      }),
    )
    .default(
      "(worst quality, low quality, normal quality, lowres, low details, oversaturated, undersaturated, overexposed, underexposed, grayscale, bw, bad photo, bad photography, bad art:1.4), (watermark, signature, text font, username, error, logo, words, letters, digits, autograph, trademark, name:1.2), (blur, blurry, grainy), morbid, ugly, asymmetrical, mutated malformed, mutilated, poorly lit, bad shadow, draft, cropped, out of frame, cut off, censored, jpeg artifacts, out of focus, glitch, duplicate, (airbrushed, cartoon, anime, semi-realistic, cgi, render, blender, digital art, manga, amateur:1.3), (3D ,3D Game, 3D Game Scene, 3D Character:1.1), (bad hands, bad anatomy, bad body, bad face, bad teeth, bad arms, bad legs, deformities:1.3)",
    ),
  format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  model_name: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The Realistic Vision model to use.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_checker_version: z.optional(
    z.enum(["v1", "v2"]).register(z.globalRegistry, {
      description:
        "The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.",
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ",
      }),
    )
    .default(""),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(70).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(35),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * Output
 */
export const zPlaygroundV25Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImagePlaygroundv25Input
 */
export const zPlaygroundV25Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zEmbedding).register(z.globalRegistry, {
        description: "The list of embeddings to use.",
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The rescale factor for the CFG.",
      }),
    )
    .default(0),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  safety_checker_version: z.optional(
    z.enum(["v1", "v2"]).register(z.globalRegistry, {
      description:
        "The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.",
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ",
      }),
    )
    .default(""),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(25),
});

/**
 * Output
 */
export const zLightningModelsOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * LightningModelsTextToImageInput
 */
export const zLightningModelsInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zEmbedding).register(z.globalRegistry, {
        description: "The list of embeddings to use.",
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoraWeightType2).register(z.globalRegistry, {
        description: "The list of LoRA weights to use.",
      }),
    )
    .default([]),
  scheduler: z.optional(
    z
      .enum([
        "DPM++ 2M",
        "DPM++ 2M Karras",
        "DPM++ 2M SDE",
        "DPM++ 2M SDE Karras",
        "DPM++ SDE",
        "DPM++ SDE Karras",
        "KDPM 2A",
        "Euler",
        "Euler (trailing timesteps)",
        "Euler A",
        "LCM",
        "EDMDPMSolverMultistepScheduler",
        "TCDScheduler",
      ])
      .register(z.globalRegistry, {
        description:
          "Scheduler / sampler to use for the image denoising process.",
      }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(2),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The negative prompt to use. Use it to address details that you don't want in the image.",
      }),
    )
    .default(
      "(worst quality, low quality, normal quality, lowres, low details, oversaturated, undersaturated, overexposed, underexposed, grayscale, bw, bad photo, bad photography, bad art:1.4), (watermark, signature, text font, username, error, logo, words, letters, digits, autograph, trademark, name:1.2), (blur, blurry, grainy), morbid, ugly, asymmetrical, mutated malformed, mutilated, poorly lit, bad shadow, draft, cropped, out of frame, cut off, censored, jpeg artifacts, out of focus, glitch, duplicate, (airbrushed, cartoon, anime, semi-realistic, cgi, render, blender, digital art, manga, amateur:1.3), (3D ,3D Game, 3D Game Scene, 3D Character:1.1), (bad hands, bad anatomy, bad body, bad face, bad teeth, bad arms, bad legs, deformities:1.3)",
    ),
  format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  model_name: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The Lightning model to use.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  safety_checker_version: z.optional(
    z.enum(["v1", "v2"]).register(z.globalRegistry, {
      description:
        "The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(12).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * T2IOutput
 */
export const zLumaPhotonOutput = z.object({
  images: z.array(zFile).register(z.globalRegistry, {
    description: "The generated image",
  }),
});

/**
 * TextToImageRequest
 */
export const zLumaPhotonInput = z.object({
  prompt: z.string().min(3).max(5000),
  aspect_ratio: z.optional(
    z
      .enum(["16:9", "9:16", "1:1", "4:3", "3:4", "21:9", "9:21"])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated video",
      }),
  ),
});

/**
 * Output
 */
export const zStableCascadeSoteDiffusionOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * SoteDiffusionInput
 */
export const zStableCascadeSoteDiffusionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  second_stage_guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(2),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the image will be returned as base64 encoded string.\n        ",
      }),
    )
    .default(false),
  first_stage_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: "Number of steps to run the first stage for.",
      }),
    )
    .default(25),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(8),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Cascade\n            will output the same image every time.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to false, the safety checker will be disabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  second_stage_steps: z
    .optional(
      z.int().gte(4).lte(24).register(z.globalRegistry, {
        description: "Number of steps to run the second stage for.",
      }),
    )
    .default(10),
});

/**
 * Output
 */
export const zFastSdxlOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * TextToImageInput
 */
export const zFastSdxlInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zEmbedding).register(z.globalRegistry, {
        description: "The list of embeddings to use.",
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoraWeightType2).register(z.globalRegistry, {
        description: "The list of LoRA weights to use.",
      }),
    )
    .default([]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(7.5),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_checker_version: z.optional(
    z.enum(["v1", "v2"]).register(z.globalRegistry, {
      description:
        "The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.",
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ",
      }),
    )
    .default(""),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(25),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * Output
 */
export const zStableCascadeOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * StableCascadeInput
 */
export const zStableCascadeInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  second_stage_guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(0),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the image will be returned as base64 encoded string.\n        ",
      }),
    )
    .default(false),
  first_stage_steps: z
    .optional(
      z.int().gte(4).lte(40).register(z.globalRegistry, {
        description: "Number of steps to run the first stage for.",
      }),
    )
    .default(20),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(4),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Cascade\n            will output the same image every time.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to false, the safety checker will be disabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  second_stage_steps: z
    .optional(
      z.int().gte(4).lte(24).register(z.globalRegistry, {
        description: "Number of steps to run the second stage for.",
      }),
    )
    .default(10),
});

/**
 * Output
 */
export const zKolorsOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * KolorsInput
 */
export const zKolorsInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "\n            The prompt to use for generating the image. Be as descriptive as possible\n            for best results.\n        ",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and\n            uploaded before returning the response. This will increase the latency of\n            the function but it allows you to get the image directly in the response\n            without going through the CDN.\n        ",
      }),
    )
    .default(false),
  scheduler: z.optional(
    z
      .enum([
        "EulerDiscreteScheduler",
        "EulerAncestralDiscreteScheduler",
        "DPMSolverMultistepScheduler",
        "DPMSolverMultistepScheduler_SDE_karras",
        "UniPCMultistepScheduler",
        "DEISMultistepScheduler",
      ])
      .register(z.globalRegistry, {
        description: "The scheduler to use for the model.",
      }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show\n            you.\n        ",
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(150).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(50),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Seed",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small\n            details (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Enable safety checker.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zSdxlControlnetUnionOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageControlNetUnionInput
 */
export const zSdxlControlnetUnionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  depth_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to preprocess the depth image.",
      }),
    )
    .default(true),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
      z.null(),
    ]),
  ),
  normal_image_url: z.optional(z.union([z.string(), z.string()])),
  embeddings: z
    .optional(
      z.array(zEmbedding).register(z.globalRegistry, {
        description: "The list of embeddings to use.",
      }),
    )
    .default([]),
  teed_image_url: z.optional(z.union([z.string(), z.string()])),
  loras: z
    .optional(
      z.array(zLoraWeightType2).register(z.globalRegistry, {
        description: "The list of LoRA weights to use.",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(7.5),
  canny_image_url: z.optional(z.union([z.string(), z.string()])),
  segmentation_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to preprocess the segmentation image.",
      }),
    )
    .default(true),
  format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ",
      }),
    )
    .default(""),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  segmentation_image_url: z.optional(z.union([z.string(), z.string()])),
  openpose_image_url: z.optional(z.union([z.string(), z.string()])),
  canny_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to preprocess the canny image.",
      }),
    )
    .default(true),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  depth_image_url: z.optional(z.union([z.string(), z.string()])),
  normal_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to preprocess the normal image.",
      }),
    )
    .default(true),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  teed_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to preprocess the teed image.",
      }),
    )
    .default(true),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  controlnet_conditioning_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The scale of the controlnet conditioning.",
      }),
    )
    .default(0.5),
  safety_checker_version: z.optional(
    z.enum(["v1", "v2"]).register(z.globalRegistry, {
      description:
        "The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.",
    }),
  ),
  openpose_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to preprocess the openpose image.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(70).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(35),
});

/**
 * Output
 */
export const zFluxSubjectOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * FluxSubjectInput
 */
export const zFluxSubjectInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(8),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * PixArtSigmaOutput
 */
export const zPixartSigmaOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description:
      "The timings of the different steps of the generation process.",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * PixArtSigmaInput
 */
export const zPixartSigmaInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  style: z.optional(
    z
      .enum([
        "(No style)",
        "Cinematic",
        "Photographic",
        "Anime",
        "Manga",
        "Digital Art",
        "Pixel art",
        "Fantasy art",
        "Neonpunk",
        "3D Model",
      ])
      .register(z.globalRegistry, {
        description: "The style to apply to the image.",
      }),
  ),
  scheduler: z.optional(
    z.enum(["DPM-SOLVER", "SA-SOLVER"]).register(z.globalRegistry, {
      description: "The scheduler to use for the model.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(4.5),
  num_inference_steps: z
    .optional(
      z.int().gte(5).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(35),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(false),
});

/**
 * Output
 */
export const zSanaOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageInput
 */
export const zSanaInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  style_name: z.optional(
    z
      .enum([
        "(No style)",
        "Cinematic",
        "Photographic",
        "Anime",
        "Manga",
        "Digital Art",
        "Pixel art",
        "Fantasy art",
        "Neonpunk",
        "3D Model",
      ])
      .register(z.globalRegistry, {
        description: "The style to generate the image in.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(18),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * FooocusOutput
 */
export const zFooocusUpscaleOrVaryOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated image file info.",
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: "The time taken for the generation process.",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
});

/**
 * FooocusUpscaleOrVaryInput
 */
export const zFooocusUpscaleOrVaryInput = z.object({
  styles: z
    .optional(
      z
        .array(
          z.enum([
            "Fooocus V2",
            "Fooocus Enhance",
            "Fooocus Sharp",
            "Fooocus Semi Realistic",
            "Fooocus Masterpiece",
            "Fooocus Photograph",
            "Fooocus Negative",
            "Fooocus Cinematic",
            "SAI 3D Model",
            "SAI Analog Film",
            "SAI Anime",
            "SAI Cinematic",
            "SAI Comic Book",
            "SAI Craft Clay",
            "SAI Digital Art",
            "SAI Enhance",
            "SAI Fantasy Art",
            "SAI Isometric",
            "SAI Line Art",
            "SAI Lowpoly",
            "SAI Neonpunk",
            "SAI Origami",
            "SAI Photographic",
            "SAI Pixel Art",
            "SAI Texture",
            "MRE Cinematic Dynamic",
            "MRE Spontaneous Picture",
            "MRE Artistic Vision",
            "MRE Dark Dream",
            "MRE Gloomy Art",
            "MRE Bad Dream",
            "MRE Underground",
            "MRE Surreal Painting",
            "MRE Dynamic Illustration",
            "MRE Undead Art",
            "MRE Elemental Art",
            "MRE Space Art",
            "MRE Ancient Illustration",
            "MRE Brave Art",
            "MRE Heroic Fantasy",
            "MRE Dark Cyberpunk",
            "MRE Lyrical Geometry",
            "MRE Sumi E Symbolic",
            "MRE Sumi E Detailed",
            "MRE Manga",
            "MRE Anime",
            "MRE Comic",
            "Ads Advertising",
            "Ads Automotive",
            "Ads Corporate",
            "Ads Fashion Editorial",
            "Ads Food Photography",
            "Ads Gourmet Food Photography",
            "Ads Luxury",
            "Ads Real Estate",
            "Ads Retail",
            "Artstyle Abstract",
            "Artstyle Abstract Expressionism",
            "Artstyle Art Deco",
            "Artstyle Art Nouveau",
            "Artstyle Constructivist",
            "Artstyle Cubist",
            "Artstyle Expressionist",
            "Artstyle Graffiti",
            "Artstyle Hyperrealism",
            "Artstyle Impressionist",
            "Artstyle Pointillism",
            "Artstyle Pop Art",
            "Artstyle Psychedelic",
            "Artstyle Renaissance",
            "Artstyle Steampunk",
            "Artstyle Surrealist",
            "Artstyle Typography",
            "Artstyle Watercolor",
            "Futuristic Biomechanical",
            "Futuristic Biomechanical Cyberpunk",
            "Futuristic Cybernetic",
            "Futuristic Cybernetic Robot",
            "Futuristic Cyberpunk Cityscape",
            "Futuristic Futuristic",
            "Futuristic Retro Cyberpunk",
            "Futuristic Retro Futurism",
            "Futuristic Sci Fi",
            "Futuristic Vaporwave",
            "Game Bubble Bobble",
            "Game Cyberpunk Game",
            "Game Fighting Game",
            "Game Gta",
            "Game Mario",
            "Game Minecraft",
            "Game Pokemon",
            "Game Retro Arcade",
            "Game Retro Game",
            "Game Rpg Fantasy Game",
            "Game Strategy Game",
            "Game Streetfighter",
            "Game Zelda",
            "Misc Architectural",
            "Misc Disco",
            "Misc Dreamscape",
            "Misc Dystopian",
            "Misc Fairy Tale",
            "Misc Gothic",
            "Misc Grunge",
            "Misc Horror",
            "Misc Kawaii",
            "Misc Lovecraftian",
            "Misc Macabre",
            "Misc Manga",
            "Misc Metropolis",
            "Misc Minimalist",
            "Misc Monochrome",
            "Misc Nautical",
            "Misc Space",
            "Misc Stained Glass",
            "Misc Techwear Fashion",
            "Misc Tribal",
            "Misc Zentangle",
            "Papercraft Collage",
            "Papercraft Flat Papercut",
            "Papercraft Kirigami",
            "Papercraft Paper Mache",
            "Papercraft Paper Quilling",
            "Papercraft Papercut Collage",
            "Papercraft Papercut Shadow Box",
            "Papercraft Stacked Papercut",
            "Papercraft Thick Layered Papercut",
            "Photo Alien",
            "Photo Film Noir",
            "Photo Glamour",
            "Photo Hdr",
            "Photo Iphone Photographic",
            "Photo Long Exposure",
            "Photo Neon Noir",
            "Photo Silhouette",
            "Photo Tilt Shift",
            "Cinematic Diva",
            "Abstract Expressionism",
            "Academia",
            "Action Figure",
            "Adorable 3D Character",
            "Adorable Kawaii",
            "Art Deco",
            "Art Nouveau",
            "Astral Aura",
            "Avant Garde",
            "Baroque",
            "Bauhaus Style Poster",
            "Blueprint Schematic Drawing",
            "Caricature",
            "Cel Shaded Art",
            "Character Design Sheet",
            "Classicism Art",
            "Color Field Painting",
            "Colored Pencil Art",
            "Conceptual Art",
            "Constructivism",
            "Cubism",
            "Dadaism",
            "Dark Fantasy",
            "Dark Moody Atmosphere",
            "Dmt Art Style",
            "Doodle Art",
            "Double Exposure",
            "Dripping Paint Splatter Art",
            "Expressionism",
            "Faded Polaroid Photo",
            "Fauvism",
            "Flat 2d Art",
            "Fortnite Art Style",
            "Futurism",
            "Glitchcore",
            "Glo Fi",
            "Googie Art Style",
            "Graffiti Art",
            "Harlem Renaissance Art",
            "High Fashion",
            "Idyllic",
            "Impressionism",
            "Infographic Drawing",
            "Ink Dripping Drawing",
            "Japanese Ink Drawing",
            "Knolling Photography",
            "Light Cheery Atmosphere",
            "Logo Design",
            "Luxurious Elegance",
            "Macro Photography",
            "Mandola Art",
            "Marker Drawing",
            "Medievalism",
            "Minimalism",
            "Neo Baroque",
            "Neo Byzantine",
            "Neo Futurism",
            "Neo Impressionism",
            "Neo Rococo",
            "Neoclassicism",
            "Op Art",
            "Ornate And Intricate",
            "Pencil Sketch Drawing",
            "Pop Art 2",
            "Rococo",
            "Silhouette Art",
            "Simple Vector Art",
            "Sketchup",
            "Steampunk 2",
            "Surrealism",
            "Suprematism",
            "Terragen",
            "Tranquil Relaxing Atmosphere",
            "Sticker Designs",
            "Vibrant Rim Light",
            "Volumetric Lighting",
            "Watercolor 2",
            "Whimsical And Playful",
            "Mk Chromolithography",
            "Mk Cross Processing Print",
            "Mk Dufaycolor Photograph",
            "Mk Herbarium",
            "Mk Punk Collage",
            "Mk Mosaic",
            "Mk Van Gogh",
            "Mk Coloring Book",
            "Mk Singer Sargent",
            "Mk Pollock",
            "Mk Basquiat",
            "Mk Andy Warhol",
            "Mk Halftone Print",
            "Mk Gond Painting",
            "Mk Albumen Print",
            "Mk Aquatint Print",
            "Mk Anthotype Print",
            "Mk Inuit Carving",
            "Mk Bromoil Print",
            "Mk Calotype Print",
            "Mk Color Sketchnote",
            "Mk Cibulak Porcelain",
            "Mk Alcohol Ink Art",
            "Mk One Line Art",
            "Mk Blacklight Paint",
            "Mk Carnival Glass",
            "Mk Cyanotype Print",
            "Mk Cross Stitching",
            "Mk Encaustic Paint",
            "Mk Embroidery",
            "Mk Gyotaku",
            "Mk Luminogram",
            "Mk Lite Brite Art",
            "Mk Mokume Gane",
            "Pebble Art",
            "Mk Palekh",
            "Mk Suminagashi",
            "Mk Scrimshaw",
            "Mk Shibori",
            "Mk Vitreous Enamel",
            "Mk Ukiyo E",
            "Mk Vintage Airline Poster",
            "Mk Vintage Travel Poster",
            "Mk Bauhaus Style",
            "Mk Afrofuturism",
            "Mk Atompunk",
            "Mk Constructivism",
            "Mk Chicano Art",
            "Mk De Stijl",
            "Mk Dayak Art",
            "Mk Fayum Portrait",
            "Mk Illuminated Manuscript",
            "Mk Kalighat Painting",
            "Mk Madhubani Painting",
            "Mk Pictorialism",
            "Mk Pichwai Painting",
            "Mk Patachitra Painting",
            "Mk Samoan Art Inspired",
            "Mk Tlingit Art",
            "Mk Adnate Style",
            "Mk Ron English Style",
            "Mk Shepard Fairey Style",
          ]),
        )
        .register(z.globalRegistry, {
          description: "\n            The style to use.\n        ",
        }),
    )
    .default(["Fooocus Enhance", "Fooocus V2", "Fooocus Sharp"]),
  uov_image_url: z.union([z.string(), z.string()]),
  performance: z.optional(
    z
      .enum(["Speed", "Quality", "Extreme Speed", "Lightning"])
      .register(z.globalRegistry, {
        description: "\n            You can choose Speed or Quality\n        ",
      }),
  ),
  mixing_image_prompt_and_vary_upscale: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Mixing Image Prompt and Vary/Upscale",
      }),
    )
    .default(false),
  image_prompt_3: z.optional(zImagePrompt),
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The prompt to use for generating the image. Be as descriptive as possible for best results.",
      }),
    )
    .default(""),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use up to 5 LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([
      {
        path: "https://huggingface.co/stabilityai/stable-diffusion-xl-base-1.0/resolve/main/sd_xl_offset_example-lora_1.0.safetensors",
        scale: 0.1,
      },
    ]),
  image_prompt_4: z.optional(zImagePrompt),
  image_prompt_1: z.optional(zImagePrompt),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to false, the safety checker will be disabled.",
      }),
    )
    .default(true),
  sharpness: z
    .optional(
      z.number().gte(0).lte(30).register(z.globalRegistry, {
        description:
          "\n            The sharpness of the generated image. Use it to control how sharp the generated\n            image should be. Higher value means image and texture are sharper.\n        ",
      }),
    )
    .default(2),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(30).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(4),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  aspect_ratio: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The size of the generated image. You can choose between some presets or\n            custom height and width that **must be multiples of 8**.\n        ",
      }),
    )
    .default("1024x1024"),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "\n            Number of images to generate in one request\n        ",
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  refiner_model: z.optional(
    z
      .enum(["None", "realisticVisionV60B1_v51VAE.safetensors"])
      .register(z.globalRegistry, {
        description: "Refiner (SDXL or SD 1.5)",
      }),
  ),
  image_prompt_2: z.optional(zImagePrompt),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  uov_method: z.optional(
    z
      .enum([
        "Disabled",
        "Vary (Subtle)",
        "Vary (Strong)",
        "Upscale (1.5x)",
        "Upscale (2x)",
        "Upscale (Fast 2x)",
      ])
      .register(z.globalRegistry, {
        description: "The method to use for upscaling or varying.",
      }),
  ),
  seed: z.optional(z.union([z.int(), z.null()])),
  refiner_switch: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            Use 0.4 for SD1.5 realistic models; 0.667 for SD1.5 anime models\n            0.8 for XL-refiners; or any value for switching two SDXL models.\n        ",
      }),
    )
    .default(0.8),
});

/**
 * SD3Output
 */
export const zStableDiffusionV3MediumOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  num_images: z.int().register(z.globalRegistry, {
    description: "The number of images generated.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageInput
 */
export const zStableDiffusionV3MediumInput = z.object({
  prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, prompt will be upsampled with more details.",
      }),
    )
    .default(false),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The negative prompt to generate an image from.",
      }),
    )
    .default(""),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zFluxLoraInpaintingOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * InpaintInput
 */
export const zFluxLoraInpaintingInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "The number of images to generate. This is always set to 1 for streaming output.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.",
      }),
    )
    .default(0.85),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  mask_url: z.union([z.string(), z.string()]),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zStableDiffusionV35MediumOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageInput
 */
export const zStableDiffusionV35MediumInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(4.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(40),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zFluxSchnellOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * SchnellTextToImageInput
 */
export const zFluxSchnellInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(12).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(4),
});

/**
 * Output
 */
export const zOmnigenV1Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageInput
 */
export const zOmnigenV1Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  img_guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The Image Guidance scale is a measure of how close you want\n            the model to stick to your input image when looking for a related image to show you.\n        ",
      }),
    )
    .default(1.6),
  input_image_urls: z
    .optional(
      z.array(z.string()).register(z.globalRegistry, {
        description:
          "URL of images to use while generating the image, Use <img><|image_1|></img> for the first image and so on.",
      }),
    )
    .default([]),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(50),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * Output
 */
export const zAuraFlowOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The expanded prompt",
  }),
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used to generate the images",
  }),
});

/**
 * Input
 */
export const zAuraFlowInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate images from",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(2).register(z.globalRegistry, {
        description: "The number of images to generate",
      }),
    )
    .default(1),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to perform prompt expansion (recommended)",
      }),
    )
    .default(true),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "Classifier free guidance scale",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(20).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to take",
      }),
    )
    .default(50),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The seed to use for generating images",
    }),
  ),
});

/**
 * T2IOutput
 */
export const zLumaPhotonFlashOutput = z.object({
  images: z.array(zFile).register(z.globalRegistry, {
    description: "The generated image",
  }),
});

/**
 * TextToImageRequest
 */
export const zLumaPhotonFlashInput = z.object({
  prompt: z.string().min(3).max(5000),
  aspect_ratio: z.optional(
    z
      .enum(["16:9", "9:16", "1:1", "4:3", "3:4", "21:9", "9:21"])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated video",
      }),
  ),
});

/**
 * File
 */
export const zFileType2 = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: "The URL where the file can be downloaded from.",
  }),
});

/**
 * Output
 */
export const zIdeogramV2TurboOutput = z.object({
  images: z.array(zFileType2),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for the random number generator",
  }),
});

/**
 * TextToImageInput
 */
export const zIdeogramV2TurboInput = z.object({
  prompt: z.string(),
  aspect_ratio: z.optional(
    z
      .enum([
        "10:16",
        "16:10",
        "9:16",
        "16:9",
        "4:3",
        "3:4",
        "1:1",
        "1:3",
        "3:1",
        "3:2",
        "2:3",
      ])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image",
      }),
  ),
  style: z.optional(
    z
      .enum(["auto", "general", "realistic", "design", "render_3D", "anime"])
      .register(z.globalRegistry, {
        description: "The style of the generated image",
      }),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to expand the prompt with MagicPrompt functionality.",
      }),
    )
    .default(true),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "A negative prompt to avoid in the generated image",
      }),
    )
    .default(""),
});

/**
 * Recraft20BTextToImageOutput
 */
export const zRecraft20bOutput = z.object({
  images: z.array(zFile),
});

/**
 * RGBColor
 */
export const zRgbColor = z.object({
  r: z
    .optional(
      z.int().gte(0).lte(255).register(z.globalRegistry, {
        description: "Red color value",
      }),
    )
    .default(0),
  b: z
    .optional(
      z.int().gte(0).lte(255).register(z.globalRegistry, {
        description: "Blue color value",
      }),
    )
    .default(0),
  g: z
    .optional(
      z.int().gte(0).lte(255).register(z.globalRegistry, {
        description: "Green color value",
      }),
    )
    .default(0),
});

/**
 * Recraft20BTextToImageInput
 */
export const zRecraft20bInput = z.object({
  prompt: z.string().min(1).max(1000),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(false),
  colors: z
    .optional(
      z.array(zRgbColor).register(z.globalRegistry, {
        description: "An array of preferable colors",
      }),
    )
    .default([]),
  style: z.optional(
    z
      .enum([
        "any",
        "realistic_image",
        "digital_illustration",
        "vector_illustration",
        "realistic_image/b_and_w",
        "realistic_image/enterprise",
        "realistic_image/hard_flash",
        "realistic_image/hdr",
        "realistic_image/motion_blur",
        "realistic_image/natural_light",
        "realistic_image/studio_portrait",
        "digital_illustration/2d_art_poster",
        "digital_illustration/2d_art_poster_2",
        "digital_illustration/3d",
        "digital_illustration/80s",
        "digital_illustration/engraving_color",
        "digital_illustration/glow",
        "digital_illustration/grain",
        "digital_illustration/hand_drawn",
        "digital_illustration/hand_drawn_outline",
        "digital_illustration/handmade_3d",
        "digital_illustration/infantile_sketch",
        "digital_illustration/kawaii",
        "digital_illustration/pixel_art",
        "digital_illustration/psychedelic",
        "digital_illustration/seamless",
        "digital_illustration/voxel",
        "digital_illustration/watercolor",
        "vector_illustration/cartoon",
        "vector_illustration/doodle_line_art",
        "vector_illustration/engraving",
        "vector_illustration/flat_2",
        "vector_illustration/kawaii",
        "vector_illustration/line_art",
        "vector_illustration/line_circuit",
        "vector_illustration/linocut",
        "vector_illustration/seamless",
      ])
      .register(z.globalRegistry, {
        description:
          "The style of the generated images. Vector images cost 2X as much.",
      }),
  ),
  style_id: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The ID of the custom style reference (optional)",
    }),
  ),
});

/**
 * Output
 */
export const zBriaTextToImageHdOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed value used for generation.",
  }),
});

/**
 * GuidanceInput
 */
export const zGuidanceInput = z.object({
  scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Impact of the guidance.",
      }),
    )
    .default(1),
  method: z.optional(
    z
      .enum([
        "controlnet_canny",
        "controlnet_depth",
        "controlnet_recoloring",
        "controlnet_color_grid",
      ])
      .register(z.globalRegistry, {
        description:
          "Which guidance type you would like to include in the generation. Up to 4 guidance methods can be combined during a single inference. This parameter is optional.",
      }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * TextToImageRequest
 */
export const zBriaTextToImageHdInput = z.object({
  prompt: z.string().min(1).register(z.globalRegistry, {
    description: "The prompt you would like to use to generate images.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "How many images you would like to generate. When using any Guidance Method, Value is set to 1.",
      }),
    )
    .default(4),
  prompt_enhancement: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "When set to true, enhances the provided prompt by generating additional, more descriptive variations, resulting in more diverse and creative output images.",
      }),
    )
    .default(false),
  guidance: z
    .optional(
      z.array(zGuidanceInput).register(z.globalRegistry, {
        description:
          "Guidance images to use for the generation. Up to 4 guidance methods can be combined during a single inference.",
      }),
    )
    .default([]),
  aspect_ratio: z.optional(
    z
      .enum(["1:1", "2:3", "3:2", "3:4", "4:3", "4:5", "5:4", "9:16", "16:9"])
      .register(z.globalRegistry, {
        description:
          "The aspect ratio of the image. When a guidance method is being used, the aspect ratio is defined by the guidance image and this parameter is ignored.",
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(5),
  medium: z.optional(
    z.enum(["photography", "art"]).register(z.globalRegistry, {
      description:
        "Which medium should be included in your generated images. This parameter is optional.",
    }),
  ),
  seed: z.optional(
    z.int().gte(0).lte(2147483647).register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The negative prompt you would like to use to generate images.",
      }),
    )
    .default(""),
  num_inference_steps: z
    .optional(
      z.int().gte(20).lte(50).register(z.globalRegistry, {
        description:
          "The number of iterations the model goes through to refine the generated image. This parameter is optional.",
      }),
    )
    .default(30),
});

/**
 * Output
 */
export const zBriaTextToImageFastOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed value used for generation.",
  }),
});

/**
 * FastTextToImageRequest
 */
export const zBriaTextToImageFastInput = z.object({
  prompt: z.string().min(1).register(z.globalRegistry, {
    description: "The prompt you would like to use to generate images.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "How many images you would like to generate. When using any Guidance Method, Value is set to 1.",
      }),
    )
    .default(4),
  prompt_enhancement: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "When set to true, enhances the provided prompt by generating additional, more descriptive variations, resulting in more diverse and creative output images.",
      }),
    )
    .default(false),
  guidance: z
    .optional(
      z.array(zGuidanceInput).register(z.globalRegistry, {
        description:
          "Guidance images to use for the generation. Up to 4 guidance methods can be combined during a single inference.",
      }),
    )
    .default([]),
  aspect_ratio: z.optional(
    z
      .enum(["1:1", "2:3", "3:2", "3:4", "4:3", "4:5", "5:4", "9:16", "16:9"])
      .register(z.globalRegistry, {
        description:
          "The aspect ratio of the image. When a guidance method is being used, the aspect ratio is defined by the guidance image and this parameter is ignored.",
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(5),
  medium: z.optional(
    z.enum(["photography", "art"]).register(z.globalRegistry, {
      description:
        "Which medium should be included in your generated images. This parameter is optional.",
    }),
  ),
  seed: z.optional(
    z.int().gte(0).lte(2147483647).register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The negative prompt you would like to use to generate images.",
      }),
    )
    .default(""),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(10).register(z.globalRegistry, {
        description:
          "The number of iterations the model goes through to refine the generated image. This parameter is optional.",
      }),
    )
    .default(8),
});

/**
 * Output
 */
export const zBriaTextToImageBaseOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed value used for generation.",
  }),
});

/**
 * TextToImageRequest
 */
export const zBriaTextToImageBaseInput = z.object({
  prompt: z.string().min(1).register(z.globalRegistry, {
    description: "The prompt you would like to use to generate images.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "How many images you would like to generate. When using any Guidance Method, Value is set to 1.",
      }),
    )
    .default(4),
  prompt_enhancement: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "When set to true, enhances the provided prompt by generating additional, more descriptive variations, resulting in more diverse and creative output images.",
      }),
    )
    .default(false),
  guidance: z
    .optional(
      z.array(zGuidanceInput).register(z.globalRegistry, {
        description:
          "Guidance images to use for the generation. Up to 4 guidance methods can be combined during a single inference.",
      }),
    )
    .default([]),
  aspect_ratio: z.optional(
    z
      .enum(["1:1", "2:3", "3:2", "3:4", "4:3", "4:5", "5:4", "9:16", "16:9"])
      .register(z.globalRegistry, {
        description:
          "The aspect ratio of the image. When a guidance method is being used, the aspect ratio is defined by the guidance image and this parameter is ignored.",
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(5),
  medium: z.optional(
    z.enum(["photography", "art"]).register(z.globalRegistry, {
      description:
        "Which medium should be included in your generated images. This parameter is optional.",
    }),
  ),
  seed: z.optional(
    z.int().gte(0).lte(2147483647).register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The negative prompt you would like to use to generate images.",
      }),
    )
    .default(""),
  num_inference_steps: z
    .optional(
      z.int().gte(20).lte(50).register(z.globalRegistry, {
        description:
          "The number of iterations the model goes through to refine the generated image. This parameter is optional.",
      }),
    )
    .default(30),
});

/**
 * SwittiOutput
 */
export const zSwitti512Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated images",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageInput
 */
export const zSwitti512Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  sampling_top_k: z
    .optional(
      z.int().gte(10).lte(1000).register(z.globalRegistry, {
        description: "The number of top-k tokens to sample from.",
      }),
    )
    .default(400),
  turn_off_cfg_start_si: z
    .optional(
      z.int().gte(0).lte(10).register(z.globalRegistry, {
        description: "Disable CFG starting scale",
      }),
    )
    .default(8),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(6),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  smooth_start_si: z
    .optional(
      z.int().gte(0).lte(10).register(z.globalRegistry, {
        description: "Smoothing starting scale",
      }),
    )
    .default(2),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  last_scale_temp: z
    .optional(
      z.number().gte(0.1).lte(10).register(z.globalRegistry, {
        description: "Temperature after disabling CFG",
      }),
    )
    .default(0.1),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  more_diverse: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "More diverse sampling",
      }),
    )
    .default(false),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  more_smooth: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Smoothing with Gumbel softmax sampling",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  sampling_top_p: z
    .optional(
      z.number().gte(0.1).lte(1).register(z.globalRegistry, {
        description: "The top-p probability to sample from.",
      }),
    )
    .default(0.95),
});

/**
 * SwittiOutput
 */
export const zSwittiOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated images",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageInput
 */
export const zSwittiInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  sampling_top_k: z
    .optional(
      z.int().gte(10).lte(1000).register(z.globalRegistry, {
        description: "The number of top-k tokens to sample from.",
      }),
    )
    .default(400),
  turn_off_cfg_start_si: z
    .optional(
      z.int().gte(0).lte(10).register(z.globalRegistry, {
        description: "Disable CFG starting scale",
      }),
    )
    .default(8),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(6),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  smooth_start_si: z
    .optional(
      z.int().gte(0).lte(10).register(z.globalRegistry, {
        description: "Smoothing starting scale",
      }),
    )
    .default(2),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  last_scale_temp: z
    .optional(
      z.number().gte(0.1).lte(10).register(z.globalRegistry, {
        description: "Temperature after disabling CFG",
      }),
    )
    .default(0.1),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  more_diverse: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "More diverse sampling",
      }),
    )
    .default(false),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  more_smooth: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Smoothing with Gumbel softmax sampling",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  sampling_top_p: z
    .optional(
      z.number().gte(0.1).lte(1).register(z.globalRegistry, {
        description: "The top-p probability to sample from.",
      }),
    )
    .default(0.95),
});

/**
 * Image
 */
export const zRegistryImageFastSdxlModelsImage = z.object({
  height: z.int(),
  content_type: z.optional(z.string()).default("image/jpeg"),
  url: z.string(),
  width: z.int(),
});

/**
 * Output
 */
export const zFluxProV11UltraFinetunedOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z
    .array(zRegistryImageFastSdxlModelsImage)
    .register(z.globalRegistry, {
      description: "The generated image files info.",
    }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * FluxProUltraTextToImageFinetunedInput
 */
export const zFluxProV11UltraFinetunedInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  finetune_id: z.string().register(z.globalRegistry, {
    description: "References your specific model",
  }),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.",
    }),
  ),
  image_prompt_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The strength of the image prompt, between 0 and 1.",
      }),
    )
    .default(0.1),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enhance the prompt for better results.",
      }),
    )
    .default(false),
  raw: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Generate less processed, more natural-looking images.",
      }),
    )
    .default(false),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z.union([
      z.enum([
        "21:9",
        "16:9",
        "4:3",
        "3:2",
        "1:1",
        "2:3",
        "3:4",
        "9:16",
        "9:21",
      ]),
      z.string(),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.optional(z.union([z.string(), z.string()])),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  finetune_strength: z.number().gte(0).lte(2).register(z.globalRegistry, {
    description:
      "\n        Controls finetune influence.\n        Increase this value if your target concept isn't showing up strongly enough.\n        The optimal setting depends on your finetune and prompt\n        ",
  }),
});

/**
 * Output
 */
export const zFluxProV11Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z
    .array(zRegistryImageFastSdxlModelsImage)
    .register(z.globalRegistry, {
      description: "The generated image files info.",
    }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * FluxProPlusTextToImageInput
 */
export const zFluxProV11Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enhance the prompt for better results.",
      }),
    )
    .default(false),
});

/**
 * Output
 */
export const zJanusOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * JanusInput
 */
export const zJanusInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(16).register(z.globalRegistry, {
        description: "Number of images to generate in parallel.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  cfg_weight: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "Classifier Free Guidance scale - how closely to follow the prompt.",
      }),
    )
    .default(5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  temperature: z
    .optional(
      z.number().gte(0.1).lte(2).register(z.globalRegistry, {
        description:
          "Controls randomness in the generation. Higher values make output more random.",
      }),
    )
    .default(1),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Random seed for reproducible generation.",
    }),
  ),
});

/**
 * ImageOutput
 */
export const zLuminaImageV2Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated images",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageInput
 */
export const zLuminaImageV2Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  cfg_trunc_ratio: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "The ratio of the timestep interval to apply normalization-based guidance scale.",
      }),
    )
    .default(1),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  system_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The system prompt to use.",
      }),
    )
    .default(
      "You are an assistant designed to generate superior images with the superior degree of image-text alignment based on textual prompts or user prompts.",
    ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(4),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(30),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  cfg_normalization: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to apply normalization-based guidance scale.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zImagen3Output = z.object({
  images: z.array(zFile),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for generation",
  }),
});

/**
 * TextToImageInput
 */
export const zImagen3Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The text prompt describing what you want to see",
  }),
  aspect_ratio: z.optional(
    z.enum(["1:1", "16:9", "9:16", "3:4", "4:3"]).register(z.globalRegistry, {
      description: "The aspect ratio of the generated image",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "Number of images to generate (1-4)",
      }),
    )
    .default(1),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Random seed for reproducible generation",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "A description of what to discourage in the generated images",
      }),
    )
    .default(""),
});

/**
 * Output
 */
export const zImagen3FastOutput = z.object({
  images: z.array(zFile),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for generation",
  }),
});

/**
 * TextToImageInput
 */
export const zImagen3FastInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The text prompt describing what you want to see",
  }),
  aspect_ratio: z.optional(
    z.enum(["1:1", "16:9", "9:16", "3:4", "4:3"]).register(z.globalRegistry, {
      description: "The aspect ratio of the generated image",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "Number of images to generate (1-4)",
      }),
    )
    .default(1),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Random seed for reproducible generation",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "A description of what to discourage in the generated images",
      }),
    )
    .default(""),
});

/**
 * Output
 */
export const zFluxControlLoraDepthOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * DepthLoraInput
 */
export const zFluxControlLoraDepthInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  control_lora_strength: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description: "The strength of the control lora.",
      }),
    )
    .default(1),
  preprocess_depth: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the input image will be preprocessed to extract depth information.\n            This is useful for generating depth maps from images.\n        ",
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  control_lora_image_url: z.union([z.string(), z.string()]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * Output
 */
export const zFluxControlLoraCannyOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageInput
 */
export const zFluxControlLoraCannyInput = z.object({
  control_lora_strength: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description: "The strength of the control lora.",
      }),
    )
    .default(1),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  control_lora_image_url: z.optional(z.union([z.string(), z.string()])),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * Output
 */
export const zIdeogramV2aTurboOutput = z.object({
  images: z.array(zFileType2),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for the random number generator",
  }),
});

/**
 * BaseTextToImageInput
 */
export const zIdeogramV2aTurboInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  aspect_ratio: z.optional(
    z
      .enum([
        "10:16",
        "16:10",
        "9:16",
        "16:9",
        "4:3",
        "3:4",
        "1:1",
        "1:3",
        "3:1",
        "3:2",
        "2:3",
      ])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image",
      }),
  ),
  prompt: z.string(),
  style: z.optional(
    z
      .enum(["auto", "general", "realistic", "design", "render_3D", "anime"])
      .register(z.globalRegistry, {
        description: "The style of the generated image",
      }),
  ),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to expand the prompt with MagicPrompt functionality.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zIdeogramV2aOutput = z.object({
  images: z.array(zFileType2),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for the random number generator",
  }),
});

/**
 * BaseTextToImageInput
 */
export const zIdeogramV2aInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  aspect_ratio: z.optional(
    z
      .enum([
        "10:16",
        "16:10",
        "9:16",
        "16:9",
        "4:3",
        "3:4",
        "1:1",
        "1:3",
        "3:1",
        "3:2",
        "2:3",
      ])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image",
      }),
  ),
  prompt: z.string(),
  style: z.optional(
    z
      .enum(["auto", "general", "realistic", "design", "render_3D", "anime"])
      .register(z.globalRegistry, {
        description: "The style of the generated image",
      }),
  ),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to expand the prompt with MagicPrompt functionality.",
      }),
    )
    .default(true),
});

/**
 * ImageOutput
 */
export const zCogview4Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated images",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageInput
 */
export const zCogview4Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(50),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zRundiffusionPhotoFluxOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * PhotoLoraT2IInput
 */
export const zRundiffusionPhotoFluxInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  photo_lora_scale: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: "LoRA Scale of the photo lora model",
      }),
    )
    .default(0.75),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zJuggernautFluxProOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * DevTextToImageInput
 */
export const zJuggernautFluxProInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zJuggernautFluxLightningOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * SchnellTextToImageInput
 */
export const zJuggernautFluxLightningInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(12).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(4),
});

/**
 * Output
 */
export const zJuggernautFluxBaseOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * DevTextToImageInput
 */
export const zJuggernautFluxBaseInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zJuggernautFluxLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageInput
 */
export const zJuggernautFluxLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zSanaSprintOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * SprintInput
 */
export const zSanaSprintInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  style_name: z.optional(
    z
      .enum([
        "(No style)",
        "Cinematic",
        "Photographic",
        "Anime",
        "Manga",
        "Digital Art",
        "Pixel art",
        "Fantasy art",
        "Neonpunk",
        "3D Model",
      ])
      .register(z.globalRegistry, {
        description: "The style to generate the image in.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(20).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(2),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zSanaV1548bOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageInput
 */
export const zSanaV1548bInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  style_name: z.optional(
    z
      .enum([
        "(No style)",
        "Cinematic",
        "Photographic",
        "Anime",
        "Manga",
        "Digital Art",
        "Pixel art",
        "Fantasy art",
        "Neonpunk",
        "3D Model",
      ])
      .register(z.globalRegistry, {
        description: "The style to generate the image in.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(18),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zSanaV1516bOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageInput
 */
export const zSanaV1516bInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  style_name: z.optional(
    z
      .enum([
        "(No style)",
        "Cinematic",
        "Photographic",
        "Anime",
        "Manga",
        "Digital Art",
        "Pixel art",
        "Fantasy art",
        "Neonpunk",
        "3D Model",
      ])
      .register(z.globalRegistry, {
        description: "The style to generate the image in.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(18),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * ImageFile
 */
export const zImageFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The size of the file in bytes.",
    }),
  ),
  height: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The height of the image",
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: "The URL where the file can be downloaded from.",
  }),
  width: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The width of the image",
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "The name of the file. It will be auto-generated if not provided.",
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The mime type of the file.",
    }),
  ),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: "File data",
    }),
  ),
});

/**
 * ImageResponse
 */
export const zGptImage1TextToImageOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images.",
  }),
});

/**
 * TextToImageRequest
 */
export const zGptImage1TextToImageInput = z.object({
  prompt: z.string().min(2).register(z.globalRegistry, {
    description: "The prompt for image generation",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "Number of images to generate",
      }),
    )
    .default(1),
  image_size: z.optional(
    z
      .enum(["auto", "1024x1024", "1536x1024", "1024x1536"])
      .register(z.globalRegistry, {
        description: "Aspect ratio for the generated image",
      }),
  ),
  background: z.optional(
    z.enum(["auto", "transparent", "opaque"]).register(z.globalRegistry, {
      description: "Background for the generated image",
    }),
  ),
  quality: z.optional(
    z.enum(["auto", "low", "medium", "high"]).register(z.globalRegistry, {
      description: "Quality for the generated image",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "Output format for the images",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
});

/**
 * Output
 */
export const zFLiteTextureOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageInputTexture
 */
export const zFLiteTextureInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Negative Prompt for generation.",
      }),
    )
    .default(""),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zFLiteStandardOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageInputStandard
 */
export const zFLiteStandardInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Negative Prompt for generation.",
      }),
    )
    .default(""),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * OutputV3
 */
export const zIdeogramV3Output = z.object({
  images: z.array(zFileType2),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for the random number generator",
  }),
});

/**
 * ColorPaletteMember
 */
export const zColorPaletteMember = z.object({
  color_weight: z.optional(z.union([z.number().gte(0.05).lte(1), z.unknown()])),
  rgb: zRgbColor,
});

/**
 * ColorPalette
 */
export const zColorPalette = z.object({
  members: z.optional(z.union([z.array(zColorPaletteMember), z.unknown()])),
  name: z.optional(
    z.union([
      z.enum([
        "EMBER",
        "FRESH",
        "JUNGLE",
        "MAGIC",
        "MELON",
        "MOSAIC",
        "PASTEL",
        "ULTRAMARINE",
      ]),
      z.unknown(),
    ]),
  ),
});

/**
 * BaseTextToImageInputV3
 */
export const zIdeogramV3Input = z.object({
  prompt: z.string(),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "Number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
      z.unknown(),
    ]),
  ),
  style: z.optional(
    z.union([z.enum(["AUTO", "GENERAL", "REALISTIC", "DESIGN"]), z.unknown()]),
  ),
  style_preset: z.optional(
    z.union([
      z.enum([
        "80S_ILLUSTRATION",
        "90S_NOSTALGIA",
        "ABSTRACT_ORGANIC",
        "ANALOG_NOSTALGIA",
        "ART_BRUT",
        "ART_DECO",
        "ART_POSTER",
        "AURA",
        "AVANT_GARDE",
        "BAUHAUS",
        "BLUEPRINT",
        "BLURRY_MOTION",
        "BRIGHT_ART",
        "C4D_CARTOON",
        "CHILDRENS_BOOK",
        "COLLAGE",
        "COLORING_BOOK_I",
        "COLORING_BOOK_II",
        "CUBISM",
        "DARK_AURA",
        "DOODLE",
        "DOUBLE_EXPOSURE",
        "DRAMATIC_CINEMA",
        "EDITORIAL",
        "EMOTIONAL_MINIMAL",
        "ETHEREAL_PARTY",
        "EXPIRED_FILM",
        "FLAT_ART",
        "FLAT_VECTOR",
        "FOREST_REVERIE",
        "GEO_MINIMALIST",
        "GLASS_PRISM",
        "GOLDEN_HOUR",
        "GRAFFITI_I",
        "GRAFFITI_II",
        "HALFTONE_PRINT",
        "HIGH_CONTRAST",
        "HIPPIE_ERA",
        "ICONIC",
        "JAPANDI_FUSION",
        "JAZZY",
        "LONG_EXPOSURE",
        "MAGAZINE_EDITORIAL",
        "MINIMAL_ILLUSTRATION",
        "MIXED_MEDIA",
        "MONOCHROME",
        "NIGHTLIFE",
        "OIL_PAINTING",
        "OLD_CARTOONS",
        "PAINT_GESTURE",
        "POP_ART",
        "RETRO_ETCHING",
        "RIVIERA_POP",
        "SPOTLIGHT_80S",
        "STYLIZED_RED",
        "SURREAL_COLLAGE",
        "TRAVEL_POSTER",
        "VINTAGE_GEO",
        "VINTAGE_POSTER",
        "WATERCOLOR",
        "WEIRD",
        "WOODBLOCK_PRINT",
      ]),
      z.unknown(),
    ]),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Determine if MagicPrompt should be used in generating the request or not.",
      }),
    )
    .default(true),
  rendering_speed: z.optional(
    z.enum(["TURBO", "BALANCED", "QUALITY"]).register(z.globalRegistry, {
      description: "The rendering speed to use.",
    }),
  ),
  style_codes: z.optional(z.union([z.array(z.string()), z.unknown()])),
  color_palette: z.optional(z.union([zColorPalette, z.unknown()])),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  image_urls: z.optional(z.union([z.array(z.string()), z.unknown()])),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Description of what to exclude from an image. Descriptions in the prompt take precedence to descriptions in the negative prompt.",
      }),
    )
    .default(""),
});

/**
 * ImageOutput
 */
export const zPonyV7Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated images",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * Input
 */
export const zPonyV7Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate images from",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(2).register(z.globalRegistry, {
        description: "The number of images to generate",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  noise_source: z.optional(
    z.enum(["gpu", "cpu"]).register(z.globalRegistry, {
      description:
        "\n            The source of the noise to use for generating images.\n            If set to 'gpu', the noise will be generated on the GPU.\n            If set to 'cpu', the noise will be generated on the CPU.\n        ",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "Classifier free guidance scale",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(20).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to take",
      }),
    )
    .default(40),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The seed to use for generating images",
    }),
  ),
});

/**
 * MiniMaxTextToImageOutput
 */
export const zMinimaxImage01Output = z.object({
  images: z.array(zFile).register(z.globalRegistry, {
    description: "Generated images",
  }),
});

/**
 * MiniMaxTextToImageRequest
 */
export const zMinimaxImage01Input = z.object({
  prompt: z.string().min(1).max(1500).register(z.globalRegistry, {
    description: "Text prompt for image generation (max 1500 characters)",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(9).register(z.globalRegistry, {
        description: "Number of images to generate (1-9)",
      }),
    )
    .default(1),
  prompt_optimizer: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enable automatic prompt optimization",
      }),
    )
    .default(false),
  aspect_ratio: z.optional(
    z
      .enum(["1:1", "16:9", "4:3", "3:2", "2:3", "3:4", "9:16", "21:9"])
      .register(z.globalRegistry, {
        description: "Aspect ratio of the generated image",
      }),
  ),
});

/**
 * Output
 */
export const zFluxLoraStreamOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageInput
 */
export const zFluxLoraStreamInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "The number of images to generate. This is always set to 1 for streaming output.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * DreamOOutput
 */
export const zDreamoOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used to generate the image.",
  }),
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The URLs of the generated images.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * DreamOInput
 */
export const zDreamoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  first_image_url: z.optional(z.union([z.string(), z.string()])),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  second_image_url: z.optional(z.union([z.string(), z.string()])),
  second_reference_task: z.optional(
    z.enum(["ip", "id", "style"]).register(z.globalRegistry, {
      description: "Task for second reference image (ip/id/style).",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  first_reference_task: z.optional(
    z.enum(["ip", "id", "style"]).register(z.globalRegistry, {
      description: "Task for first reference image (ip/id/style).",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The prompt to generate an image from.",
      }),
    )
    .default(""),
  ref_resolution: z
    .optional(
      z.int().gte(512).lte(1024).register(z.globalRegistry, {
        description: "Resolution for reference images.",
      }),
    )
    .default(512),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  true_cfg: z
    .optional(
      z.number().gte(1).lte(5).register(z.globalRegistry, {
        description: "The weight of the CFG loss.",
      }),
    )
    .default(1),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(12),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * Imagen4TextToImageUltraOutput
 */
export const zImagen4PreviewUltraOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images.",
  }),
  description: z.string().register(z.globalRegistry, {
    description: "The description of the generated images.",
  }),
});

/**
 * Imagen4TextToImageUltraInput
 */
export const zImagen4PreviewUltraInput = z.object({
  prompt: z.string().min(3).max(5000).register(z.globalRegistry, {
    description: "The text prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z.enum(["1:1", "16:9", "9:16", "4:3", "3:4"]).register(z.globalRegistry, {
      description: "The aspect ratio of the generated image.",
    }),
  ),
  resolution: z.optional(
    z.enum(["1K", "2K"]).register(z.globalRegistry, {
      description: "The resolution of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
});

/**
 * ImageOutput
 */
export const zBagelOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated images.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * ImageGenInput
 */
export const zBagelInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The seed to use for the generation.",
    }),
  ),
  use_thought: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to use thought tokens for generation. If set to true, the model will "think" to potentially improve generation quality. Increases generation time and increases the cost by 20%.',
      }),
    )
    .default(false),
});

/**
 * Output
 */
export const zFluxProKontextTextToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z
    .array(zRegistryImageFastSdxlModelsImage)
    .register(z.globalRegistry, {
      description: "The generated image files info.",
    }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * FluxProTextToImageInputWithAR
 */
export const zFluxProKontextTextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z
      .enum(["21:9", "16:9", "4:3", "3:2", "1:1", "2:3", "3:4", "9:16", "9:21"])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enhance the prompt for better results.",
      }),
    )
    .default(false),
});

/**
 * Output
 */
export const zFluxProKontextMaxTextToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z
    .array(zRegistryImageFastSdxlModelsImage)
    .register(z.globalRegistry, {
      description: "The generated image files info.",
    }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * FluxProTextToImageInputWithAR
 */
export const zFluxProKontextMaxTextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z
      .enum(["21:9", "16:9", "4:3", "3:2", "1:1", "2:3", "3:4", "9:16", "9:21"])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enhance the prompt for better results.",
      }),
    )
    .default(false),
});

/**
 * Output
 */
export const zFlux1DevOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseFlux1Input
 */
export const zFlux1DevInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ",
      }),
    )
    .default(3.5),
});

/**
 * Output
 */
export const zFlux1SchnellOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * SchnellFlux1TextToImageInput
 */
export const zFlux1SchnellInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(12).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(4),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ",
      }),
    )
    .default(3.5),
});

/**
 * SeedDreamOutput
 */
export const zBytedanceSeedreamV3TextToImageOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "Generated images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for generation",
  }),
});

/**
 * SeedDreamInput
 */
export const zBytedanceSeedreamV3TextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The text prompt used to generate the image",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "Number of images to generate",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "Controls how closely the output image aligns with the input prompt. Higher values mean stronger prompt correlation.",
      }),
    )
    .default(2.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed to control the stochasticity of image generation.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zOmnigenV2Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageInput
 */
export const zOmnigenV2Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to generate or edit an image. Use specific language like 'Add the bird from image 1 to the desk in image 2' for better results.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  scheduler: z.optional(
    z.enum(["euler", "dpmsolver"]).register(z.globalRegistry, {
      description: "The scheduler to use for the diffusion process.",
    }),
  ),
  cfg_range_end: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "CFG range end value.",
      }),
    )
    .default(1),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Negative prompt to guide what should not be in the image.",
      }),
    )
    .default(
      "(((deformed))), blurry, over saturation, bad anatomy, disfigured, poorly drawn face, mutation, mutated, (extra_limb), (ugly), (poorly drawn hands), fused fingers, messy drawing, broken legs censor, censored, censor_bar",
    ),
  text_guidance_scale: z
    .optional(
      z.number().gte(1).lte(8).register(z.globalRegistry, {
        description:
          "\n            The Text Guidance scale controls how closely the model follows the text prompt.\n            Higher values make the model stick more closely to the prompt.\n        ",
      }),
    )
    .default(5),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_guidance_scale: z
    .optional(
      z.number().gte(1).lte(3).register(z.globalRegistry, {
        description:
          "\n            The Image Guidance scale controls how closely the model follows the input images.\n            For image editing: 1.3-2.0, for in-context generation: 2.0-3.0\n        ",
      }),
    )
    .default(2),
  input_image_urls: z
    .optional(
      z.array(z.string()).register(z.globalRegistry, {
        description:
          "URLs of input images to use for image editing or multi-image generation. Support up to 3 images.",
      }),
    )
    .default([]),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  cfg_range_start: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "CFG range start value.",
      }),
    )
    .default(0),
  num_inference_steps: z
    .optional(
      z.int().gte(20).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(50),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * KontextT2IOutput
 */
export const zFluxKontextLoraTextToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseKontextInput
 */
export const zFluxKontextLoraTextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate the image with",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(2.5),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(30),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * SkyRaccoonResponse
 */
export const zSkyRaccoonOutput = z.object({
  image: zFile,
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation.",
  }),
});

/**
 * SkyRaccoonRequest
 */
export const zSkyRaccoonInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The text prompt to guide video generation.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  turbo_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If true, the video will be generated faster with no noticeable degradation in the visual quality.",
      }),
    )
    .default(false),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enable prompt expansion.",
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed for reproducibility. If None, a random seed is chosen.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Negative prompt for video generation.",
      }),
    )
    .default(
      "bright colors, overexposed, static, blurred details, subtitles, style, artwork, painting, picture, still, overall gray, worst quality, low quality, JPEG compression residue, ugly, incomplete, extra fingers, poorly drawn hands, poorly drawn faces, deformed, disfigured, malformed limbs, fused fingers, still picture, cluttered background, three legs, many people in the background, walking backwards",
    ),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(40).register(z.globalRegistry, {
        description:
          "Number of inference steps for sampling. Higher values give better quality but take longer.",
      }),
    )
    .default(30),
});

/**
 * KreaOutput
 */
export const zFlux1KreaOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated images.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseKreaFlux1Input
 */
export const zFlux1KreaInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ",
      }),
    )
    .default(4.5),
});

/**
 * KreaOutput
 */
export const zFluxKreaOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated images.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseKreaInput
 */
export const zFluxKreaInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ",
      }),
    )
    .default(4.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
});

/**
 * Output
 */
export const zFluxKreaLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * TextToImageInput
 */
export const zFluxKreaLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "The number of images to generate. This is always set to 1 for streaming output.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * Output
 */
export const zFluxKreaLoraStreamOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * TextToImageInput
 */
export const zFluxKreaLoraStreamInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "The number of images to generate. This is always set to 1 for streaming output.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * QwenImageOutput
 */
export const zQwenImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * BaseQwenImageInput
 */
export const zQwenImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate the image with",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "Acceleration level for image generation. Options: 'none', 'regular', 'high'. Higher acceleration increases speed. 'regular' balances speed and quality. 'high' is recommended for images without text.",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(250).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(30),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use up to 3 LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  use_turbo: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Enable turbo mode for faster generation with high quality. When enabled, uses optimized settings (10 steps, CFG=1.2).",
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The negative prompt for the generation",
      }),
    )
    .default(" "),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(2.5),
});

/**
 * WanT2IResponse
 */
export const zWanV22A14bTextToImageOutput = z.object({
  image: zFile,
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation.",
  }),
});

/**
 * WanT2IRequest
 */
export const zWanV22A14bTextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The text prompt to guide image generation.",
  }),
  shift: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: "Shift value for the image. Must be between 1.0 and 10.0.",
      }),
    )
    .default(2),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular"]).register(z.globalRegistry, {
      description:
        "Acceleration level to use. The more acceleration, the faster the generation, but with lower quality. The recommended value is 'regular'.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "Classifier-free guidance scale. Higher values give better adherence to the prompt but may decrease quality.",
      }),
    )
    .default(3.5),
  enable_output_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, output video will be checked for safety after generation.",
      }),
    )
    .default(false),
  guidance_scale_2: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "Guidance scale for the second stage of the model. This is used to control the adherence to the prompt in the second stage of the model.",
      }),
    )
    .default(4),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, input data will be checked for safety before processing.",
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(40).register(z.globalRegistry, {
        description:
          "Number of inference steps for sampling. Higher values give better quality but take longer.",
      }),
    )
    .default(27),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed for reproducibility. If None, a random seed is chosen.",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Negative prompt for video generation.",
      }),
    )
    .default(""),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.",
      }),
    )
    .default(false),
});

/**
 * WanSmallT2IResponse
 */
export const zWanV225bTextToImageOutput = z.object({
  image: zFile,
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation.",
  }),
});

/**
 * WanSmallT2IRequest
 */
export const zWanV225bTextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The text prompt to guide image generation.",
  }),
  shift: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: "Shift value for the image. Must be between 1.0 and 10.0.",
      }),
    )
    .default(2),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Negative prompt for video generation.",
      }),
    )
    .default(""),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "Classifier-free guidance scale. Higher values give better adherence to the prompt but may decrease quality.",
      }),
    )
    .default(3.5),
  enable_output_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, output video will be checked for safety after generation.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, input data will be checked for safety before processing.",
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description:
          "Number of inference steps for sampling. Higher values give better quality but take longer.",
      }),
    )
    .default(40),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed for reproducibility. If None, a random seed is chosen.",
    }),
  ),
  image_format: z.optional(
    z.enum(["png", "jpeg"]).register(z.globalRegistry, {
      description: "The format of the output image.",
    }),
  ),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.",
      }),
    )
    .default(false),
});

/**
 * LoRAWeight
 */
export const zLoRaWeight = z.object({
  path: z.string().register(z.globalRegistry, {
    description: "URL or the path to the LoRA weights.",
  }),
  scale: z
    .optional(
      z.number().gte(0).lte(4).register(z.globalRegistry, {
        description:
          "\n            The scale of the LoRA weight. This is used to scale the LoRA weight\n            before merging it with the base model.\n        ",
      }),
    )
    .default(1),
  transformer: z.optional(
    z.enum(["high", "low", "both"]).register(z.globalRegistry, {
      description:
        "Specifies the transformer to load the lora weight into. 'high' loads into the high-noise transformer, 'low' loads it into the low-noise transformer, while 'both' loads the LoRA into both transformers.",
    }),
  ),
  weight_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "Name of the LoRA weight. Used only if `path` is a Hugging Face repository, and required only if you have more than 1 safetensors file in the repo.",
    }),
  ),
});

/**
 * WanT2IResponse
 */
export const zWanV22A14bTextToImageLoraOutput = z.object({
  image: zFile,
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation.",
  }),
});

/**
 * WanLoRAT2IRequest
 */
export const zWanV22A14bTextToImageLoraInput = z.object({
  shift: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: "Shift value for the image. Must be between 1.0 and 10.0.",
      }),
    )
    .default(2),
  prompt: z.string().register(z.globalRegistry, {
    description: "The text prompt to guide image generation.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular"]).register(z.globalRegistry, {
      description:
        "Acceleration level to use. The more acceleration, the faster the generation, but with lower quality. The recommended value is 'regular'.",
    }),
  ),
  reverse_video: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If true, the video will be reversed.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoRaWeight).register(z.globalRegistry, {
        description: "LoRA weights to be used in the inference.",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "Classifier-free guidance scale. Higher values give better adherence to the prompt but may decrease quality.",
      }),
    )
    .default(3.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, input data will be checked for safety before processing.",
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Negative prompt for video generation.",
      }),
    )
    .default(""),
  image_format: z.optional(
    z.enum(["png", "jpeg"]).register(z.globalRegistry, {
      description: "The format of the output image.",
    }),
  ),
  enable_output_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, output video will be checked for safety after generation.",
      }),
    )
    .default(false),
  guidance_scale_2: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "Guidance scale for the second stage of the model. This is used to control the adherence to the prompt in the second stage of the model.",
      }),
    )
    .default(4),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.",
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(40).register(z.globalRegistry, {
        description:
          "Number of inference steps for sampling. Higher values give better quality but take longer.",
      }),
    )
    .default(27),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed for reproducibility. If None, a random seed is chosen.",
    }),
  ),
});

/**
 * DreaminaOutput
 */
export const zBytedanceDreaminaV31TextToImageOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "Generated images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for generation",
  }),
});

/**
 * DreaminaInput
 */
export const zBytedanceDreaminaV31TextToImageInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "Number of images to generate",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  prompt: z.string().register(z.globalRegistry, {
    description: "The text prompt used to generate the image",
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed to control the stochasticity of image generation.",
    }),
  ),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use an LLM to enhance the prompt",
      }),
    )
    .default(false),
});

/**
 * NanoBananaTextToImageOutput
 */
export const zNanoBananaOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images.",
  }),
  description: z.string().register(z.globalRegistry, {
    description: "The description of the generated images.",
  }),
});

/**
 * NanoBananaTextToImageInput
 */
export const zNanoBananaInput = z.object({
  prompt: z.string().min(3).max(50000).register(z.globalRegistry, {
    description: "The text prompt to generate an image from.",
  }),
  aspect_ratio: z.optional(
    z
      .enum([
        "21:9",
        "16:9",
        "3:2",
        "4:3",
        "5:4",
        "1:1",
        "4:5",
        "3:4",
        "2:3",
        "9:16",
      ])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  limit_generations: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.",
      }),
    )
    .default(false),
});

/**
 * NanoBananaTextToImageOutput
 */
export const zGemini25FlashImageOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images.",
  }),
  description: z.string().register(z.globalRegistry, {
    description: "The description of the generated images.",
  }),
});

/**
 * NanoBananaTextToImageInput
 */
export const zGemini25FlashImageInput = z.object({
  prompt: z.string().min(3).max(50000).register(z.globalRegistry, {
    description: "The text prompt to generate an image from.",
  }),
  aspect_ratio: z.optional(
    z
      .enum([
        "21:9",
        "16:9",
        "3:2",
        "4:3",
        "5:4",
        "1:1",
        "4:5",
        "3:4",
        "2:3",
        "9:16",
      ])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  limit_generations: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.",
      }),
    )
    .default(false),
});

/**
 * SeedDream4T2IOutput
 */
export const zBytedanceSeedreamV4TextToImageOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "Generated images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for generation",
  }),
});

/**
 * SeedDream4T2IInput
 */
export const zBytedanceSeedreamV4TextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The text prompt used to generate the image",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(6).register(z.globalRegistry, {
        description:
          "Number of separate model generations to be run with the prompt.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
        "auto",
        "auto_2K",
        "auto_4K",
      ]),
    ]),
  ),
  enhance_prompt_mode: z.optional(
    z.enum(["standard", "fast"]).register(z.globalRegistry, {
      description:
        "The mode to use for enhancing prompt enhancement. Standard mode provides higher quality results but takes longer to generate. Fast mode provides average quality results but takes less time to generate.",
    }),
  ),
  max_images: z
    .optional(
      z.int().gte(1).lte(6).register(z.globalRegistry, {
        description:
          "If set to a number greater than one, enables multi-image generation. The model will potentially return up to `max_images` images every generation, and in total, `num_images` generations will be carried out. In total, the number of images generated will be between `num_images` and `max_images*num_images`.",
      }),
    )
    .default(1),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed to control the stochasticity of image generation.",
    }),
  ),
});

/**
 * HunyuanTextToImageOutput
 */
export const zHunyuanImageV21TextToImageOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "A list of the generated images.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The base seed used for the generation process.",
  }),
});

/**
 * HunyuanTextToImageInput
 */
export const zHunyuanImageV21TextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The text prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  use_reprompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Enable prompt enhancement for potentially better results.",
      }),
    )
    .default(true),
  use_refiner: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Enable the refiner model for improved image quality.",
      }),
    )
    .default(false),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "Controls how much the model adheres to the prompt. Higher values mean stricter adherence.",
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed for reproducible results. If None, a random seed is used.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The negative prompt to guide the image generation away from certain concepts.",
      }),
    )
    .default(""),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of denoising steps.",
      }),
    )
    .default(28),
});

/**
 * SRPOOutput
 */
export const zFlux1SrpoOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated images.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseSRPOFlux1Input
 */
export const zFlux1SrpoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ",
      }),
    )
    .default(4.5),
});

/**
 * SRPOOutput
 */
export const zFluxSrpoOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated images.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseSRPOInput
 */
export const zFluxSrpoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ",
      }),
    )
    .default(4.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
});

/**
 * TextToImageOutput
 *
 * Output for text-to-image generation
 */
export const zWan25PreviewTextToImageOutput = z
  .object({
    seeds: z.array(z.int()).register(z.globalRegistry, {
      description: "The seeds used for each generated image",
    }),
    images: z.array(zImageFile).register(z.globalRegistry, {
      description: "The generated images",
    }),
    actual_prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description: "The actual prompt used if prompt rewriting was enabled",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "Output for text-to-image generation",
  });

/**
 * TextToImageInput
 *
 * Input for text-to-image generation
 */
export const zWan25PreviewTextToImageInput = z
  .object({
    prompt: z.string().min(1).register(z.globalRegistry, {
      description:
        "The prompt for image generation. Supports Chinese and English, max 2000 characters.",
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate. Values from 1 to 4.",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
      ]),
    ),
    enable_prompt_expansion: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable prompt rewriting using LLM. Improves results for short prompts but increases processing time.",
        }),
      )
      .default(true),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          "Random seed for reproducibility. If None, a random seed is chosen.",
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "If set to true, the safety checker will be enabled.",
        }),
      )
      .default(true),
    negative_prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          "Negative prompt to describe content to avoid. Max 500 characters.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "Input for text-to-image generation",
  });

/**
 * HunyuanTextToImageV3Output
 */
export const zHunyuanImageV3TextToImageOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "A list of the generated images.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The base seed used for the generation process.",
  }),
});

/**
 * HunyuanTextToImageInputV3
 */
export const zHunyuanImageV3TextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The text prompt for image-to-image.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.",
      }),
    )
    .default(false),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "Controls how much the model adheres to the prompt. Higher values mean stricter adherence.",
      }),
    )
    .default(7.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed for reproducible results. If None, a random seed is used.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The negative prompt to guide the image generation away from certain concepts.",
      }),
    )
    .default(""),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of denoising steps.",
      }),
    )
    .default(28),
});

/**
 * ReveCreateOutput
 *
 * Output for Reve text-to-image generation
 */
export const zReveTextToImageOutput = z
  .object({
    images: z.array(zImage).register(z.globalRegistry, {
      description: "The generated images",
    }),
  })
  .register(z.globalRegistry, {
    description: "Output for Reve text-to-image generation",
  });

/**
 * ReveCreateInput
 *
 * Input for Reve text-to-image generation
 */
export const zReveTextToImageInput = z
  .object({
    prompt: z.string().min(1).max(2560).register(z.globalRegistry, {
      description: "The text description of the desired image.",
    }),
    aspect_ratio: z.optional(
      z
        .enum(["16:9", "9:16", "3:2", "2:3", "4:3", "3:4", "1:1"])
        .register(z.globalRegistry, {
          description: "The desired aspect ratio of the generated image.",
        }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
        }),
      )
      .default(false),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "Output format for the generated image.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "Input for Reve text-to-image generation",
  });

/**
 * ImageResponseMini
 */
export const zGptImage1MiniOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images.",
  }),
});

/**
 * TextToImageRequestMini
 */
export const zGptImage1MiniInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt for image generation",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "Number of images to generate",
      }),
    )
    .default(1),
  image_size: z.optional(
    z
      .enum(["auto", "1024x1024", "1536x1024", "1024x1536"])
      .register(z.globalRegistry, {
        description: "Aspect ratio for the generated image",
      }),
  ),
  background: z.optional(
    z.enum(["auto", "transparent", "opaque"]).register(z.globalRegistry, {
      description: "Background for the generated image",
    }),
  ),
  quality: z.optional(
    z.enum(["auto", "low", "medium", "high"]).register(z.globalRegistry, {
      description: "Quality for the generated image",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "Output format for the images",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
});

/**
 * PiQwenOutput
 */
export const zPiflowOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The URLs of the generated images.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation.",
  }),
});

/**
 * PiQwenInput
 */
export const zPiflowInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(8),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed for reproducible generation. If set to None, a random seed will be used.",
    }),
  ),
});

/**
 * GaiaOutputModel
 */
export const zFiboGenerateOutput = z.object({
  images: z
    .optional(
      z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: "Generated images.",
      }),
    )
    .default([]),
  image: zImageType3,
  structured_prompt: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: "Current prompt.",
    }),
});

/**
 * Lighting
 */
export const zLighting = z.object({
  shadows: z.optional(z.union([z.string(), z.unknown()])),
  conditions: z.optional(z.union([z.string(), z.unknown()])),
  direction: z.optional(z.union([z.string(), z.unknown()])),
});

/**
 * Aesthetics
 */
export const zAesthetics = z.object({
  composition: z.optional(z.union([z.string(), z.unknown()])),
  mood_atmosphere: z.optional(z.union([z.string(), z.unknown()])),
  color_scheme: z.optional(z.union([z.string(), z.unknown()])),
});

/**
 * PhotographicCharacteristics
 */
export const zPhotographicCharacteristics = z.object({
  focus: z.optional(z.union([z.string(), z.unknown()])),
  lens_focal_length: z.optional(z.union([z.string(), z.unknown()])),
  camera_angle: z.optional(z.union([z.string(), z.unknown()])),
  depth_of_field: z.optional(z.union([z.string(), z.unknown()])),
});

/**
 * PromptObject
 */
export const zPromptObject = z.object({
  relative_size: z.optional(z.union([z.string(), z.unknown()])),
  description: z.optional(z.union([z.string(), z.unknown()])),
  skin_tone_and_texture: z.optional(z.union([z.string(), z.unknown()])),
  appearance_details: z.optional(z.union([z.string(), z.unknown()])),
  number_of_objects: z.optional(z.union([z.int(), z.unknown()])),
  expression: z.optional(z.union([z.string(), z.unknown()])),
  pose: z.optional(z.union([z.string(), z.unknown()])),
  shape_and_color: z.optional(z.union([z.string(), z.unknown()])),
  relationship: z.string().register(z.globalRegistry, {
    description:
      "The relationship of the object to other objects in the image.",
  }),
  texture: z.optional(z.union([z.string(), z.unknown()])),
  gender: z.optional(z.union([z.string(), z.unknown()])),
  clothing: z.optional(z.union([z.string(), z.unknown()])),
  location: z.optional(z.union([z.string(), z.unknown()])),
  orientation: z.optional(z.union([z.string(), z.unknown()])),
  action: z.optional(z.union([z.string(), z.unknown()])),
});

/**
 * StructuredPrompt
 */
export const zStructuredPrompt = z.object({
  background_setting: z.optional(z.union([z.string(), z.unknown()])),
  artistic_style: z.optional(z.union([z.string(), z.unknown()])),
  context: z.optional(z.union([z.string(), z.unknown()])),
  text_render: z.optional(z.union([z.array(z.unknown()), z.unknown()])),
  objects: z.optional(z.union([z.array(zPromptObject), z.unknown()])),
  style_medium: z.optional(z.union([z.string(), z.unknown()])),
  photographic_characteristics: z.optional(
    z.union([zPhotographicCharacteristics, z.unknown()]),
  ),
  aesthetics: z.optional(z.union([zAesthetics, z.unknown()])),
  lighting: z.optional(z.union([zLighting, z.unknown()])),
  short_description: z.optional(z.union([z.string(), z.unknown()])),
});

/**
 * GaiaInputModel
 */
export const zFiboGenerateInput = z.object({
  prompt: z.optional(z.union([z.string(), z.unknown()])),
  aspect_ratio: z.optional(
    z
      .enum(["1:1", "2:3", "3:2", "3:4", "4:3", "4:5", "5:4", "9:16", "16:9"])
      .register(z.globalRegistry, {
        description:
          "Aspect ratio. Options: 1:1, 2:3, 3:2, 3:4, 4:3, 4:5, 5:4, 9:16, 16:9",
      }),
  ),
  steps_num: z
    .optional(
      z.int().gte(20).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps.",
      }),
    )
    .default(50),
  image_url: z.optional(z.union([z.string(), z.unknown()])),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If true, returns the image directly in the response (increases latency).",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.int().gte(3).lte(5).register(z.globalRegistry, {
        description: "Guidance scale for text.",
      }),
    )
    .default(5),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Random seed for reproducibility.",
      }),
    )
    .default(5555),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Negative prompt for image generation.",
      }),
    )
    .default(""),
  structured_prompt: z.optional(z.union([zStructuredPrompt, z.unknown()])),
});

/**
 * Emu35Output
 */
export const zEmu35ImageTextToImageOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The edited image.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed for the inference.",
  }),
});

/**
 * Emu35ImageInput
 */
export const zEmu35ImageTextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to create the image.",
  }),
  resolution: z.optional(
    z.enum(["480p", "720p"]).register(z.globalRegistry, {
      description: "The resolution of the output image.",
    }),
  ),
  aspect_ratio: z.optional(
    z
      .enum(["21:9", "16:9", "4:3", "3:2", "1:1", "2:3", "3:4", "9:16", "9:21"])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the output image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the output image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to return the image in sync mode.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enable the safety checker.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The seed for the inference.",
    }),
  ),
});

/**
 * Image
 *
 * Represents an image file.
 */
export const zImageOutput = z
  .object({
    file_size: z.optional(z.union([z.int(), z.unknown()])),
    height: z.optional(z.union([z.int(), z.unknown()])),
    file_name: z.optional(z.union([z.string(), z.unknown()])),
    content_type: z.optional(z.union([z.string(), z.unknown()])),
    url: z.string().register(z.globalRegistry, {
      description: "The URL where the file can be downloaded from.",
    }),
    width: z.optional(z.union([z.int(), z.unknown()])),
  })
  .register(z.globalRegistry, {
    description: "Represents an image file.",
  });

/**
 * ImagineArt_1_5_Output
 */
export const zImagineart15PreviewTextToImageOutput = z.object({
  images: z.array(zImageOutput).register(z.globalRegistry, {
    description: "Generated image",
  }),
});

/**
 * ImagineArt_1_5_Input
 */
export const zImagineart15PreviewTextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "Text prompt describing the desired image",
  }),
  aspect_ratio: z.optional(
    z
      .enum(["1:1", "16:9", "9:16", "4:3", "3:4", "3:1", "1:3", "3:2", "2:3"])
      .register(z.globalRegistry, {
        description:
          "Image aspect ratio: 1:1, 3:1, 1:3, 16:9, 9:16, 4:3, 3:4, 3:2, 2:3",
      }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Seed for the image generation",
    }),
  ),
});

/**
 * ImageFile
 */
export const zImageFileType2 = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  height: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: "The URL where the file can be downloaded from.",
  }),
  width: z.optional(z.union([z.int(), z.unknown()])),
});

/**
 * NanoBananaTextToImageOutput
 */
export const zNanoBananaProOutput = z.object({
  images: z.array(zImageFileType2).register(z.globalRegistry, {
    description: "The generated images.",
  }),
  description: z.string().register(z.globalRegistry, {
    description: "The description of the generated images.",
  }),
});

/**
 * NanoBananaTextToImageInput
 */
export const zNanoBananaProInput = z.object({
  prompt: z.string().min(3).max(50000).register(z.globalRegistry, {
    description: "The text prompt to generate an image from.",
  }),
  resolution: z.optional(
    z.enum(["1K", "2K", "4K"]).register(z.globalRegistry, {
      description: "The resolution of the image to generate.",
    }),
  ),
  enable_web_search: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Enable web search for the image generation task. This will allow the model to use the latest information from the web to generate the image.",
      }),
    )
    .default(false),
  aspect_ratio: z.optional(
    z
      .enum([
        "21:9",
        "16:9",
        "3:2",
        "4:3",
        "5:4",
        "1:1",
        "4:5",
        "3:4",
        "2:3",
        "9:16",
      ])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  limit_generations: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.",
      }),
    )
    .default(false),
});

/**
 * NanoBananaTextToImageOutput
 */
export const zGemini3ProImagePreviewOutput = z.object({
  images: z.array(zImageFileType2).register(z.globalRegistry, {
    description: "The generated images.",
  }),
  description: z.string().register(z.globalRegistry, {
    description: "The description of the generated images.",
  }),
});

/**
 * NanoBananaTextToImageInput
 */
export const zGemini3ProImagePreviewInput = z.object({
  prompt: z.string().min(3).max(50000).register(z.globalRegistry, {
    description: "The text prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  enable_web_search: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Enable web search for the image generation task. This will allow the model to use the latest information from the web to generate the image.",
      }),
    )
    .default(false),
  resolution: z.optional(
    z.enum(["1K", "2K", "4K"]).register(z.globalRegistry, {
      description: "The resolution of the image to generate.",
    }),
  ),
  aspect_ratio: z.optional(
    z.union([
      z.enum([
        "auto",
        "21:9",
        "16:9",
        "3:2",
        "4:3",
        "5:4",
        "1:1",
        "4:5",
        "3:4",
        "2:3",
        "9:16",
      ]),
      z.unknown(),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  limit_generations: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.",
      }),
    )
    .default(false),
});

/**
 * Flux2FlexOutput
 */
export const zFlux2FlexOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for the generation.",
  }),
});

/**
 * Flux2FlexTextToImageInput
 */
export const zFlux2FlexInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.",
    }),
  ),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to expand the prompt using the model's own knowledge.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enable the safety checker.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The seed to use for the generation.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1.5).lte(10).register(z.globalRegistry, {
        description: "The guidance scale to use for the generation.",
      }),
    )
    .default(3.5),
});

/**
 * BallpointPenSketchOutput
 */
export const zFlux2LoraGalleryBallpointPenSketchOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generation",
  }),
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated ballpoint pen sketch style images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * BallpointPenSketchInput
 *
 * Input model for Ballpoint Pen Sketch endpoint - Generate ballpoint pen sketch style images
 */
export const zFlux2LoraGalleryBallpointPenSketchInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description:
        "The prompt to generate a ballpoint pen sketch style image. Use 'b4llp01nt' trigger word for best results.",
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: "The strength of the ballpoint pen sketch effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(2.5),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(40),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Ballpoint Pen Sketch endpoint - Generate ballpoint pen sketch style images",
  });

/**
 * DigitalComicArtOutput
 */
export const zFlux2LoraGalleryDigitalComicArtOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generation",
  }),
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated digital comic art style images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * DigitalComicArtInput
 *
 * Input model for Digital Comic Art endpoint - Generate digital comic art style images
 */
export const zFlux2LoraGalleryDigitalComicArtInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description:
        "The prompt to generate a digital comic art style image. Use 'd1g1t4l' trigger word for best results.",
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: "The strength of the digital comic art effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(2.5),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(40),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Digital Comic Art endpoint - Generate digital comic art style images",
  });

/**
 * HdrStyleOutput
 */
export const zFlux2LoraGalleryHdrStyleOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generation",
  }),
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated HDR style images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * HdrStyleInput
 *
 * Input model for HDR Style endpoint - Generate HDR style images with vibrant colors
 */
export const zFlux2LoraGalleryHdrStyleInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description:
        "The prompt to generate an HDR style image. The trigger word 'Hyp3rRe4list1c' will be automatically prepended.",
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: "The strength of the HDR style effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(2.5),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(40),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for HDR Style endpoint - Generate HDR style images with vibrant colors",
  });

/**
 * RealismOutput
 */
export const zFlux2LoraGalleryRealismOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generation",
  }),
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated realistic style images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * RealismInput
 *
 * Input model for Realism endpoint - Generate realistic style images
 */
export const zFlux2LoraGalleryRealismInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description:
        "The prompt to generate a realistic image with natural lighting and authentic details.",
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: "The strength of the realism effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(2.5),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(40),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Realism endpoint - Generate realistic style images",
  });

/**
 * SatelliteViewStyleOutput
 */
export const zFlux2LoraGallerySatelliteViewStyleOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generation",
  }),
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated satellite view style images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * SatelliteViewStyleInput
 *
 * Input model for Satellite View Style endpoint - Generate satellite/aerial view style images
 */
export const zFlux2LoraGallerySatelliteViewStyleInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description:
        "The prompt to generate a satellite/aerial view style image.",
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: "The strength of the satellite view style effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(2.5),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(40),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Satellite View Style endpoint - Generate satellite/aerial view style images",
  });

/**
 * SepiaVintageOutput
 */
export const zFlux2LoraGallerySepiaVintageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generation",
  }),
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated sepia vintage photography style images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * SepiaVintageInput
 *
 * Input model for Sepia Vintage Photography endpoint - Generate vintage sepia style images
 */
export const zFlux2LoraGallerySepiaVintageInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description:
        "The prompt to generate a sepia vintage photography style image.",
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: "The strength of the sepia vintage photography effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(2.5),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(40),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Sepia Vintage Photography endpoint - Generate vintage sepia style images",
  });

/**
 * ZImageTurboOutput
 */
export const zZImageTurboOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: "The timings of the generation process.",
  }),
});

/**
 * ZImageTurboTextToImageInput
 */
export const zZImageTurboInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.",
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(8),
});

/**
 * OvisImageOutput
 */
export const zOvisImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * TextToImageInput
 */
export const zOvisImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use.",
    }),
  ),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description: "The guidance scale to use for the image generation.",
      }),
    )
    .default(5),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The negative prompt to generate an image from.",
      }),
    )
    .default(""),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
});

/**
 * ZImageTurboOutput
 */
export const zZImageTurboLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: "The timings of the generation process.",
  }),
});

/**
 * LoRAInput
 *
 * LoRA weight configuration.
 */
export const zLoRaInput = z
  .object({
    path: z.string().register(z.globalRegistry, {
      description:
        "URL, HuggingFace repo ID (owner/repo), or local path to LoRA weights.",
    }),
    scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description: "Scale factor for LoRA application (0.0 to 4.0).",
        }),
      )
      .default(1),
  })
  .register(z.globalRegistry, {
    description: "LoRA weight configuration.",
  });

/**
 * ZImageTurboTextToImageLoRAInput
 */
export const zZImageTurboLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoRaInput).register(z.globalRegistry, {
        description: "List of LoRA weights to apply (maximum 3).",
      }),
    )
    .default([]),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.",
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(8),
});

/**
 * TextToImageOutput
 */
export const zViduQ2TextToImageOutput = z.object({
  image: zImage,
});

/**
 * TextToImageRequest
 */
export const zViduQ2TextToImageInput = z.object({
  prompt: z.string().max(1500).register(z.globalRegistry, {
    description: "Text prompt for video generation, max 1500 characters",
  }),
  aspect_ratio: z.optional(
    z.enum(["16:9", "9:16", "1:1"]).register(z.globalRegistry, {
      description: "The aspect ratio of the output video",
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Random seed for generation",
    }),
  ),
});

/**
 * SeedDream45T2IOutput
 */
export const zBytedanceSeedreamV45TextToImageOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "Generated images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for generation",
  }),
});

/**
 * SeedDream45T2IInput
 */
export const zBytedanceSeedreamV45TextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The text prompt used to generate the image",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(6).register(z.globalRegistry, {
        description:
          "Number of separate model generations to be run with the prompt.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
        "auto_2K",
        "auto_4K",
      ]),
    ]),
  ),
  max_images: z
    .optional(
      z.int().gte(1).lte(6).register(z.globalRegistry, {
        description:
          "If set to a number greater than one, enables multi-image generation. The model will potentially return up to `max_images` images every generation, and in total, `num_images` generations will be carried out. In total, the number of images generated will be between `num_images` and `max_images*num_images`.",
      }),
    )
    .default(1),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed to control the stochasticity of image generation.",
    }),
  ),
});

/**
 * TextToImageOutput
 */
export const zLongcatImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageInput
 */
export const zLongcatImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use.",
    }),
  ),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description: "The guidance scale to use for the image generation.",
      }),
    )
    .default(4.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * Flux2MaxOutput
 */
export const zFlux2MaxOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for the generation.",
  }),
});

/**
 * Flux2MaxTextToImageInput
 */
export const zFlux2MaxInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enable the safety checker.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The seed to use for the generation.",
    }),
  ),
});

/**
 * Flux2TurboT2IOutput
 */
export const zFlux2TurboOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * Flux2TurboTextToImageInput
 */
export const zFlux2TurboInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(2.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The seed to use for the generation. If not provided, a random seed will be used.",
    }),
  ),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded for better results.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * GaiaOutputModel
 */
export const zFiboLiteGenerateOutput = z.object({
  images: z
    .optional(
      z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: "Generated images.",
      }),
    )
    .default([]),
  image: zImageType3,
  structured_prompt: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: "Current prompt.",
    }),
});

/**
 * GaiaLiteInputModel
 */
export const zFiboLiteGenerateInput = z.object({
  prompt: z.optional(z.union([z.string(), z.unknown()])),
  steps_num: z
    .optional(
      z.int().gte(4).lte(30).register(z.globalRegistry, {
        description: "Number of inference steps for Fibo Lite.",
      }),
    )
    .default(8),
  aspect_ratio: z.optional(
    z
      .enum(["1:1", "2:3", "3:2", "3:4", "4:3", "4:5", "5:4", "9:16", "16:9"])
      .register(z.globalRegistry, {
        description:
          "Aspect ratio. Options: 1:1, 2:3, 3:2, 3:4, 4:3, 4:5, 5:4, 9:16, 16:9",
      }),
  ),
  image_url: z.optional(z.union([z.string(), z.unknown()])),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If true, returns the image directly in the response (increases latency).",
      }),
    )
    .default(false),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Random seed for reproducibility.",
      }),
    )
    .default(5555),
  structured_prompt: z.optional(z.union([zStructuredPrompt, z.unknown()])),
});

/**
 * ImageResponse
 */
export const zGptImage15Output = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images.",
  }),
});

/**
 * TextToImageRequest
 */
export const zGptImage15Input = z.object({
  prompt: z.string().min(2).register(z.globalRegistry, {
    description: "The prompt for image generation",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "Number of images to generate",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.enum(["1024x1024", "1536x1024", "1024x1536"]).register(z.globalRegistry, {
      description: "Aspect ratio for the generated image",
    }),
  ),
  background: z.optional(
    z.enum(["auto", "transparent", "opaque"]).register(z.globalRegistry, {
      description: "Background for the generated image",
    }),
  ),
  quality: z.optional(
    z.enum(["low", "medium", "high"]).register(z.globalRegistry, {
      description: "Quality for the generated image",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "Output format for the images",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
});

/**
 * Flux2FlashT2IOutput
 */
export const zFlux2FlashOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * Flux2FlashTextToImageInput
 */
export const zFlux2FlashInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(2.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The seed to use for the generation. If not provided, a random seed will be used.",
    }),
  ),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded for better results.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * TextToImageWanOutput
 *
 * Output for Wan 2.6 text-to-image (can include generated text in mixed mode)
 */
export const zV26TextToImageOutput = z
  .object({
    images: z.array(zFile).register(z.globalRegistry, {
      description: "Generated images in PNG format",
    }),
    seed: z.int().register(z.globalRegistry, {
      description: "The seed used for generation",
    }),
    generated_text: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          "Generated text content (in mixed text-and-image mode). May be None if only images were generated.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description:
      "Output for Wan 2.6 text-to-image (can include generated text in mixed mode)",
  });

/**
 * TextToImageWanInput
 *
 * Input for Wan 2.6 text-to-image or mixed text-and-image generation (enable_interleave=true)
 */
export const zV26TextToImageInput = z
  .object({
    prompt: z.string().min(1).register(z.globalRegistry, {
      description:
        "Text prompt describing the desired image. Supports Chinese and English. Max 2000 characters.",
    }),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
      ]),
    ),
    max_images: z
      .optional(
        z.int().gte(1).lte(5).register(z.globalRegistry, {
          description:
            "Maximum number of images to generate (1-5). Actual count may be less depending on model inference.",
        }),
      )
      .default(1),
    image_url: z.optional(z.union([z.string(), z.string()])),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Enable content moderation for input and output.",
        }),
      )
      .default(true),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: "Random seed for reproducibility (0-2147483647).",
      }),
    ),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Content to avoid in the generated image. Max 500 characters.",
        }),
      )
      .default(""),
  })
  .register(z.globalRegistry, {
    description:
      "Input for Wan 2.6 text-to-image or mixed text-and-image generation (enable_interleave=true)",
  });

/**
 * QwenImage2512Output
 */
export const zQwenImage2512Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageInput
 */
export const zQwenImage2512Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use.",
    }),
  ),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "The guidance scale to use for the image generation.",
      }),
    )
    .default(4),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The negative prompt to generate an image from.",
      }),
    )
    .default(""),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
});

/**
 * QwenImage2512Output
 */
export const zQwenImage2512LoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * LoraInput
 */
export const zQwenImage2512LoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use.",
    }),
  ),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use up to 3 LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "The guidance scale to use for the image generation.",
      }),
    )
    .default(4),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The negative prompt to generate an image from.",
      }),
    )
    .default(""),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
});

/**
 * GlmImageOutput
 */
export const zGlmImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "List of URLs to the generated images.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * GlmImageInput
 */
export const zGlmImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "Text prompt for image generation.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "Number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
        "portrait_3_2",
        "landscape_3_2",
        "portrait_hd",
        "landscape_hd",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "Output image format.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If True, the image will be returned as a base64 data URI instead of a URL.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "Classifier-free guidance scale. Higher values make the model follow the prompt more closely.",
      }),
    )
    .default(1.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed for reproducibility. The same seed with the same prompt will produce the same image.",
    }),
  ),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If True, the prompt will be enhanced using an LLM for more detailed and higher quality results.",
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(100).register(z.globalRegistry, {
        description:
          "Number of diffusion denoising steps. More steps generally produce higher quality images.",
      }),
    )
    .default(30),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Enable NSFW safety checking on the generated images.",
      }),
    )
    .default(true),
});

/**
 * ImagineArt_1_5_Output
 */
export const zImagineart15ProPreviewTextToImageOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "Generated image",
  }),
});

/**
 * ImagineArt_1_5_Input
 */
export const zImagineart15ProPreviewTextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "Text prompt describing the desired image",
  }),
  aspect_ratio: z.optional(
    z
      .enum(["1:1", "16:9", "9:16", "4:3", "3:4", "3:1", "1:3", "3:2", "2:3"])
      .register(z.globalRegistry, {
        description:
          "Image aspect ratio: 1:1, 3:1, 1:3, 16:9, 9:16, 4:3, 3:4, 3:2, 2:3",
      }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Seed for the image generation",
    }),
  ),
});

/**
 * Klein4BDistilledT2IOutput
 */
export const zFlux2Klein4bOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * KleinDistilledInput
 */
export const zFlux2Klein4bInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI. Output is not stored when this is True.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(8).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(4),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The seed to use for the generation. If not provided, a random seed will be used.",
    }),
  ),
});

/**
 * Klein9BDistilledT2IOutput
 */
export const zFlux2Klein9bOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * Klein9BDistilledInput
 */
export const zFlux2Klein9bInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI. Output is not stored when this is True.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(8).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(4),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The seed to use for the generation. If not provided, a random seed will be used.",
    }),
  ),
});

/**
 * Klein4BT2IOutput
 */
export const zFlux2Klein4bBaseOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * Klein4BBaseInput
 */
export const zFlux2Klein4bBaseInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use for image generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI. Output is not stored when this is True.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The seed to use for the generation. If not provided, a random seed will be used.",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Negative prompt for classifier-free guidance. Describes what to avoid in the image.",
      }),
    )
    .default(""),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "Guidance scale for classifier-free guidance.",
      }),
    )
    .default(5),
});

/**
 * Klein9BT2IOutput
 */
export const zFlux2Klein9bBaseOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * Klein9BBaseInput
 */
export const zFlux2Klein9bBaseInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use for image generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI. Output is not stored when this is True.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The seed to use for the generation. If not provided, a random seed will be used.",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Negative prompt for classifier-free guidance. Describes what to avoid in the image.",
      }),
    )
    .default(""),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "Guidance scale for classifier-free guidance.",
      }),
    )
    .default(5),
});

/**
 * KleinT2IOutput
 */
export const zFlux2Klein4bBaseLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * LoRAInput
 */
export const zFalAiFlux2KleinLoRaInput = z.object({
  path: z.string().register(z.globalRegistry, {
    description:
      "URL, HuggingFace repo ID (owner/repo), or local path to LoRA weights.",
  }),
  scale: z
    .optional(
      z.number().gte(0).lte(4).register(z.globalRegistry, {
        description: "Scale factor for LoRA application (0.0 to 4.0).",
      }),
    )
    .default(1),
});

/**
 * KleinBaseLoRAInput
 */
export const zFlux2Klein4bBaseLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use for image generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  loras: z
    .optional(
      z.array(zFalAiFlux2KleinLoRaInput).register(z.globalRegistry, {
        description: "List of LoRA weights to apply (maximum 3).",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI. Output is not stored when this is True.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The seed to use for the generation. If not provided, a random seed will be used.",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Negative prompt for classifier-free guidance. Describes what to avoid in the image.",
      }),
    )
    .default(""),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "Guidance scale for classifier-free guidance.",
      }),
    )
    .default(5),
});

/**
 * KleinT2IOutput
 */
export const zFlux2Klein9bBaseLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * KleinBaseLoRAInput
 */
export const zFlux2Klein9bBaseLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use for image generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  loras: z
    .optional(
      z.array(zFalAiFlux2KleinLoRaInput).register(z.globalRegistry, {
        description: "List of LoRA weights to apply (maximum 3).",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI. Output is not stored when this is True.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The seed to use for the generation. If not provided, a random seed will be used.",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Negative prompt for classifier-free guidance. Describes what to avoid in the image.",
      }),
    )
    .default(""),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "Guidance scale for classifier-free guidance.",
      }),
    )
    .default(5),
});

/**
 * ZImageBaseOutput
 */
export const zZImageBaseOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: "The timings of the generation process.",
  }),
});

/**
 * ZImageBaseTextToImageInput
 */
export const zZImageBaseInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description: "The guidance scale to use for the image generation.",
      }),
    )
    .default(4),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The negative prompt to use for the image generation.",
      }),
    )
    .default(""),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
});

/**
 * ZImageBaseOutput
 */
export const zZImageBaseLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: "The timings of the generation process.",
  }),
});

/**
 * ZImageBaseTextToImageLoRAInput
 */
export const zZImageBaseLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoRaInput).register(z.globalRegistry, {
        description: "List of LoRA weights to apply (maximum 3).",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description: "The guidance scale to use for the image generation.",
      }),
    )
    .default(4),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The negative prompt to use for the image generation.",
      }),
    )
    .default(""),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
});

/**
 * QwenImageMaxTextToImageOutput
 */
export const zQwenImageMaxTextToImageOutput = z.object({
  images: z.array(zFile).register(z.globalRegistry, {
    description: "Generated images.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * QwenImageMaxTextToImageInput
 */
export const zQwenImageMaxTextToImageInput = z.object({
  prompt: z.string().min(1).max(800).register(z.globalRegistry, {
    description:
      "Text prompt describing the desired image. Supports Chinese and English. Max 800 characters.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Enable LLM prompt optimization for better results.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Random seed for reproducibility (0-2147483647).",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Enable content moderation for input and output.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().max(500).register(z.globalRegistry, {
        description:
          "Content to avoid in the generated image. Max 500 characters.",
      }),
    )
    .default(""),
});

/**
 * HunyuanImageTextToImageResponse
 */
export const zHunyuanImageV3InstructTextToImageOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "A list of the generated images.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The base seed used for the generation process.",
  }),
});

/**
 * HunyuanImageRequest
 */
export const zHunyuanImageV3InstructTextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The text prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "auto",
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed for reproducible results. If None, a random seed is used.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "Controls how much the model adheres to the prompt. Higher values mean stricter adherence.",
      }),
    )
    .default(3.5),
});

/**
 * XAIImageOutput
 */
export const zGrokImagineImageOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The URL of the generated image.",
  }),
  revised_prompt: z.string().register(z.globalRegistry, {
    description: "The enhanced prompt that was used to generate the image.",
  }),
});

/**
 * XAIImageInput
 */
export const zGrokImagineImageInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "Number of images to generate.",
      }),
    )
    .default(1),
  prompt: z.string().max(8000).register(z.globalRegistry, {
    description: "Text description of the desired image.",
  }),
  aspect_ratio: z.optional(
    z
      .enum([
        "2:1",
        "20:9",
        "19.5:9",
        "16:9",
        "4:3",
        "3:2",
        "1:1",
        "2:3",
        "3:4",
        "9:16",
        "9:19.5",
        "9:20",
        "1:2",
      ])
      .register(z.globalRegistry, {
        description: "Aspect ratio of the generated image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
});

/**
 * Output
 */
export const zFluxLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageInput
 */
export const zFluxLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "The number of images to generate. This is always set to 1 for streaming output.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zFluxGeneralOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * ControlNet
 */
export const zControlNet = z.object({
  conditioning_scale: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description:
          "\n            The scale of the control net weight. This is used to scale the control net weight\n            before merging it with the base model.\n        ",
      }),
    )
    .default(1),
  path: z.string().register(z.globalRegistry, {
    description: "URL or the path to the control net weights.",
  }),
  mask_threshold: z
    .optional(
      z.number().gte(0.01).lte(0.99).register(z.globalRegistry, {
        description: "Threshold for mask.",
      }),
    )
    .default(0.5),
  end_percentage: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            The percentage of the image to end applying the controlnet in terms of the total timesteps.\n        ",
      }),
    )
    .default(1),
  config_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: "optional URL to the controlnet config.json file.",
    }),
  ),
  mask_image_url: z.optional(z.union([z.string(), z.null()])),
  variant: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The optional variant if a Hugging Face repo key is used.",
    }),
  ),
  control_image_url: z.string().register(z.globalRegistry, {
    description: "URL of the image to be used as the control image.",
  }),
  start_percentage: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            The percentage of the image to start applying the controlnet in terms of the total timesteps.\n        ",
      }),
    )
    .default(0),
});

/**
 * IPAdapter
 */
export const zIpAdapter = z.object({
  path: z.string().register(z.globalRegistry, {
    description: "Hugging Face path to the IP-Adapter",
  }),
  mask_threshold: z
    .optional(
      z.number().gte(0.01).lte(0.99).register(z.globalRegistry, {
        description: "Threshold for mask.",
      }),
    )
    .default(0.5),
  image_encoder_weight_name: z.optional(
    z.string().register(z.globalRegistry, {
      description: "Name of the image encoder.",
    }),
  ),
  image_encoder_subfolder: z.optional(
    z.string().register(z.globalRegistry, {
      description: "Subfolder in which the image encoder weights exist.",
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: "URL of Image for IP-Adapter conditioning. ",
  }),
  mask_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: "URL of the mask for the control image.",
    }),
  ),
  subfolder: z.optional(
    z.string().register(z.globalRegistry, {
      description: "Subfolder in which the ip_adapter weights exist",
    }),
  ),
  scale: z.number().register(z.globalRegistry, {
    description: "Scale for ip adapter.",
  }),
  image_encoder_path: z.string().register(z.globalRegistry, {
    description:
      "Path to the Image Encoder for the IP-Adapter, for example 'openai/clip-vit-large-patch14'",
  }),
  weight_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "Name of the safetensors file containing the ip-adapter weights",
    }),
  ),
});

/**
 * ControlNetUnionInput
 */
export const zControlNetUnionInput = z.object({
  conditioning_scale: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description:
          "\n            The scale of the control net weight. This is used to scale the control net weight\n            before merging it with the base model.\n        ",
      }),
    )
    .default(1),
  mask_threshold: z
    .optional(
      z.number().gte(0.01).lte(0.99).register(z.globalRegistry, {
        description: "Threshold for mask.",
      }),
    )
    .default(0.5),
  end_percentage: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            The percentage of the image to end applying the controlnet in terms of the total timesteps.\n        ",
      }),
    )
    .default(1),
  mask_image_url: z.optional(z.union([z.string(), z.string(), z.null()])),
  control_image_url: z.union([z.string(), z.string()]),
  control_mode: z
    .enum(["canny", "tile", "depth", "blur", "pose", "gray", "low-quality"])
    .register(z.globalRegistry, {
      description:
        "Control Mode for Flux Controlnet Union. Supported values are:\n        - canny: Uses the edges for guided generation.\n        - tile: Uses the tiles for guided generation.\n        - depth: Utilizes a grayscale depth map for guided generation.\n        - blur: Adds a blur to the image.\n        - pose: Uses the pose of the image for guided generation.\n        - gray: Converts the image to grayscale.\n        - low-quality: Converts the image to a low-quality image.",
    }),
  start_percentage: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            The percentage of the image to start applying the controlnet in terms of the total timesteps.\n        ",
      }),
    )
    .default(0),
});

/**
 * ControlNetUnion
 */
export const zControlNetUnion = z.object({
  controls: z.array(zControlNetUnionInput).register(z.globalRegistry, {
    description: "The control images and modes to use for the control net.",
  }),
  path: z.string().register(z.globalRegistry, {
    description: "URL or the path to the control net weights.",
  }),
  variant: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The optional variant if a Hugging Face repo key is used.",
    }),
  ),
  config_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: "optional URL to the controlnet config.json file.",
    }),
  ),
});

/**
 * ImageFillInput
 */
export const zImageFillInput = z.object({
  fill_image_url: z.optional(z.union([z.string(), z.array(z.string())])),
});

/**
 * EasyControlWeight
 */
export const zEasyControlWeight = z.object({
  scale: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description: "Scale for the control method.",
      }),
    )
    .default(1),
  image_control_type: z
    .enum(["subject", "spatial"])
    .register(z.globalRegistry, {
      description:
        "Control type of the image. Must be one of `spatial` or `subject`.",
    }),
  control_method_url: z.string().register(z.globalRegistry, {
    description:
      "URL to safetensor weights of control method to be applied. Can also be one of `canny`, `depth`, `hedsketch`, `inpainting`, `pose`, `seg`, `subject`, `ghibli` ",
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: "URL of an image to use as a control",
  }),
});

/**
 * ControlLoraWeight
 */
export const zControlLoraWeight = z.object({
  path: z.string().register(z.globalRegistry, {
    description: "URL or the path to the LoRA weights.",
  }),
  scale: z.optional(
    z.union([z.record(z.string(), z.unknown()), z.number().gte(-4).lte(4)]),
  ),
  control_image_url: z.string().register(z.globalRegistry, {
    description: "URL of the image to be used as the control image.",
  }),
  preprocess: z.optional(
    z.enum(["canny", "depth", "None"]).register(z.globalRegistry, {
      description: "Type of preprocessing to apply to the input image.",
    }),
  ),
});

/**
 * TextToImageInput
 */
export const zFluxGeneralInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  nag_end: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description:
          "\n            The proportion of steps to apply NAG. After the specified proportion\n            of steps has been iterated, the remaining steps will use original\n            attention processors in FLUX.\n        ",
      }),
    )
    .default(0.25),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  control_loras: z
    .optional(
      z.array(zControlLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation which use a control image. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  scheduler: z.optional(
    z.enum(["euler", "dpmpp_2m"]).register(z.globalRegistry, {
      description: "Scheduler for the denoising process.",
    }),
  ),
  easycontrols: z
    .optional(
      z.array(zEasyControlWeight).register(z.globalRegistry, {
        description:
          "\n        EasyControl Inputs to use for image generation.\n        ",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  real_cfg_scale: z
    .optional(
      z.number().gte(0).lte(5).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  use_cfg_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            Uses CFG-zero init sampling as in https://arxiv.org/abs/2503.18886.\n        ",
      }),
    )
    .default(false),
  fill_image: z.optional(zImageFillInput),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  sigma_schedule: z.optional(
    z.enum(["sgm_uniform"]).register(z.globalRegistry, {
      description: "Sigmas schedule for the denoising process.",
    }),
  ),
  reference_end: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            The percentage of the total timesteps when the reference guidance is to be ended.\n        ",
      }),
    )
    .default(1),
  reference_strength: z
    .optional(
      z.number().gte(-3).lte(3).register(z.globalRegistry, {
        description:
          "Strength of reference_only generation. Only used if a reference image is provided.",
      }),
    )
    .default(0.65),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  nag_scale: z
    .optional(
      z.number().lte(10).register(z.globalRegistry, {
        description:
          "\n            The scale for NAG. Higher values will result in a image that is more distant\n            to the negative prompt.\n        ",
      }),
    )
    .default(3),
  reference_image_url: z.optional(z.union([z.string(), z.string()])),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  controlnet_unions: z
    .optional(
      z.array(zControlNetUnion).register(z.globalRegistry, {
        description:
          "\n            The controlnet unions to use for the image generation. Only one controlnet is supported at the moment.\n        ",
      }),
    )
    .default([]),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            Negative prompt to steer the image generation away from unwanted features.\n            By default, we will be using NAG for processing the negative prompt.\n        ",
      }),
    )
    .default(""),
  nag_tau: z
    .optional(
      z.number().register(z.globalRegistry, {
        description:
          "\n            The tau for NAG. Controls the normalization of the hidden state.\n            Higher values will result in a less aggressive normalization,\n            but may also lead to unexpected changes with respect to the original image.\n            Not recommended to change this value.\n        ",
      }),
    )
    .default(2.5),
  num_images: z
    .optional(
      z.int().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "The number of images to generate. This is always set to 1 for streaming output.",
      }),
    )
    .default(1),
  use_beta_schedule: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Specifies whether beta sigmas ought to be used.",
      }),
    )
    .default(false),
  ip_adapters: z
    .optional(
      z.array(zIpAdapter).register(z.globalRegistry, {
        description:
          "\n        IP-Adapter to use for image generation.\n        ",
      }),
    )
    .default([]),
  base_shift: z
    .optional(
      z.number().gte(0.01).lte(5).register(z.globalRegistry, {
        description: "Base shift for the scheduled timesteps",
      }),
    )
    .default(0.5),
  nag_alpha: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description:
          "\n            The alpha value for NAG. This value is used as a final weighting\n            factor for steering the normalized guidance (positive and negative prompts)\n            in the direction of the positive prompt. Higher values will result in less\n            steering on the normalized guidance where lower values will result in\n            considering the positive prompt guidance more.\n        ",
      }),
    )
    .default(0.25),
  use_real_cfg: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            Uses classical CFG as in SD1.5, SDXL, etc. Increases generation times and price when set to be true.\n            If using XLabs IP-Adapter v1, this will be turned on!.\n        ",
      }),
    )
    .default(false),
  max_shift: z
    .optional(
      z.number().gte(0.01).lte(5).register(z.globalRegistry, {
        description: "Max shift for the scheduled timesteps",
      }),
    )
    .default(1.15),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  controlnets: z
    .optional(
      z.array(zControlNet).register(z.globalRegistry, {
        description:
          "\n            The controlnets to use for the image generation. Only one controlnet is supported at the moment.\n        ",
      }),
    )
    .default([]),
  reference_start: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            The percentage of the total timesteps when the reference guidance is to bestarted.\n        ",
      }),
    )
    .default(0),
});

/**
 * Output
 */
export const zStableDiffusionV35LargeOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * ControlNet
 */
export const zControlNetType3 = z.object({
  conditioning_scale: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description:
          "\n            The scale of the control net weight. This is used to scale the control net weight\n            before merging it with the base model.\n        ",
      }),
    )
    .default(1),
  path: z.string().register(z.globalRegistry, {
    description: "URL or the path to the control net weights.",
  }),
  control_image_url: z.string().register(z.globalRegistry, {
    description: "URL of the image to be used as the control image.",
  }),
  start_percentage: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            The percentage of the image to start applying the controlnet in terms of the total timesteps.\n        ",
      }),
    )
    .default(0),
  end_percentage: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            The percentage of the image to end applying the controlnet in terms of the total timesteps.\n        ",
      }),
    )
    .default(1),
});

/**
 * TextToImageInput
 */
export const zStableDiffusionV35LargeInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  controlnet: z.optional(zControlNetType3),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  ip_adapter: z.optional(zIpAdapter),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * Output
 */
export const zIdeogramV2Output = z.object({
  images: z.array(zFileType2),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for the random number generator",
  }),
});

/**
 * TextToImageInput
 */
export const zIdeogramV2Input = z.object({
  prompt: z.string(),
  aspect_ratio: z.optional(
    z
      .enum([
        "10:16",
        "16:10",
        "9:16",
        "16:9",
        "4:3",
        "3:4",
        "1:1",
        "1:3",
        "3:1",
        "3:2",
        "2:3",
      ])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image",
      }),
  ),
  style: z.optional(
    z
      .enum(["auto", "general", "realistic", "design", "render_3D", "anime"])
      .register(z.globalRegistry, {
        description: "The style of the generated image",
      }),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to expand the prompt with MagicPrompt functionality.",
      }),
    )
    .default(true),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "A negative prompt to avoid in the generated image",
      }),
    )
    .default(""),
});

/**
 * Output
 */
export const zFluxDevOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseInput
 */
export const zFluxDevInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
});

/**
 * Output
 */
export const zHidreamI1FastOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * FastInput
 */
export const zHidreamI1FastInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(16),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
});

/**
 * Output
 */
export const zHidreamI1DevOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * DevInput
 */
export const zHidreamI1DevInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
});

export const zHidreamI1FullOutput = z.unknown();

/**
 * LoraWeight
 */
export const zLoraWeightType3 = z.object({
  path: z.string().register(z.globalRegistry, {
    description: "URL or the path to the LoRA weights.",
  }),
  scale: z
    .optional(
      z.number().gte(0).lte(4).register(z.globalRegistry, {
        description:
          "\n            The scale of the LoRA weight. This is used to scale the LoRA weight\n            before merging it with the base model.\n        ",
      }),
    )
    .default(1),
  weight_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "Name of the LoRA weight. Used only if `path` is a Hugging Face repository, and required only if you have more than 1 safetensors file in the repo.",
    }),
  ),
});

/**
 * TextToImageInput
 */
export const zHidreamI1FullInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoraWeightType3).register(z.globalRegistry, {
        description:
          "A list of LoRAs to apply to the model. Each LoRA specifies its path, scale, and optional weight name.",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(50),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * Imagen4TextToImageFastOutput
 */
export const zImagen4PreviewFastOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images.",
  }),
  description: z.string().register(z.globalRegistry, {
    description: "The description of the generated images.",
  }),
});

/**
 * Imagen4TextToImageFastInput
 */
export const zImagen4PreviewFastInput = z.object({
  prompt: z.string().min(3).max(5000).register(z.globalRegistry, {
    description: "The text prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z.enum(["1:1", "16:9", "9:16", "4:3", "3:4"]).register(z.globalRegistry, {
      description: "The aspect ratio of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
});

/**
 * OutputModel
 */
export const zTextToImage32Output = z.object({
  image: zImageType3,
});

/**
 * InputModel
 */
export const zTextToImage32Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "Prompt for image generation.",
  }),
  aspect_ratio: z.optional(
    z
      .enum(["1:1", "2:3", "3:2", "3:4", "4:3", "4:5", "5:4", "9:16", "16:9"])
      .register(z.globalRegistry, {
        description:
          "Aspect ratio. Options: 1:1, 2:3, 3:2, 3:4, 4:3, 4:5, 5:4, 9:16, 16:9",
      }),
  ),
  prompt_enhancer: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to improve the prompt.",
      }),
    )
    .default(true),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If true, returns the image directly in the response (increases latency).",
      }),
    )
    .default(false),
  truncate_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to truncate the prompt.",
      }),
    )
    .default(true),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: "Guidance scale for text.",
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(20).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps.",
      }),
    )
    .default(30),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Random seed for reproducibility.",
      }),
    )
    .default(5555),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Negative prompt for image generation.",
      }),
    )
    .default(
      "Logo,Watermark,Ugly,Morbid,Extra fingers,Poorly drawn hands,Mutation,Blurry,Extra limbs,Gross proportions,Missing arms,Mutated hands,Long neck,Duplicate,Mutilated,Mutilated hands,Poorly drawn face,Deformed,Bad anatomy,Cloned face,Malformed limbs,Missing legs,Too many fingers",
    ),
});

/**
 * Flux2ProOutput
 */
export const zFlux2ProOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for the generation.",
  }),
});

/**
 * Flux2ProTextToImageInput
 */
export const zFlux2ProInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enable the safety checker.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The seed to use for the generation.",
    }),
  ),
});

/**
 * Flux2T2IOutput
 */
export const zFlux2Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * Flux2TextToImageInput
 */
export const zFlux2Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use for the image generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(2.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The seed to use for the generation. If not provided, a random seed will be used.",
    }),
  ),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded for better results.",
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * Flux2T2ILoRAOutput
 */
export const zFlux2LoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * Flux2TextToImageLoRAInput
 */
export const zFlux2LoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use for the image generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  loras: z
    .optional(
      z.array(zLoRaInput).register(z.globalRegistry, {
        description:
          "List of LoRA weights to apply (maximum 3). Each LoRA can be a URL, HuggingFace repo ID, or local path.",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(2.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The seed to use for the generation. If not provided, a random seed will be used.",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded for better results.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * TextToImageOutput
 */
export const zRecraftV3TextToImageOutput = z.object({
  images: z.array(zFile),
});

/**
 * TextToImageInput
 */
export const zRecraftV3TextToImageInput = z.object({
  prompt: z.string().min(1).max(1000),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(false),
  colors: z
    .optional(
      z.array(zRgbColor).register(z.globalRegistry, {
        description: "An array of preferable colors",
      }),
    )
    .default([]),
  style: z.optional(
    z
      .enum([
        "any",
        "realistic_image",
        "digital_illustration",
        "vector_illustration",
        "realistic_image/b_and_w",
        "realistic_image/hard_flash",
        "realistic_image/hdr",
        "realistic_image/natural_light",
        "realistic_image/studio_portrait",
        "realistic_image/enterprise",
        "realistic_image/motion_blur",
        "realistic_image/evening_light",
        "realistic_image/faded_nostalgia",
        "realistic_image/forest_life",
        "realistic_image/mystic_naturalism",
        "realistic_image/natural_tones",
        "realistic_image/organic_calm",
        "realistic_image/real_life_glow",
        "realistic_image/retro_realism",
        "realistic_image/retro_snapshot",
        "realistic_image/urban_drama",
        "realistic_image/village_realism",
        "realistic_image/warm_folk",
        "digital_illustration/pixel_art",
        "digital_illustration/hand_drawn",
        "digital_illustration/grain",
        "digital_illustration/infantile_sketch",
        "digital_illustration/2d_art_poster",
        "digital_illustration/handmade_3d",
        "digital_illustration/hand_drawn_outline",
        "digital_illustration/engraving_color",
        "digital_illustration/2d_art_poster_2",
        "digital_illustration/antiquarian",
        "digital_illustration/bold_fantasy",
        "digital_illustration/child_book",
        "digital_illustration/child_books",
        "digital_illustration/cover",
        "digital_illustration/crosshatch",
        "digital_illustration/digital_engraving",
        "digital_illustration/expressionism",
        "digital_illustration/freehand_details",
        "digital_illustration/grain_20",
        "digital_illustration/graphic_intensity",
        "digital_illustration/hard_comics",
        "digital_illustration/long_shadow",
        "digital_illustration/modern_folk",
        "digital_illustration/multicolor",
        "digital_illustration/neon_calm",
        "digital_illustration/noir",
        "digital_illustration/nostalgic_pastel",
        "digital_illustration/outline_details",
        "digital_illustration/pastel_gradient",
        "digital_illustration/pastel_sketch",
        "digital_illustration/pop_art",
        "digital_illustration/pop_renaissance",
        "digital_illustration/street_art",
        "digital_illustration/tablet_sketch",
        "digital_illustration/urban_glow",
        "digital_illustration/urban_sketching",
        "digital_illustration/vanilla_dreams",
        "digital_illustration/young_adult_book",
        "digital_illustration/young_adult_book_2",
        "vector_illustration/bold_stroke",
        "vector_illustration/chemistry",
        "vector_illustration/colored_stencil",
        "vector_illustration/contour_pop_art",
        "vector_illustration/cosmics",
        "vector_illustration/cutout",
        "vector_illustration/depressive",
        "vector_illustration/editorial",
        "vector_illustration/emotional_flat",
        "vector_illustration/infographical",
        "vector_illustration/marker_outline",
        "vector_illustration/mosaic",
        "vector_illustration/naivector",
        "vector_illustration/roundish_flat",
        "vector_illustration/segmented_colors",
        "vector_illustration/sharp_contrast",
        "vector_illustration/thin",
        "vector_illustration/vector_photo",
        "vector_illustration/vivid_shapes",
        "vector_illustration/engraving",
        "vector_illustration/line_art",
        "vector_illustration/line_circuit",
        "vector_illustration/linocut",
      ])
      .register(z.globalRegistry, {
        description:
          "The style of the generated images. Vector images cost 2X as much.",
      }),
  ),
  style_id: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The ID of the custom style reference (optional)",
    }),
  ),
});

/**
 * Output
 */
export const zFluxProV11UltraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z
    .array(zRegistryImageFastSdxlModelsImage)
    .register(z.globalRegistry, {
      description: "The generated image files info.",
    }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * FluxProUltraTextToImageInput
 */
export const zFluxProV11UltraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z.union([
      z.enum([
        "21:9",
        "16:9",
        "4:3",
        "3:2",
        "1:1",
        "2:3",
        "3:4",
        "9:16",
        "9:21",
      ]),
      z.string(),
    ]),
  ),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enhance the prompt for better results.",
      }),
    )
    .default(false),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.optional(z.union([z.string(), z.string()])),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.",
    }),
  ),
  image_prompt_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The strength of the image prompt, between 0 and 1.",
      }),
    )
    .default(0.1),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  raw: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Generate less processed, more natural-looking images.",
      }),
    )
    .default(false),
});

/**
 * Imagen4TextToImageOutput
 */
export const zImagen4PreviewOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images.",
  }),
  description: z.string().register(z.globalRegistry, {
    description: "The description of the generated images.",
  }),
});

/**
 * Imagen4TextToImageInput
 */
export const zImagen4PreviewInput = z.object({
  prompt: z.string().min(3).max(5000).register(z.globalRegistry, {
    description: "The text prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z.enum(["1:1", "16:9", "9:16", "4:3", "3:4"]).register(z.globalRegistry, {
      description: "The aspect ratio of the generated image.",
    }),
  ),
  resolution: z.optional(
    z.enum(["1K", "2K"]).register(z.globalRegistry, {
      description: "The resolution of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
});

/**
 * RemoveBackgroundOutput
 */
export const zImageutilsRembgOutput = z.object({
  image: zImage,
});

/**
 * RemoveBackgroundInput
 */
export const zImageutilsRembgInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  crop_to_bbox: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the resulting image be cropped to a bounding box around the subject\n        ",
      }),
    )
    .default(false),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * UpscaleOutput
 */
export const zEsrganOutput = z.object({
  image: zImage,
});

/**
 * UpscaleInput
 */
export const zEsrganInput = z.object({
  model: z.optional(
    z
      .enum([
        "RealESRGAN_x4plus",
        "RealESRGAN_x2plus",
        "RealESRGAN_x4plus_anime_6B",
        "RealESRGAN_x4_v3",
        "RealESRGAN_x4_wdn_v3",
        "RealESRGAN_x4_anime_v3",
      ])
      .register(z.globalRegistry, {
        description: "Model to use for upscaling",
      }),
  ),
  face: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Upscaling a face",
      }),
    )
    .default(false),
  scale: z
    .optional(
      z.number().gte(1).lte(8).register(z.globalRegistry, {
        description: "Rescaling factor",
      }),
    )
    .default(2),
  tile: z
    .optional(
      z.int().register(z.globalRegistry, {
        description:
          "Tile size. Default is 0, that is no tile. When encountering the out-of-GPU-memory issue, please specify it, e.g., 400 or 200",
      }),
    )
    .default(0),
  output_format: z.optional(
    z.enum(["png", "jpeg"]).register(z.globalRegistry, {
      description: "Output image format (png or jpeg)",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * InpaintOutput
 */
export const zInpaintOutput = z.object({
  image: zImage,
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * InpaintInput
 */
export const zInpaintInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  image_url: z.union([z.string(), z.string()]),
  model_name: z.string().register(z.globalRegistry, {
    description:
      "URL or HuggingFace ID of the base model to generate the image.",
  }),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(7.5),
  num_inference_steps: z
    .optional(
      z.int().gte(0).lte(150).register(z.globalRegistry, {
        description:
          "\n            Increasing the amount of steps tells Stable Diffusion that it should take more steps\n            to generate your final result which can increase the amount of detail in your image.\n        ",
      }),
    )
    .default(30),
  mask_url: z.union([z.string(), z.string()]),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * LCMOutput
 */
export const zLcmSd15I2iOutput = z.object({
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ",
      }),
    )
    .default(""),
  timings: z.record(z.string(), z.number()),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  num_inference_steps: z
    .optional(
      z.int().register(z.globalRegistry, {
        description:
          "\n            Number of inference steps used to generate the image. It will be the same value of the one passed in the\n            input or the default one in case none was passed.\n        ",
      }),
    )
    .default(4),
  nsfw_content_detected: z.array(z.boolean()).register(z.globalRegistry, {
    description:
      "\n            A list of booleans indicating whether the generated image contains any\n            potentially unsafe content. If the safety check is disabled, this field\n            will have a false for each generated image.\n        ",
  }),
});

/**
 * LCMI2IInput
 */
export const zLcmSd15I2iInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description:
          "\n            The number of images to generate. The function will return a list of images\n            with the same prompt and negative prompt but different seeds.\n        ",
      }),
    )
    .default(1),
  image_url: z.union([z.string(), z.string()]),
  strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The strength of the image.",
      }),
    )
    .default(0.8),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  enable_safety_checks: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the resulting image will be checked whether it includes any\n            potentially unsafe content. If it does, it will be replaced with a black\n            image.\n        ",
      }),
    )
    .default(true),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(16).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(1),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ",
      }),
    )
    .default(""),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(12).register(z.globalRegistry, {
        description:
          "\n            The number of inference steps to use for generating the image. The more steps\n            the better the image will be but it will also take longer to generate.\n        ",
      }),
    )
    .default(4),
});

/**
 * Output
 */
export const zFastSdxlControlnetCannyInpaintingOutput = z.object({
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * InpaintingControlNetInput
 */
export const zFastSdxlControlnetCannyInpaintingInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
      z.null(),
    ]),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description: "The list of LoRA weights to use.",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(7.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  controlnet_conditioning_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The scale of the controlnet conditioning.",
      }),
    )
    .default(0.5),
  image_url: z.union([z.string(), z.string()]),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "determines how much the generated image resembles the initial image",
      }),
    )
    .default(0.95),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  control_image_url: z.union([z.string(), z.string()]),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  mask_url: z.union([z.string(), z.string()]),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(65).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(25),
});

/**
 * Output
 */
export const zFastSdxlControlnetCannyImageToImageOutput = z.object({
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * ImageToImageControlNetInput
 */
export const zFastSdxlControlnetCannyImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
      z.null(),
    ]),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description: "The list of LoRA weights to use.",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(7.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  controlnet_conditioning_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The scale of the controlnet conditioning.",
      }),
    )
    .default(0.5),
  image_url: z.union([z.string(), z.string()]),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "determines how much the generated image resembles the initial image",
      }),
    )
    .default(0.95),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  control_image_url: z.union([z.string(), z.string()]),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(65).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(25),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * ReferenceFace
 */
export const zReferenceFace = z.object({
  image_url: z.string().register(z.globalRegistry, {
    description: "URL of the reference face image",
  }),
});

/**
 * OutputModel
 */
export const zPulidOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "List of generated images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "Random seed used for reproducibility",
  }),
});

/**
 * InputModel
 */
export const zPulidInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "Prompt to generate the face from",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "Number of images to generate",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  id_scale: z
    .optional(
      z.number().lte(5).register(z.globalRegistry, {
        description: "ID scale",
      }),
    )
    .default(0.8),
  mode: z.optional(
    z.enum(["fidelity", "extreme style"]).register(z.globalRegistry, {
      description: "Mode of generation",
    }),
  ),
  id_mix: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "if you want to mix two ID image, please turn this on, otherwise, turn this off",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(1.5).register(z.globalRegistry, {
        description: "Guidance scale",
      }),
    )
    .default(1.2),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(12).register(z.globalRegistry, {
        description: "Number of steps to take",
      }),
    )
    .default(4),
  reference_images: z.array(zReferenceFace).register(z.globalRegistry, {
    description: "List of reference faces, ideally 4 images.",
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Negative prompt to generate the face from",
      }),
    )
    .default(
      "flaws in the eyes, flaws in the face, flaws, lowres, non-HDRi, low quality, worst quality,artifacts noise, text, watermark, glitch, deformed, mutated, ugly, disfigured, hands, low resolution, partially rendered objects,  deformed or partially rendered eyes, deformed, deformed eyeballs, cross-eyed,blurry",
    ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Random seed for reproducibility",
    }),
  ),
});

/**
 * MarigoldDepthMapOutput
 */
export const zImageutilsMarigoldDepthOutput = z.object({
  image: zImage,
});

/**
 * MarigoldDepthMapInput
 */
export const zImageutilsMarigoldDepthInput = z.object({
  ensemble_size: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description:
          "Number of predictions to average over. Defaults to `10`. The higher the number, the more accurate the result, but the slower the inference.",
      }),
    )
    .default(10),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description:
          "Number of denoising steps. Defaults to `10`. The higher the number, the more accurate the result, but the slower the inference.",
      }),
    )
    .default(10),
  processing_res: z
    .optional(
      z.int().gte(0).lte(2048).register(z.globalRegistry, {
        description:
          "Maximum processing resolution. Defaults `0` which means it uses the size of the input image.",
      }),
    )
    .default(0),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * DepthMapOutput
 */
export const zImageutilsDepthOutput = z.object({
  image: zImage,
});

/**
 * DepthMapInput
 */
export const zImageutilsDepthInput = z.object({
  bg_th: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: "bg_th",
      }),
    )
    .default(0.1),
  a: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: "a",
      }),
    )
    .default(6.283185307179586),
  depth_and_normal: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "depth_and_normal",
      }),
    )
    .default(false),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * RetoucherOutput
 */
export const zRetoucherOutput = z.object({
  image: zImage,
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for the generation.",
  }),
});

/**
 * RetoucherInput
 */
export const zRetoucherInput = z.object({
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Seed for reproducibility. Different seeds will make slightly different results.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * Output
 */
export const zFastLcmDiffusionImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * ImageToImageLCMInput
 */
export const zFastLcmDiffusionImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The rescale factor for the CFG.",
      }),
    )
    .default(0),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(1.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  preserve_aspect_ratio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n        If set to true, the aspect ratio of the generated image will be preserved even\n        if the image size is too large. However, if the image is not a multiple of 32\n        in width or height, it will be resized to the nearest multiple of 32. By default,\n        this snapping to the nearest multiple of 32 will not preserve the aspect ratio.\n        Set crop_output to True, to crop the output to the proper aspect ratio\n        after generating.\n        ",
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  crop_output: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n        If set to true, the output cropped to the proper aspect ratio after generating.\n        ",
      }),
    )
    .default(false),
  format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(true),
  model_name: z.optional(
    z
      .enum([
        "stabilityai/stable-diffusion-xl-base-1.0",
        "runwayml/stable-diffusion-v1-5",
      ])
      .register(z.globalRegistry, {
        description: "The name of the model to use.",
      }),
  ),
  safety_checker_version: z.optional(
    z.enum(["v1", "v2"]).register(z.globalRegistry, {
      description:
        "The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.",
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ",
      }),
    )
    .default(""),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(32).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(6),
  strength: z
    .optional(
      z.number().gte(0.05).lte(1).register(z.globalRegistry, {
        description:
          "determines how much the generated image resembles the initial image",
      }),
    )
    .default(0.95),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * Output
 */
export const zFastLcmDiffusionInpaintingOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * InpaintingLCMInput
 */
export const zFastLcmDiffusionInpaintingInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The rescale factor for the CFG.",
      }),
    )
    .default(0),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(1.5),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_url: z.union([z.string(), z.string()]),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "determines how much the generated image resembles the initial image",
      }),
    )
    .default(0.95),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(true),
  safety_checker_version: z.optional(
    z.enum(["v1", "v2"]).register(z.globalRegistry, {
      description:
        "The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.",
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ",
      }),
    )
    .default(""),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(32).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(6),
  mask_url: z.union([z.string(), z.string()]),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  model_name: z.optional(
    z
      .enum([
        "stabilityai/stable-diffusion-xl-base-1.0",
        "runwayml/stable-diffusion-v1-5",
      ])
      .register(z.globalRegistry, {
        description: "The name of the model to use.",
      }),
  ),
});

/**
 * Output
 */
export const zPlaygroundV25InpaintingOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * InpaintingPlaygroundv25Input
 */
export const zPlaygroundV25InpaintingInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zEmbedding).register(z.globalRegistry, {
        description: "The list of embeddings to use.",
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The rescale factor for the CFG.",
      }),
    )
    .default(0),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_url: z.union([z.string(), z.string()]),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "determines how much the generated image resembles the initial image",
      }),
    )
    .default(0.95),
  safety_checker_version: z.optional(
    z.enum(["v1", "v2"]).register(z.globalRegistry, {
      description:
        "The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.",
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ",
      }),
    )
    .default(""),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  mask_url: z.union([z.string(), z.string()]),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(65).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(25),
});

/**
 * Output
 */
export const zFastLightningSdxlInpaintingOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * InpaintingLightningInput
 */
export const zFastLightningSdxlInpaintingInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zEmbedding).register(z.globalRegistry, {
        description: "The list of embeddings to use.",
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The rescale factor for the CFG.",
      }),
    )
    .default(0),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_url: z.union([z.string(), z.string()]),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "determines how much the generated image resembles the initial image",
      }),
    )
    .default(0.95),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_checker_version: z.optional(
    z.enum(["v1", "v2"]).register(z.globalRegistry, {
      description:
        "The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.",
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ",
      }),
    )
    .default(""),
  num_inference_steps: z.optional(
    z.enum(["1", "2", "4", "8"]).register(z.globalRegistry, {
      description: "The number of inference steps to perform.",
    }),
  ),
  mask_url: z.union([z.string(), z.string()]),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * Output
 */
export const zFastLightningSdxlImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * ImageToImageLightningInput
 */
export const zFastLightningSdxlImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zEmbedding).register(z.globalRegistry, {
        description: "The list of embeddings to use.",
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The rescale factor for the CFG.",
      }),
    )
    .default(0),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  preserve_aspect_ratio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n        If set to true, the aspect ratio of the generated image will be preserved even\n        if the image size is too large. However, if the image is not a multiple of 32\n        in width or height, it will be resized to the nearest multiple of 32. By default,\n        this snapping to the nearest multiple of 32 will not preserve the aspect ratio.\n        Set crop_output to True, to crop the output to the proper aspect ratio\n        after generating.\n        ",
      }),
    )
    .default(false),
  crop_output: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n        If set to true, the output cropped to the proper aspect ratio after generating.\n        ",
      }),
    )
    .default(false),
  format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_url: z.union([z.string(), z.string()]),
  strength: z
    .optional(
      z.number().gte(0.05).lte(1).register(z.globalRegistry, {
        description:
          "determines how much the generated image resembles the initial image",
      }),
    )
    .default(0.95),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_checker_version: z.optional(
    z.enum(["v1", "v2"]).register(z.globalRegistry, {
      description:
        "The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.",
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ",
      }),
    )
    .default(""),
  num_inference_steps: z.optional(
    z.enum(["1", "2", "4", "8"]).register(z.globalRegistry, {
      description: "The number of inference steps to perform.",
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * Output
 */
export const zPlaygroundV25ImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * ImageToImagePlaygroundv25Input
 */
export const zPlaygroundV25ImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zEmbedding).register(z.globalRegistry, {
        description: "The list of embeddings to use.",
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The rescale factor for the CFG.",
      }),
    )
    .default(0),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3),
  preserve_aspect_ratio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n        If set to true, the aspect ratio of the generated image will be preserved even\n        if the image size is too large. However, if the image is not a multiple of 32\n        in width or height, it will be resized to the nearest multiple of 32. By default,\n        this snapping to the nearest multiple of 32 will not preserve the aspect ratio.\n        Set crop_output to True, to crop the output to the proper aspect ratio\n        after generating.\n        ",
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  crop_output: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n        If set to true, the output cropped to the proper aspect ratio after generating.\n        ",
      }),
    )
    .default(false),
  format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_url: z.union([z.string(), z.string()]),
  strength: z
    .optional(
      z.number().gte(0.05).lte(1).register(z.globalRegistry, {
        description:
          "determines how much the generated image resembles the initial image",
      }),
    )
    .default(0.95),
  safety_checker_version: z.optional(
    z.enum(["v1", "v2"]).register(z.globalRegistry, {
      description:
        "The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.",
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ",
      }),
    )
    .default(""),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(65).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(25),
});

/**
 * Output
 */
export const zBirefnetOutput = z.object({
  image: zImageFile,
  mask_image: z.optional(zImageFile),
});

/**
 * Input
 */
export const zBirefnetInput = z.object({
  operating_resolution: z.optional(
    z.enum(["1024x1024", "2048x2048"]).register(z.globalRegistry, {
      description:
        "The resolution to operate on. The higher the resolution, the more accurate the output will be for high res input images.",
    }),
  ),
  output_format: z.optional(
    z.enum(["webp", "png", "gif"]).register(z.globalRegistry, {
      description: "The format of the output image",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  model: z.optional(
    z
      .enum(["General Use (Light)", "General Use (Heavy)", "Portrait"])
      .register(z.globalRegistry, {
        description:
          "\n            Model to use for background removal.\n            The 'General Use (Light)' model is the original model used in the BiRefNet repository.\n            The 'General Use (Heavy)' model is a slower but more accurate model.\n            The 'Portrait' model is a model trained specifically for portrait images.\n            The 'General Use (Light)' model is recommended for most use cases.\n\n            The corresponding models are as follows:\n            - 'General Use (Light)': BiRefNet-DIS_ep580.pth\n            - 'General Use (Heavy)': BiRefNet-massive-epoch_240.pth\n            - 'Portrait': BiRefNet-portrait-TR_P3M_10k-epoch_120.pth\n        ",
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  output_mask: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to output the mask used to remove the background",
      }),
    )
    .default(false),
  refine_foreground: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to refine the foreground using the estimated mask",
      }),
    )
    .default(true),
});

/**
 * CreativeUpscalerOutput
 */
export const zCreativeUpscalerOutput = z.object({
  image: zImage,
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * CreativeUpscalerInput
 */
export const zCreativeUpscalerInput = z.object({
  shape_preservation: z
    .optional(
      z.number().gte(0).lte(3).register(z.globalRegistry, {
        description: "How much to preserve the shape of the original image",
      }),
    )
    .default(0.25),
  prompt: z.optional(z.union([z.string(), z.null()])),
  additional_embedding_url: z.optional(z.union([z.string(), z.string()])),
  enable_safety_checks: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the resulting image will be checked whether it includes any\n            potentially unsafe content. If it does, it will be replaced with a black\n            image.\n        ",
      }),
    )
    .default(true),
  additional_lora_url: z.optional(z.union([z.string(), z.string()])),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(16).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(7.5),
  scale: z
    .optional(
      z.number().gte(1).lte(5).register(z.globalRegistry, {
        description:
          "The scale of the output image. The higher the scale, the bigger the output image will be.",
      }),
    )
    .default(2),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(
      "blurry, low resolution, bad, ugly, low quality, pixelated, interpolated, compression artifacts, noisey, grainy",
    ),
  skip_ccsr: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the image will not be processed by the CCSR model before\n            being processed by the creativity model.\n        ",
      }),
    )
    .default(false),
  additional_lora_scale: z
    .optional(
      z.number().register(z.globalRegistry, {
        description:
          "The scale of the additional LORA model to use for the upscaling. Default is 1.0",
      }),
    )
    .default(1),
  detail: z
    .optional(
      z.number().gte(0).lte(5).register(z.globalRegistry, {
        description: "How much detail to add",
      }),
    )
    .default(1),
  base_model_url: z.optional(z.union([z.string(), z.string()])),
  image_url: z.union([z.string(), z.string()]),
  creativity: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "How much the output can deviate from the original",
      }),
    )
    .default(0.5),
  override_size_limits: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            Allow for large uploads that could take a very long time.\n        ",
      }),
    )
    .default(false),
  prompt_suffix: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The suffix to add to the prompt. This is useful to add a common ending to all prompts such as 'high quality' etc or embedding tokens.",
      }),
    )
    .default(" high quality, highly detailed, high resolution, sharp"),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(200).register(z.globalRegistry, {
        description:
          "\n            The number of inference steps to use for generating the image. The more steps\n            the better the image will be but it will also take longer to generate.\n        ",
      }),
    )
    .default(20),
  model_type: z.optional(
    z.enum(["SD_1_5", "SDXL"]).register(z.globalRegistry, {
      description:
        "The type of model to use for the upscaling. Default is SD_1_5",
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * PhotoMakerOutput
 */
export const zPhotomakerOutput = z.object({
  images: z.array(zImageType3),
  seed: z.int(),
});

/**
 * PhotoMakerInput
 */
export const zPhotomakerInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "\n            Number of images to generate in one request. Note that the higher the batch size,\n            the longer it will take to generate the images.\n        ",
      }),
    )
    .default(1),
  style_strength: z.optional(z.int().gte(15).lte(50)).default(20),
  style: z.optional(
    z.enum([
      "(No style)",
      "Cinematic",
      "Disney Character",
      "Digital Art",
      "Photographic",
      "Fantasy art",
      "Neonpunk",
      "Enhance",
      "Comic book",
      "Lowpoly",
      "Line art",
    ]),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0.1).lte(10).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  image_archive_url: z.union([z.string(), z.string()]),
  initial_image_url: z.optional(z.union([z.string(), z.string()])),
  num_inference_steps: z
    .optional(
      z.int().gte(20).lte(100).register(z.globalRegistry, {
        description:
          "\n            Increasing the amount of steps tells Stable Diffusion that it should take more steps\n            to generate your final result which can increase the amount of detail in your image.\n        ",
      }),
    )
    .default(50),
  initial_image_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "How much noise to add to the latent image. O for no noise, 1 for maximum noise.",
      }),
    )
    .default(0.5),
  base_pipeline: z.optional(
    z.enum(["photomaker", "photomaker-style"]).register(z.globalRegistry, {
      description: "The base pipeline to use for generating the image.",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
});

/**
 * FaceToStickerOutput
 */
export const zFaceToStickerOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated images.",
  }),
  sticker_image: zImage,
  sticker_image_background_removed: zImage,
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used during the inference.",
  }),
  has_nsfw_concepts: z
    .record(z.string(), z.boolean())
    .register(z.globalRegistry, {
      description:
        "\n            Whether the generated images contain NSFW concepts.\n            The key is the image type and the value is a boolean.\n        ",
    }),
});

/**
 * FaceToStickerInput
 */
export const zFaceToStickerInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to false, the safety checker will be disabled.",
      }),
    )
    .default(true),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  ip_adapter_weight: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The weight of the IP adapter.",
      }),
    )
    .default(0.2),
  image_url: z.union([z.string(), z.string()]),
  upscale_steps: z
    .optional(
      z.int().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "The number of steps to use for upscaling. Only used if `upscale` is `true`.",
      }),
    )
    .default(10),
  instant_id_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The strength of the instant ID.",
      }),
    )
    .default(0.7),
  upscale: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to upscale the image 2x.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(4.5),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(40).register(z.globalRegistry, {
        description:
          "\n            Increasing the amount of steps tells Stable Diffusion that it should take more steps\n            to generate your final result which can increase the amount of detail in your image.\n        ",
      }),
    )
    .default(20),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  ip_adapter_noise: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The amount of noise to add to the IP adapter.",
      }),
    )
    .default(0.5),
});

/**
 * Output
 */
export const zFastSdxlInpaintingOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * InpaintingInput
 */
export const zFastSdxlInpaintingInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zEmbedding).register(z.globalRegistry, {
        description: "The list of embeddings to use.",
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoraWeightType2).register(z.globalRegistry, {
        description: "The list of LoRA weights to use.",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(7.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_url: z.union([z.string(), z.string()]),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "determines how much the generated image resembles the initial image",
      }),
    )
    .default(0.95),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_checker_version: z.optional(
    z.enum(["v1", "v2"]).register(z.globalRegistry, {
      description:
        "The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.",
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ",
      }),
    )
    .default(""),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(65).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(25),
  mask_url: z.union([z.string(), z.string()]),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * Output
 */
export const zFastSdxlImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * ImageToImageInput
 */
export const zFastSdxlImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zEmbedding).register(z.globalRegistry, {
        description: "The list of embeddings to use.",
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoraWeightType2).register(z.globalRegistry, {
        description: "The list of LoRA weights to use.",
      }),
    )
    .default([]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(7.5),
  preserve_aspect_ratio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n        If set to true, the aspect ratio of the generated image will be preserved even\n        if the image size is too large. However, if the image is not a multiple of 32\n        in width or height, it will be resized to the nearest multiple of 32. By default,\n        this snapping to the nearest multiple of 32 will not preserve the aspect ratio.\n        Set crop_output to True, to crop the output to the proper aspect ratio\n        after generating.\n        ",
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  crop_output: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n        If set to true, the output cropped to the proper aspect ratio after generating.\n        ",
      }),
    )
    .default(false),
  format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_url: z.union([z.string(), z.string()]),
  strength: z
    .optional(
      z.number().gte(0.05).lte(1).register(z.globalRegistry, {
        description:
          "determines how much the generated image resembles the initial image",
      }),
    )
    .default(0.95),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_checker_version: z.optional(
    z.enum(["v1", "v2"]).register(z.globalRegistry, {
      description:
        "The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.",
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ",
      }),
    )
    .default(""),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(65).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(25),
});

/**
 * OutputParameters
 */
export const zLoraImageToImageOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  debug_latents: z.optional(zFile),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  debug_per_pass_latents: z.optional(zFile),
});

/**
 * ImageToImageInput
 */
export const zLoraImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  noise_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "The amount of noise to add to noise image for image. Only used if the image_url is provided. 1.0 is complete noise and 0 is no noise.",
      }),
    )
    .default(0.5),
  tile_height: z
    .optional(
      z.int().gte(128).lte(4096).register(z.globalRegistry, {
        description:
          "The size of the tiles to be used for the image generation.",
      }),
    )
    .default(4096),
  embeddings: z
    .optional(
      z.array(zEmbedding).register(z.globalRegistry, {
        description:
          "\n            The embeddings to use for the image generation. Only a single embedding is supported at the moment.\n            The embeddings will be used to map the tokens in the prompt to the embedding weights.\n        ",
      }),
    )
    .default([]),
  ic_light_model_url: z.optional(z.union([z.string(), z.string()])),
  image_encoder_weight_name: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The weight name of the image encoder model to use for the image generation.\n        ",
      }),
    )
    .default("pytorch_model.bin"),
  ip_adapter: z
    .optional(
      z.array(zIpAdapterType2).register(z.globalRegistry, {
        description:
          "\n            The IP adapter to use for the image generation.\n        ",
      }),
    )
    .default([]),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  scheduler: z.optional(
    z
      .enum([
        "DPM++ 2M",
        "DPM++ 2M Karras",
        "DPM++ 2M SDE",
        "DPM++ 2M SDE Karras",
        "Euler",
        "Euler A",
        "Euler (trailing timesteps)",
        "LCM",
        "LCM (trailing timesteps)",
        "DDIM",
        "TCD",
      ])
      .register(z.globalRegistry, {
        description:
          "Scheduler / sampler to use for the image denoising process.",
      }),
  ),
  sigmas: z.optional(zSigmasInput),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(7.5),
  tile_stride_width: z
    .optional(
      z.int().gte(64).lte(2048).register(z.globalRegistry, {
        description:
          "The stride of the tiles to be used for the image generation.",
      }),
    )
    .default(2048),
  debug_per_pass_latents: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the latents will be saved for debugging per pass.",
      }),
    )
    .default(false),
  timesteps: z.optional(zTimestepsInput),
  model_name: z.string().register(z.globalRegistry, {
    description:
      "URL or HuggingFace ID of the base model to generate the image.",
  }),
  prompt_weighting: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the prompt weighting syntax will be used.\n            Additionally, this will lift the 77 token limit by averaging embeddings.\n        ",
      }),
    )
    .default(false),
  variant: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "The variant of the model to use for huggingface models, e.g. 'fp16'.",
    }),
  ),
  image_url: z.optional(z.union([z.string(), z.string()])),
  controlnet_guess_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the controlnet will be applied to only the conditional predictions.\n        ",
      }),
    )
    .default(false),
  image_encoder_subfolder: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "\n            The subfolder of the image encoder model to use for the image generation.\n        ",
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  ic_light_model_background_image_url: z.optional(
    z.union([z.string(), z.string()]),
  ),
  rescale_betas_snr_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            Whether to set the rescale_betas_snr_zero option or not for the sampler\n        ",
      }),
    )
    .default(false),
  tile_width: z
    .optional(
      z.int().gte(128).lte(4096).register(z.globalRegistry, {
        description:
          "The size of the tiles to be used for the image generation.",
      }),
    )
    .default(4096),
  prediction_type: z.optional(
    z.enum(["v_prediction", "epsilon"]).register(z.globalRegistry, {
      description:
        "\n            The type of prediction to use for the image generation.\n            The `epsilon` is the default.\n        ",
    }),
  ),
  eta: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The eta value to be used for the image generation.",
      }),
    )
    .default(0),
  image_encoder_path: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "\n            The path to the image encoder model to use for the image generation.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  image_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description:
          "\n            Number of images to generate in one request. Note that the higher the batch size,\n            the longer it will take to generate the images.\n        ",
      }),
    )
    .default(1),
  debug_latents: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the latents will be saved for debugging.",
      }),
    )
    .default(false),
  ic_light_image_url: z.optional(z.union([z.string(), z.string()])),
  unet_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "URL or HuggingFace ID of the custom U-Net model to use for the image generation.",
    }),
  ),
  clip_skip: z
    .optional(
      z.int().gte(0).lte(2).register(z.globalRegistry, {
        description:
          "\n            Skips part of the image generation process, leading to slightly different results.\n            This means the image renders faster, too.\n        ",
      }),
    )
    .default(0),
  tile_stride_height: z
    .optional(
      z.int().gte(64).lte(2048).register(z.globalRegistry, {
        description:
          "The stride of the tiles to be used for the image generation.",
      }),
    )
    .default(2048),
  controlnets: z
    .optional(
      z.array(zControlNetType2).register(z.globalRegistry, {
        description:
          "\n            The control nets to use for the image generation. You can use any number of control nets\n            and they will be applied to the image at the specified timesteps.\n        ",
      }),
    )
    .default([]),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(150).register(z.globalRegistry, {
        description:
          "\n            Increasing the amount of steps tells Stable Diffusion that it should take more steps\n            to generate your final result which can increase the amount of detail in your image.\n        ",
      }),
    )
    .default(30),
});

/**
 * OutputParameters
 */
export const zLoraInpaintOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  debug_latents: z.optional(zFile),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  debug_per_pass_latents: z.optional(zFile),
});

/**
 * InpaintInput
 */
export const zLoraInpaintInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  noise_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "The amount of noise to add to noise image for image. Only used if the image_url is provided. 1.0 is complete noise and 0 is no noise.",
      }),
    )
    .default(0.5),
  tile_height: z
    .optional(
      z.int().gte(128).lte(4096).register(z.globalRegistry, {
        description:
          "The size of the tiles to be used for the image generation.",
      }),
    )
    .default(4096),
  embeddings: z
    .optional(
      z.array(zEmbedding).register(z.globalRegistry, {
        description:
          "\n            The embeddings to use for the image generation. Only a single embedding is supported at the moment.\n            The embeddings will be used to map the tokens in the prompt to the embedding weights.\n        ",
      }),
    )
    .default([]),
  ic_light_model_url: z.optional(z.union([z.string(), z.string()])),
  image_encoder_weight_name: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The weight name of the image encoder model to use for the image generation.\n        ",
      }),
    )
    .default("pytorch_model.bin"),
  ip_adapter: z
    .optional(
      z.array(zIpAdapterType2).register(z.globalRegistry, {
        description:
          "\n            The IP adapter to use for the image generation.\n        ",
      }),
    )
    .default([]),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  scheduler: z.optional(
    z
      .enum([
        "DPM++ 2M",
        "DPM++ 2M Karras",
        "DPM++ 2M SDE",
        "DPM++ 2M SDE Karras",
        "Euler",
        "Euler A",
        "Euler (trailing timesteps)",
        "LCM",
        "LCM (trailing timesteps)",
        "DDIM",
        "TCD",
      ])
      .register(z.globalRegistry, {
        description:
          "Scheduler / sampler to use for the image denoising process.",
      }),
  ),
  sigmas: z.optional(zSigmasInput),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(7.5),
  tile_stride_width: z
    .optional(
      z.int().gte(64).lte(2048).register(z.globalRegistry, {
        description:
          "The stride of the tiles to be used for the image generation.",
      }),
    )
    .default(2048),
  debug_per_pass_latents: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the latents will be saved for debugging per pass.",
      }),
    )
    .default(false),
  timesteps: z.optional(zTimestepsInput),
  model_name: z.string().register(z.globalRegistry, {
    description:
      "URL or HuggingFace ID of the base model to generate the image.",
  }),
  prompt_weighting: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the prompt weighting syntax will be used.\n            Additionally, this will lift the 77 token limit by averaging embeddings.\n        ",
      }),
    )
    .default(false),
  variant: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "The variant of the model to use for huggingface models, e.g. 'fp16'.",
    }),
  ),
  image_url: z.optional(z.union([z.string(), z.string()])),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  mask_url: z.optional(z.union([z.string(), z.string()])),
  image_encoder_subfolder: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "\n            The subfolder of the image encoder model to use for the image generation.\n        ",
    }),
  ),
  ic_light_model_background_image_url: z.optional(
    z.union([z.string(), z.string()]),
  ),
  rescale_betas_snr_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            Whether to set the rescale_betas_snr_zero option or not for the sampler\n        ",
      }),
    )
    .default(false),
  tile_width: z
    .optional(
      z.int().gte(128).lte(4096).register(z.globalRegistry, {
        description:
          "The size of the tiles to be used for the image generation.",
      }),
    )
    .default(4096),
  controlnet_guess_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the controlnet will be applied to only the conditional predictions.\n        ",
      }),
    )
    .default(false),
  prediction_type: z.optional(
    z.enum(["v_prediction", "epsilon"]).register(z.globalRegistry, {
      description:
        "\n            The type of prediction to use for the image generation.\n            The `epsilon` is the default.\n        ",
    }),
  ),
  eta: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The eta value to be used for the image generation.",
      }),
    )
    .default(0),
  image_encoder_path: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "\n            The path to the image encoder model to use for the image generation.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  image_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description:
          "\n            Number of images to generate in one request. Note that the higher the batch size,\n            the longer it will take to generate the images.\n        ",
      }),
    )
    .default(1),
  debug_latents: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the latents will be saved for debugging.",
      }),
    )
    .default(false),
  ic_light_image_url: z.optional(z.union([z.string(), z.string()])),
  unet_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "URL or HuggingFace ID of the custom U-Net model to use for the image generation.",
    }),
  ),
  clip_skip: z
    .optional(
      z.int().gte(0).lte(2).register(z.globalRegistry, {
        description:
          "\n            Skips part of the image generation process, leading to slightly different results.\n            This means the image renders faster, too.\n        ",
      }),
    )
    .default(0),
  tile_stride_height: z
    .optional(
      z.int().gte(64).lte(2048).register(z.globalRegistry, {
        description:
          "The stride of the tiles to be used for the image generation.",
      }),
    )
    .default(2048),
  controlnets: z
    .optional(
      z.array(zControlNetType2).register(z.globalRegistry, {
        description:
          "\n            The control nets to use for the image generation. You can use any number of control nets\n            and they will be applied to the image at the specified timesteps.\n        ",
      }),
    )
    .default([]),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(150).register(z.globalRegistry, {
        description:
          "\n            Increasing the amount of steps tells Stable Diffusion that it should take more steps\n            to generate your final result which can increase the amount of detail in your image.\n        ",
      }),
    )
    .default(30),
});

/**
 * IpAdapterFaceIdOutput
 */
export const zIpAdapterFaceIdOutput = z.object({
  image: zImage,
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * IpAdapterFaceIdInput
 */
export const zIpAdapterFaceIdInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  face_image_url: z.optional(z.union([z.string(), z.string()])),
  width: z
    .optional(
      z.int().gte(512).lte(1024).register(z.globalRegistry, {
        description:
          "\n            The width of the generated image.\n        ",
      }),
    )
    .default(512),
  face_id_det_size: z
    .optional(
      z.int().gte(64).lte(640).register(z.globalRegistry, {
        description:
          "\n            The size of the face detection model. The higher the number the more accurate\n            the detection will be but it will also take longer to run. The higher the number the more\n            likely it will fail to find a face as well. Lower it if you are having trouble\n            finding a face in the image.\n        ",
      }),
    )
    .default(640),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(16).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(7.5),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(
      "blurry, low resolution, bad, ugly, low quality, pixelated, interpolated, compression artifacts, noisey, grainy",
    ),
  height: z
    .optional(
      z.int().gte(512).lte(1024).register(z.globalRegistry, {
        description:
          "\n            The height of the generated image.\n        ",
      }),
    )
    .default(512),
  num_samples: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "\n            The number of samples for face id. The more samples the better the image will\n            be but it will also take longer to generate. Default is 4.\n        ",
      }),
    )
    .default(4),
  base_sdxl_model_repo: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The URL to the base SDXL model. Default is SG161222/RealVisXL_V3.0",
      }),
    )
    .default("SG161222/RealVisXL_V3.0"),
  base_1_5_model_repo: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The URL to the base 1.5 model. Default is SG161222/Realistic_Vision_V4.0_noVAE",
      }),
    )
    .default("SG161222/Realistic_Vision_V4.0_noVAE"),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(200).register(z.globalRegistry, {
        description:
          "\n            The number of inference steps to use for generating the image. The more steps\n            the better the image will be but it will also take longer to generate.\n        ",
      }),
    )
    .default(50),
  model_type: z.optional(
    z
      .enum([
        "1_5-v1",
        "1_5-v1-plus",
        "1_5-v2-plus",
        "SDXL-v1",
        "SDXL-v2-plus",
        "1_5-auraface-v1",
      ])
      .register(z.globalRegistry, {
        description:
          "The model type to use. 1_5 is the default and is recommended for most use cases.",
      }),
  ),
  face_images_data_url: z.optional(z.union([z.string(), z.string()])),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * OmniZeroOutput
 */
export const zOmniZeroOutput = z.object({
  image: zImage,
});

/**
 * OmniZeroInput
 */
export const zOmniZeroInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "Prompt to guide the image generation.",
  }),
  identity_image_url: z.union([z.string(), z.string()]),
  identity_strength: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: "Identity strength.",
      }),
    )
    .default(1),
  number_of_images: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Number of images.",
      }),
    )
    .default(1),
  guidance_scale: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: "Guidance scale.",
      }),
    )
    .default(5),
  image_strength: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: "Image strength.",
      }),
    )
    .default(0.75),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Negative prompt to guide the image generation.",
      }),
    )
    .default(""),
  composition_image_url: z.union([z.string(), z.string()]),
  depth_strength: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: "Depth strength.",
      }),
    )
    .default(0.5),
  composition_strength: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: "Composition strength.",
      }),
    )
    .default(1),
  image_url: z.union([z.string(), z.string()]),
  style_image_url: z.union([z.string(), z.string()]),
  face_strength: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: "Face strength.",
      }),
    )
    .default(1),
  style_strength: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: "Style strength.",
      }),
    )
    .default(1),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Seed.",
      }),
    )
    .default(42),
});

/**
 * CCSROutput
 */
export const zCcsrOutput = z.object({
  image: zImage,
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for the generation.",
  }),
});

/**
 * CCSRInput
 */
export const zCcsrInput = z.object({
  color_fix_type: z.optional(
    z.enum(["none", "wavelet", "adain"]).register(z.globalRegistry, {
      description: "Type of color correction for samples.",
    }),
  ),
  tile_diffusion_size: z
    .optional(
      z.int().gte(256).lte(2048).register(z.globalRegistry, {
        description: "Size of patch.",
      }),
    )
    .default(1024),
  tile_vae_decoder_size: z
    .optional(
      z.int().gte(64).lte(2048).register(z.globalRegistry, {
        description: "Size of VAE patch.",
      }),
    )
    .default(226),
  tile_vae_encoder_size: z
    .optional(
      z.int().gte(128).lte(2048).register(z.globalRegistry, {
        description: "Size of latent image",
      }),
    )
    .default(1024),
  t_min: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The starting point of uniform sampling strategy.",
      }),
    )
    .default(0.3333),
  image_url: z.union([z.string(), z.string()]),
  tile_diffusion_stride: z
    .optional(
      z.int().gte(128).lte(1024).register(z.globalRegistry, {
        description: "Stride of sliding patch.",
      }),
    )
    .default(512),
  tile_vae: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If specified, a patch-based sampling strategy will be used for VAE decoding.",
      }),
    )
    .default(false),
  scale: z
    .optional(
      z.number().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "The scale of the output image. The higher the scale, the bigger the output image will be.",
      }),
    )
    .default(2),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Seed for reproducibility. Different seeds will make slightly different results.",
    }),
  ),
  t_max: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The ending point of uniform sampling strategy.",
      }),
    )
    .default(0.6667),
  steps: z
    .optional(
      z.int().gte(10).lte(100).register(z.globalRegistry, {
        description:
          "The number of steps to run the model for. The higher the number the better the quality and longer it will take to generate.",
      }),
    )
    .default(50),
  tile_diffusion: z.optional(
    z.enum(["none", "mix", "gaussian"]).register(z.globalRegistry, {
      description:
        "If specified, a patch-based sampling strategy will be used for sampling.",
    }),
  ),
});

/**
 * Output
 */
export const zSd15DepthControlnetOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageControlNetInput
 */
export const zSd15DepthControlnetInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
      z.null(),
    ]),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description: "The list of LoRA weights to use.",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(7.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  controlnet_conditioning_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The scale of the controlnet conditioning.",
      }),
    )
    .default(0.5),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  control_image_url: z.union([z.string(), z.string()]),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(70).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(35),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  enable_deep_cache: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, DeepCache will be enabled. TBD\n        ",
      }),
    )
    .default(false),
});

/**
 * DWPoseOutput
 */
export const zDwposeOutput = z.object({
  image: zImage,
});

/**
 * DWPoseInput
 */
export const zDwposeInput = z.object({
  draw_mode: z.optional(
    z
      .enum([
        "full-pose",
        "body-pose",
        "face-pose",
        "hand-pose",
        "face-hand-mask",
        "face-mask",
        "hand-mask",
      ])
      .register(z.globalRegistry, {
        description:
          "Mode of drawing the pose on the image. Options are: 'full-pose', 'body-pose', 'face-pose', 'hand-pose', 'face-hand-mask', 'face-mask', 'hand-mask'.",
      }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * SD3Output
 */
export const zStableDiffusionV3MediumImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  num_images: z.int().register(z.globalRegistry, {
    description: "The number of images generated.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * ImageToImageInput
 */
export const zStableDiffusionV3MediumImageToImageInput = z.object({
  prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, prompt will be upsampled with more details.",
      }),
    )
    .default(false),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
      z.null(),
    ]),
  ),
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  image_url: z.union([z.string(), z.string()]),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description: "The strength of the image-to-image transformation.",
      }),
    )
    .default(0.9),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The negative prompt to generate an image from.",
      }),
    )
    .default(""),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * Region
 */
export const zRegion = z.object({
  y1: z.int().gte(0).lte(999).register(z.globalRegistry, {
    description: "Y-coordinate of the top-left corner",
  }),
  x2: z.int().gte(0).lte(999).register(z.globalRegistry, {
    description: "X-coordinate of the bottom-right corner",
  }),
  x1: z.int().gte(0).lte(999).register(z.globalRegistry, {
    description: "X-coordinate of the top-left corner",
  }),
  y2: z.int().gte(0).lte(999).register(z.globalRegistry, {
    description: "Y-coordinate of the bottom-right corner",
  }),
});

/**
 * Polygon
 */
export const zPolygon = z.object({
  points: z.array(z.record(z.string(), z.number())).register(z.globalRegistry, {
    description: "List of points",
  }),
  label: z.string().register(z.globalRegistry, {
    description: "Label of the polygon",
  }),
});

/**
 * PolygonOutput
 */
export const zPolygonOutput = z.object({
  polygons: z.array(zPolygon).register(z.globalRegistry, {
    description: "List of polygons",
  }),
});

/**
 * PolygonOutputWithLabels
 */
export const zFlorence2LargeRegionToSegmentationOutput = z.object({
  image: z.optional(zImage),
  results: zPolygonOutput,
});

/**
 * ImageWithUserCoordinatesInput
 */
export const zFlorence2LargeRegionToSegmentationInput = z.object({
  region: zRegion,
  image_url: z.union([z.string(), z.string()]),
});

/**
 * OCRBoundingBoxSingle
 */
export const zOcrBoundingBoxSingle = z.object({
  y: z.number().register(z.globalRegistry, {
    description: "Y-coordinate of the top-left corner",
  }),
  label: z.string().register(z.globalRegistry, {
    description: "Label of the bounding box",
  }),
  h: z.number().register(z.globalRegistry, {
    description: "Height of the bounding box",
  }),
  w: z.number().register(z.globalRegistry, {
    description: "Width of the bounding box",
  }),
  x: z.number().register(z.globalRegistry, {
    description: "X-coordinate of the top-left corner",
  }),
});

/**
 * OCRBoundingBox
 */
export const zOcrBoundingBox = z.object({
  quad_boxes: z.array(zOcrBoundingBoxSingle).register(z.globalRegistry, {
    description: "List of quadrilateral boxes",
  }),
});

/**
 * OCRBoundingBoxOutputWithLabels
 */
export const zFlorence2LargeOcrWithRegionOutput = z.object({
  image: z.optional(zImage),
  results: zOcrBoundingBox,
});

/**
 * ImageInput
 */
export const zFlorence2LargeOcrWithRegionInput = z.object({
  image_url: z.union([z.string(), z.string()]),
});

/**
 * BoundingBox
 */
export const zBoundingBox = z.object({
  y: z.number().register(z.globalRegistry, {
    description: "Y-coordinate of the top-left corner",
  }),
  label: z.string().register(z.globalRegistry, {
    description: "Label of the bounding box",
  }),
  h: z.number().register(z.globalRegistry, {
    description: "Height of the bounding box",
  }),
  w: z.number().register(z.globalRegistry, {
    description: "Width of the bounding box",
  }),
  x: z.number().register(z.globalRegistry, {
    description: "X-coordinate of the top-left corner",
  }),
});

/**
 * BoundingBoxes
 */
export const zBoundingBoxes = z.object({
  bboxes: z.array(zBoundingBox).register(z.globalRegistry, {
    description: "List of bounding boxes",
  }),
});

/**
 * BoundingBoxOutputWithLabels
 */
export const zFlorence2LargeRegionProposalOutput = z.object({
  image: z.optional(zImage),
  results: zBoundingBoxes,
});

/**
 * ImageInput
 */
export const zFlorence2LargeRegionProposalInput = z.object({
  image_url: z.union([z.string(), z.string()]),
});

/**
 * BoundingBoxOutputWithLabels
 */
export const zFlorence2LargeCaptionToPhraseGroundingOutput = z.object({
  image: z.optional(zImage),
  results: zBoundingBoxes,
});

/**
 * ImageWithTextInput
 */
export const zFlorence2LargeCaptionToPhraseGroundingInput = z.object({
  text_input: z.string().register(z.globalRegistry, {
    description: "Text input for the task",
  }),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * BoundingBoxOutputWithLabels
 */
export const zFlorence2LargeOpenVocabularyDetectionOutput = z.object({
  image: z.optional(zImage),
  results: zBoundingBoxes,
});

/**
 * ImageWithTextInput
 */
export const zFlorence2LargeOpenVocabularyDetectionInput = z.object({
  text_input: z.string().register(z.globalRegistry, {
    description: "Text input for the task",
  }),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * BoundingBoxOutputWithLabels
 */
export const zFlorence2LargeObjectDetectionOutput = z.object({
  image: z.optional(zImage),
  results: zBoundingBoxes,
});

/**
 * ImageInput
 */
export const zFlorence2LargeObjectDetectionInput = z.object({
  image_url: z.union([z.string(), z.string()]),
});

/**
 * PolygonOutputWithLabels
 */
export const zFlorence2LargeReferringExpressionSegmentationOutput = z.object({
  image: z.optional(zImage),
  results: zPolygonOutput,
});

/**
 * ImageWithTextInput
 */
export const zFlorence2LargeReferringExpressionSegmentationInput = z.object({
  text_input: z.string().register(z.globalRegistry, {
    description: "Text input for the task",
  }),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * BoundingBoxOutputWithLabels
 */
export const zFlorence2LargeDenseRegionCaptionOutput = z.object({
  image: z.optional(zImage),
  results: zBoundingBoxes,
});

/**
 * ImageInput
 */
export const zFlorence2LargeDenseRegionCaptionInput = z.object({
  image_url: z.union([z.string(), z.string()]),
});

/**
 * Era3DOutput
 */
export const zEra3dOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "Images with background removed",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for random number generation",
  }),
  normal_images: z.array(zImageType3).register(z.globalRegistry, {
    description: "Normal images with background removed",
  }),
});

/**
 * Era3DInput
 */
export const zEra3dInput = z.object({
  cfg: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(4),
  background_removal: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Background removal",
      }),
    )
    .default(true),
  steps: z
    .optional(
      z.int().gte(1).lte(200).register(z.globalRegistry, {
        description: "Number of steps to run the model for",
      }),
    )
    .default(40),
  crop_size: z
    .optional(
      z.int().gte(256).lte(512).register(z.globalRegistry, {
        description: "Size of the image to crop to",
      }),
    )
    .default(400),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Seed for random number generation",
      }),
    )
    .default(-1),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * Output
 */
export const zSdxlControlnetUnionImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * ImageToImageControlNetUnionInput
 */
export const zSdxlControlnetUnionImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  depth_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to preprocess the depth image.",
      }),
    )
    .default(true),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
      z.null(),
    ]),
  ),
  normal_image_url: z.optional(z.union([z.string(), z.string()])),
  embeddings: z
    .optional(
      z.array(zEmbedding).register(z.globalRegistry, {
        description: "The list of embeddings to use.",
      }),
    )
    .default([]),
  teed_image_url: z.optional(z.union([z.string(), z.string()])),
  loras: z
    .optional(
      z.array(zLoraWeightType2).register(z.globalRegistry, {
        description: "The list of LoRA weights to use.",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(7.5),
  canny_image_url: z.optional(z.union([z.string(), z.string()])),
  segmentation_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to preprocess the segmentation image.",
      }),
    )
    .default(true),
  format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ",
      }),
    )
    .default(""),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  segmentation_image_url: z.optional(z.union([z.string(), z.string()])),
  openpose_image_url: z.optional(z.union([z.string(), z.string()])),
  canny_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to preprocess the canny image.",
      }),
    )
    .default(true),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  depth_image_url: z.optional(z.union([z.string(), z.string()])),
  normal_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to preprocess the normal image.",
      }),
    )
    .default(true),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  preserve_aspect_ratio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n        If set to true, the aspect ratio of the generated image will be preserved even\n        if the image size is too large. However, if the image is not a multiple of 32\n        in width or height, it will be resized to the nearest multiple of 32. By default,\n        this snapping to the nearest multiple of 32 will not preserve the aspect ratio.\n        Set crop_output to True, to crop the output to the proper aspect ratio\n        after generating.\n        ",
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  crop_output: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n        If set to true, the output cropped to the proper aspect ratio after generating.\n        ",
      }),
    )
    .default(false),
  teed_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to preprocess the teed image.",
      }),
    )
    .default(true),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  controlnet_conditioning_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The scale of the controlnet conditioning.",
      }),
    )
    .default(0.5),
  strength: z
    .optional(
      z.number().gte(0.05).lte(1).register(z.globalRegistry, {
        description:
          "determines how much the generated image resembles the initial image",
      }),
    )
    .default(0.95),
  safety_checker_version: z.optional(
    z.enum(["v1", "v2"]).register(z.globalRegistry, {
      description:
        "The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.",
    }),
  ),
  openpose_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to preprocess the openpose image.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(70).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(35),
});

/**
 * Output
 */
export const zSdxlControlnetUnionInpaintingOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * InpaintingControlNetUnionInput
 */
export const zSdxlControlnetUnionInpaintingInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to use for generating the image. Be as descriptive as possible for best results.",
  }),
  depth_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to preprocess the depth image.",
      }),
    )
    .default(true),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
      z.null(),
    ]),
  ),
  normal_image_url: z.optional(z.union([z.string(), z.string()])),
  embeddings: z
    .optional(
      z.array(zEmbedding).register(z.globalRegistry, {
        description: "The list of embeddings to use.",
      }),
    )
    .default([]),
  teed_image_url: z.optional(z.union([z.string(), z.string()])),
  loras: z
    .optional(
      z.array(zLoraWeightType2).register(z.globalRegistry, {
        description: "The list of LoRA weights to use.",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(7.5),
  canny_image_url: z.optional(z.union([z.string(), z.string()])),
  segmentation_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to preprocess the segmentation image.",
      }),
    )
    .default(true),
  format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ",
      }),
    )
    .default(""),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ",
    }),
  ),
  mask_url: z.union([z.string(), z.string()]),
  segmentation_image_url: z.optional(z.union([z.string(), z.string()])),
  openpose_image_url: z.optional(z.union([z.string(), z.string()])),
  canny_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to preprocess the canny image.",
      }),
    )
    .default(true),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded with additional prompts.",
      }),
    )
    .default(false),
  depth_image_url: z.optional(z.union([z.string(), z.string()])),
  normal_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to preprocess the normal image.",
      }),
    )
    .default(true),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  teed_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to preprocess the teed image.",
      }),
    )
    .default(true),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  controlnet_conditioning_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The scale of the controlnet conditioning.",
      }),
    )
    .default(0.5),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "determines how much the generated image resembles the initial image",
      }),
    )
    .default(0.95),
  safety_checker_version: z.optional(
    z.enum(["v1", "v2"]).register(z.globalRegistry, {
      description:
        "The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.",
    }),
  ),
  openpose_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to preprocess the openpose image.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(70).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(35),
});

/**
 * Output
 */
export const zFluxLoraImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * ImageToImageInput
 */
export const zFluxLoraImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "The number of images to generate. This is always set to 1 for streaming output.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.",
      }),
    )
    .default(0.85),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zFluxGeneralDifferentialDiffusionOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * DifferentialDiffusionInput
 */
export const zFluxGeneralDifferentialDiffusionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  nag_end: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description:
          "\n            The proportion of steps to apply NAG. After the specified proportion\n            of steps has been iterated, the remaining steps will use original\n            attention processors in FLUX.\n        ",
      }),
    )
    .default(0.25),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  control_loras: z
    .optional(
      z.array(zControlLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation which use a control image. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  scheduler: z.optional(
    z.enum(["euler", "dpmpp_2m"]).register(z.globalRegistry, {
      description: "Scheduler for the denoising process.",
    }),
  ),
  easycontrols: z
    .optional(
      z.array(zEasyControlWeight).register(z.globalRegistry, {
        description:
          "\n        EasyControl Inputs to use for image generation.\n        ",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  real_cfg_scale: z
    .optional(
      z.number().gte(0).lte(5).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  use_cfg_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            Uses CFG-zero init sampling as in https://arxiv.org/abs/2503.18886.\n        ",
      }),
    )
    .default(false),
  fill_image: z.optional(zImageFillInput),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  sigma_schedule: z.optional(
    z.enum(["sgm_uniform"]).register(z.globalRegistry, {
      description: "Sigmas schedule for the denoising process.",
    }),
  ),
  reference_end: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            The percentage of the total timesteps when the reference guidance is to be ended.\n        ",
      }),
    )
    .default(1),
  reference_strength: z
    .optional(
      z.number().gte(-3).lte(3).register(z.globalRegistry, {
        description:
          "Strength of reference_only generation. Only used if a reference image is provided.",
      }),
    )
    .default(0.65),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  nag_scale: z
    .optional(
      z.number().lte(10).register(z.globalRegistry, {
        description:
          "\n            The scale for NAG. Higher values will result in a image that is more distant\n            to the negative prompt.\n        ",
      }),
    )
    .default(3),
  reference_image_url: z.optional(z.union([z.string(), z.string()])),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  controlnet_unions: z
    .optional(
      z.array(zControlNetUnion).register(z.globalRegistry, {
        description:
          "\n            The controlnet unions to use for the image generation. Only one controlnet is supported at the moment.\n        ",
      }),
    )
    .default([]),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            Negative prompt to steer the image generation away from unwanted features.\n            By default, we will be using NAG for processing the negative prompt.\n        ",
      }),
    )
    .default(""),
  nag_tau: z
    .optional(
      z.number().register(z.globalRegistry, {
        description:
          "\n            The tau for NAG. Controls the normalization of the hidden state.\n            Higher values will result in a less aggressive normalization,\n            but may also lead to unexpected changes with respect to the original image.\n            Not recommended to change this value.\n        ",
      }),
    )
    .default(2.5),
  change_map_image_url: z.union([z.string(), z.string()]),
  num_images: z
    .optional(
      z.int().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "The number of images to generate. This is always set to 1 for streaming output.",
      }),
    )
    .default(1),
  use_beta_schedule: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Specifies whether beta sigmas ought to be used.",
      }),
    )
    .default(false),
  ip_adapters: z
    .optional(
      z.array(zIpAdapter).register(z.globalRegistry, {
        description:
          "\n        IP-Adapter to use for image generation.\n        ",
      }),
    )
    .default([]),
  base_shift: z
    .optional(
      z.number().gte(0.01).lte(5).register(z.globalRegistry, {
        description: "Base shift for the scheduled timesteps",
      }),
    )
    .default(0.5),
  nag_alpha: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description:
          "\n            The alpha value for NAG. This value is used as a final weighting\n            factor for steering the normalized guidance (positive and negative prompts)\n            in the direction of the positive prompt. Higher values will result in less\n            steering on the normalized guidance where lower values will result in\n            considering the positive prompt guidance more.\n        ",
      }),
    )
    .default(0.25),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "The strength to use for differential diffusion. 1.0 is completely remakes the image while 0.0 preserves the original.",
      }),
    )
    .default(0.85),
  max_shift: z
    .optional(
      z.number().gte(0.01).lte(5).register(z.globalRegistry, {
        description: "Max shift for the scheduled timesteps",
      }),
    )
    .default(1.15),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  controlnets: z
    .optional(
      z.array(zControlNet).register(z.globalRegistry, {
        description:
          "\n            The controlnets to use for the image generation. Only one controlnet is supported at the moment.\n        ",
      }),
    )
    .default([]),
  reference_start: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            The percentage of the total timesteps when the reference guidance is to bestarted.\n        ",
      }),
    )
    .default(0),
  use_real_cfg: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            Uses classical CFG as in SD1.5, SDXL, etc. Increases generation times and price when set to be true.\n            If using XLabs IP-Adapter v1, this will be turned on!.\n        ",
      }),
    )
    .default(false),
});

/**
 * Output
 */
export const zFluxGeneralImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * ImageToImageInput
 */
export const zFluxGeneralImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  nag_end: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description:
          "\n            The proportion of steps to apply NAG. After the specified proportion\n            of steps has been iterated, the remaining steps will use original\n            attention processors in FLUX.\n        ",
      }),
    )
    .default(0.25),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  control_loras: z
    .optional(
      z.array(zControlLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation which use a control image. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  scheduler: z.optional(
    z.enum(["euler", "dpmpp_2m"]).register(z.globalRegistry, {
      description: "Scheduler for the denoising process.",
    }),
  ),
  easycontrols: z
    .optional(
      z.array(zEasyControlWeight).register(z.globalRegistry, {
        description:
          "\n        EasyControl Inputs to use for image generation.\n        ",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  real_cfg_scale: z
    .optional(
      z.number().gte(0).lte(5).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  use_cfg_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            Uses CFG-zero init sampling as in https://arxiv.org/abs/2503.18886.\n        ",
      }),
    )
    .default(false),
  fill_image: z.optional(zImageFillInput),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  sigma_schedule: z.optional(
    z.enum(["sgm_uniform"]).register(z.globalRegistry, {
      description: "Sigmas schedule for the denoising process.",
    }),
  ),
  reference_end: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            The percentage of the total timesteps when the reference guidance is to be ended.\n        ",
      }),
    )
    .default(1),
  reference_strength: z
    .optional(
      z.number().gte(-3).lte(3).register(z.globalRegistry, {
        description:
          "Strength of reference_only generation. Only used if a reference image is provided.",
      }),
    )
    .default(0.65),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  nag_scale: z
    .optional(
      z.number().lte(10).register(z.globalRegistry, {
        description:
          "\n            The scale for NAG. Higher values will result in a image that is more distant\n            to the negative prompt.\n        ",
      }),
    )
    .default(3),
  reference_image_url: z.optional(z.union([z.string(), z.string()])),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  controlnet_unions: z
    .optional(
      z.array(zControlNetUnion).register(z.globalRegistry, {
        description:
          "\n            The controlnet unions to use for the image generation. Only one controlnet is supported at the moment.\n        ",
      }),
    )
    .default([]),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            Negative prompt to steer the image generation away from unwanted features.\n            By default, we will be using NAG for processing the negative prompt.\n        ",
      }),
    )
    .default(""),
  nag_tau: z
    .optional(
      z.number().register(z.globalRegistry, {
        description:
          "\n            The tau for NAG. Controls the normalization of the hidden state.\n            Higher values will result in a less aggressive normalization,\n            but may also lead to unexpected changes with respect to the original image.\n            Not recommended to change this value.\n        ",
      }),
    )
    .default(2.5),
  num_images: z
    .optional(
      z.int().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "The number of images to generate. This is always set to 1 for streaming output.",
      }),
    )
    .default(1),
  use_beta_schedule: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Specifies whether beta sigmas ought to be used.",
      }),
    )
    .default(false),
  ip_adapters: z
    .optional(
      z.array(zIpAdapter).register(z.globalRegistry, {
        description:
          "\n        IP-Adapter to use for image generation.\n        ",
      }),
    )
    .default([]),
  base_shift: z
    .optional(
      z.number().gte(0.01).lte(5).register(z.globalRegistry, {
        description: "Base shift for the scheduled timesteps",
      }),
    )
    .default(0.5),
  nag_alpha: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description:
          "\n            The alpha value for NAG. This value is used as a final weighting\n            factor for steering the normalized guidance (positive and negative prompts)\n            in the direction of the positive prompt. Higher values will result in less\n            steering on the normalized guidance where lower values will result in\n            considering the positive prompt guidance more.\n        ",
      }),
    )
    .default(0.25),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.",
      }),
    )
    .default(0.85),
  max_shift: z
    .optional(
      z.number().gte(0.01).lte(5).register(z.globalRegistry, {
        description: "Max shift for the scheduled timesteps",
      }),
    )
    .default(1.15),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  controlnets: z
    .optional(
      z.array(zControlNet).register(z.globalRegistry, {
        description:
          "\n            The controlnets to use for the image generation. Only one controlnet is supported at the moment.\n        ",
      }),
    )
    .default([]),
  reference_start: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            The percentage of the total timesteps when the reference guidance is to bestarted.\n        ",
      }),
    )
    .default(0),
  use_real_cfg: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            Uses classical CFG as in SD1.5, SDXL, etc. Increases generation times and price when set to be true.\n            If using XLabs IP-Adapter v1, this will be turned on!.\n        ",
      }),
    )
    .default(false),
});

/**
 * Output
 */
export const zFluxGeneralInpaintingOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * InpaintInput
 */
export const zFluxGeneralInpaintingInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  nag_end: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description:
          "\n            The proportion of steps to apply NAG. After the specified proportion\n            of steps has been iterated, the remaining steps will use original\n            attention processors in FLUX.\n        ",
      }),
    )
    .default(0.25),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  control_loras: z
    .optional(
      z.array(zControlLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation which use a control image. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  scheduler: z.optional(
    z.enum(["euler", "dpmpp_2m"]).register(z.globalRegistry, {
      description: "Scheduler for the denoising process.",
    }),
  ),
  easycontrols: z
    .optional(
      z.array(zEasyControlWeight).register(z.globalRegistry, {
        description:
          "\n        EasyControl Inputs to use for image generation.\n        ",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  real_cfg_scale: z
    .optional(
      z.number().gte(0).lte(5).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  use_cfg_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            Uses CFG-zero init sampling as in https://arxiv.org/abs/2503.18886.\n        ",
      }),
    )
    .default(false),
  fill_image: z.optional(zImageFillInput),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  sigma_schedule: z.optional(
    z.enum(["sgm_uniform"]).register(z.globalRegistry, {
      description: "Sigmas schedule for the denoising process.",
    }),
  ),
  reference_end: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            The percentage of the total timesteps when the reference guidance is to be ended.\n        ",
      }),
    )
    .default(1),
  reference_strength: z
    .optional(
      z.number().gte(-3).lte(3).register(z.globalRegistry, {
        description:
          "Strength of reference_only generation. Only used if a reference image is provided.",
      }),
    )
    .default(0.65),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  mask_url: z.union([z.string(), z.string()]),
  image_url: z.union([z.string(), z.string()]),
  nag_scale: z
    .optional(
      z.number().lte(10).register(z.globalRegistry, {
        description:
          "\n            The scale for NAG. Higher values will result in a image that is more distant\n            to the negative prompt.\n        ",
      }),
    )
    .default(3),
  reference_image_url: z.optional(z.union([z.string(), z.string()])),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  controlnet_unions: z
    .optional(
      z.array(zControlNetUnion).register(z.globalRegistry, {
        description:
          "\n            The controlnet unions to use for the image generation. Only one controlnet is supported at the moment.\n        ",
      }),
    )
    .default([]),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            Negative prompt to steer the image generation away from unwanted features.\n            By default, we will be using NAG for processing the negative prompt.\n        ",
      }),
    )
    .default(""),
  nag_tau: z
    .optional(
      z.number().register(z.globalRegistry, {
        description:
          "\n            The tau for NAG. Controls the normalization of the hidden state.\n            Higher values will result in a less aggressive normalization,\n            but may also lead to unexpected changes with respect to the original image.\n            Not recommended to change this value.\n        ",
      }),
    )
    .default(2.5),
  num_images: z
    .optional(
      z.int().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "The number of images to generate. This is always set to 1 for streaming output.",
      }),
    )
    .default(1),
  use_beta_schedule: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Specifies whether beta sigmas ought to be used.",
      }),
    )
    .default(false),
  ip_adapters: z
    .optional(
      z.array(zIpAdapter).register(z.globalRegistry, {
        description:
          "\n        IP-Adapter to use for image generation.\n        ",
      }),
    )
    .default([]),
  base_shift: z
    .optional(
      z.number().gte(0.01).lte(5).register(z.globalRegistry, {
        description: "Base shift for the scheduled timesteps",
      }),
    )
    .default(0.5),
  nag_alpha: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description:
          "\n            The alpha value for NAG. This value is used as a final weighting\n            factor for steering the normalized guidance (positive and negative prompts)\n            in the direction of the positive prompt. Higher values will result in less\n            steering on the normalized guidance where lower values will result in\n            considering the positive prompt guidance more.\n        ",
      }),
    )
    .default(0.25),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.",
      }),
    )
    .default(0.85),
  max_shift: z
    .optional(
      z.number().gte(0.01).lte(5).register(z.globalRegistry, {
        description: "Max shift for the scheduled timesteps",
      }),
    )
    .default(1.15),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  controlnets: z
    .optional(
      z.array(zControlNet).register(z.globalRegistry, {
        description:
          "\n            The controlnets to use for the image generation. Only one controlnet is supported at the moment.\n        ",
      }),
    )
    .default([]),
  reference_start: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            The percentage of the total timesteps when the reference guidance is to bestarted.\n        ",
      }),
    )
    .default(0),
  use_real_cfg: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            Uses classical CFG as in SD1.5, SDXL, etc. Increases generation times and price when set to be true.\n            If using XLabs IP-Adapter v1, this will be turned on!.\n        ",
      }),
    )
    .default(false),
});

/**
 * SAM2ImageOutput
 */
export const zSam2ImageOutput = z.object({
  image: zImage,
});

/**
 * BoxPrompt
 */
export const zBoxPromptType2 = z.object({
  y_min: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Y Min Coordinate of the box",
      }),
    )
    .default(0),
  frame_index: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "The frame index to interact with.",
      }),
    )
    .default(0),
  x_max: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "X Max Coordinate of the prompt",
      }),
    )
    .default(0),
  x_min: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "X Min Coordinate of the box",
      }),
    )
    .default(0),
  y_max: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Y Max Coordinate of the prompt",
      }),
    )
    .default(0),
});

/**
 * PointPrompt
 */
export const zPointPromptType2 = z.object({
  y: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Y Coordinate of the prompt",
      }),
    )
    .default(350),
  label: z.optional(
    z.union([z.literal(0), z.literal(1)]).register(z.globalRegistry, {
      description: "Label of the prompt. 1 for foreground, 0 for background",
    }),
  ),
  frame_index: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "The frame index to interact with.",
      }),
    )
    .default(0),
  x: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "X Coordinate of the prompt",
      }),
    )
    .default(305),
});

/**
 * SAM2ImageInput
 */
export const zSam2ImageInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  prompts: z
    .optional(
      z.array(zPointPromptType2).register(z.globalRegistry, {
        description: "List of prompts to segment the image",
      }),
    )
    .default([]),
  box_prompts: z
    .optional(
      z.array(zBoxPromptType2).register(z.globalRegistry, {
        description: "Coordinates for boxes",
      }),
    )
    .default([]),
  apply_mask: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Apply the mask on the image.",
      }),
    )
    .default(false),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * PiDiOutput
 */
export const zImagePreprocessorsPidiOutput = z.object({
  image: zImageType3,
});

/**
 * PiDiInput
 */
export const zImagePreprocessorsPidiInput = z.object({
  safe: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use the safe version of the Pidi detector",
      }),
    )
    .default(false),
  apply_filter: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to apply the filter to the image.",
      }),
    )
    .default(false),
  scribble: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use the scribble version of the Pidi detector",
      }),
    )
    .default(false),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * ZoeOutput
 */
export const zImagePreprocessorsZoeOutput = z.object({
  image: zImageType3,
});

/**
 * ZoeInput
 */
export const zImagePreprocessorsZoeInput = z.object({
  image_url: z.union([z.string(), z.string()]),
});

/**
 * LineartOutput
 */
export const zImagePreprocessorsLineartOutput = z.object({
  image: zImageType3,
});

/**
 * LineartInput
 */
export const zImagePreprocessorsLineartInput = z.object({
  coarse: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use the coarse model",
      }),
    )
    .default(false),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * TeeDOutput
 */
export const zImagePreprocessorsTeedOutput = z.object({
  image: zImageType3,
});

/**
 * TeeDInput
 */
export const zImagePreprocessorsTeedInput = z.object({
  image_url: z.union([z.string(), z.string()]),
});

/**
 * MiDaSOutput
 */
export const zImagePreprocessorsMidasOutput = z.object({
  normal_map: zImageType3,
  depth_map: zImageType3,
});

/**
 * MiDaSInput
 */
export const zImagePreprocessorsMidasInput = z.object({
  a: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: "A parameter for the MiDaS detector",
      }),
    )
    .default(6.283185307179586),
  background_threshold: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: "Background threshold for the MiDaS detector",
      }),
    )
    .default(0.1),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * SamOutput
 */
export const zImagePreprocessorsSamOutput = z.object({
  image: zImageType3,
});

/**
 * SamInput
 */
export const zImagePreprocessorsSamInput = z.object({
  image_url: z.union([z.string(), z.string()]),
});

/**
 * MLSDOutput
 */
export const zImagePreprocessorsMlsdOutput = z.object({
  image: zImageType3,
});

/**
 * MLSDInput
 */
export const zImagePreprocessorsMlsdInput = z.object({
  distance_threshold: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: "Distance threshold for the MLSD detector",
      }),
    )
    .default(0.1),
  score_threshold: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: "Score threshold for the MLSD detector",
      }),
    )
    .default(0.1),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * ScribbleOutput
 */
export const zImagePreprocessorsScribbleOutput = z.object({
  image: zImageType3,
});

/**
 * ScribbleInput
 */
export const zImagePreprocessorsScribbleInput = z.object({
  model: z.optional(
    z.enum(["HED", "PiDi"]).register(z.globalRegistry, {
      description: "The model to use for the Scribble detector",
    }),
  ),
  safe: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use the safe version of the Scribble detector",
      }),
    )
    .default(false),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * DepthAnythingV2Output
 */
export const zImagePreprocessorsDepthAnythingV2Output = z.object({
  image: zImageType3,
});

/**
 * DepthAnythingV2Input
 */
export const zImagePreprocessorsDepthAnythingV2Input = z.object({
  image_url: z.union([z.string(), z.string()]),
});

/**
 * HEDOutput
 */
export const zImagePreprocessorsHedOutput = z.object({
  image: zImageType3,
});

/**
 * HEDInput
 */
export const zImagePreprocessorsHedInput = z.object({
  safe: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use the safe version of the HED detector",
      }),
    )
    .default(false),
  scribble: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use the scribble version of the HED detector",
      }),
    )
    .default(false),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * Output
 */
export const zFluxGeneralRfInversionOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * RFInversionInput
 */
export const zFluxGeneralRfInversionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to edit the image with",
  }),
  nag_end: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description:
          "\n            The proportion of steps to apply NAG. After the specified proportion\n            of steps has been iterated, the remaining steps will use original\n            attention processors in FLUX.\n        ",
      }),
    )
    .default(0.25),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
      z.null(),
    ]),
  ),
  control_loras: z
    .optional(
      z.array(zControlLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation which use a control image. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  controller_guidance_reverse: z
    .optional(
      z.number().gte(0.01).lte(3).register(z.globalRegistry, {
        description:
          "The controller guidance (eta) used in the denoising process.Using values closer to 1 will result in an image closer to input.",
      }),
    )
    .default(0.75),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  reverse_guidance_start: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Timestep to start guidance during reverse process.",
      }),
    )
    .default(0),
  easycontrols: z
    .optional(
      z.array(zEasyControlWeight).register(z.globalRegistry, {
        description:
          "\n        EasyControl Inputs to use for image generation.\n        ",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  scheduler: z.optional(
    z.enum(["euler", "dpmpp_2m"]).register(z.globalRegistry, {
      description: "Scheduler for the denoising process.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  use_cfg_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            Uses CFG-zero init sampling as in https://arxiv.org/abs/2503.18886.\n        ",
      }),
    )
    .default(false),
  reference_strength: z
    .optional(
      z.number().gte(-3).lte(3).register(z.globalRegistry, {
        description:
          "Strength of reference_only generation. Only used if a reference image is provided.",
      }),
    )
    .default(0.65),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  sigma_schedule: z.optional(
    z.enum(["sgm_uniform"]).register(z.globalRegistry, {
      description: "Sigmas schedule for the denoising process.",
    }),
  ),
  reference_end: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            The percentage of the total timesteps when the reference guidance is to be ended.\n        ",
      }),
    )
    .default(1),
  controller_guidance_forward: z
    .optional(
      z.number().gte(0.01).lte(3).register(z.globalRegistry, {
        description:
          "The controller guidance (gamma) used in the creation of structured noise.",
      }),
    )
    .default(0.6),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  fill_image: z.optional(zImageFillInput),
  nag_scale: z
    .optional(
      z.number().lte(10).register(z.globalRegistry, {
        description:
          "\n            The scale for NAG. Higher values will result in a image that is more distant\n            to the negative prompt.\n        ",
      }),
    )
    .default(3),
  reverse_guidance_schedule: z.optional(
    z
      .enum(["constant", "linear_increase", "linear_decrease"])
      .register(z.globalRegistry, {
        description: "Scheduler for applying reverse guidance.",
      }),
  ),
  reference_image_url: z.optional(z.union([z.string(), z.string()])),
  reverse_guidance_end: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Timestep to stop guidance during reverse process.",
      }),
    )
    .default(8),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  controlnet_unions: z
    .optional(
      z.array(zControlNetUnion).register(z.globalRegistry, {
        description:
          "\n            The controlnet unions to use for the image generation. Only one controlnet is supported at the moment.\n        ",
      }),
    )
    .default([]),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            Negative prompt to steer the image generation away from unwanted features.\n            By default, we will be using NAG for processing the negative prompt.\n        ",
      }),
    )
    .default(""),
  nag_tau: z
    .optional(
      z.number().register(z.globalRegistry, {
        description:
          "\n            The tau for NAG. Controls the normalization of the hidden state.\n            Higher values will result in a less aggressive normalization,\n            but may also lead to unexpected changes with respect to the original image.\n            Not recommended to change this value.\n        ",
      }),
    )
    .default(2.5),
  num_images: z
    .optional(
      z.int().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "The number of images to generate. This is always set to 1 for streaming output.",
      }),
    )
    .default(1),
  use_beta_schedule: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Specifies whether beta sigmas ought to be used.",
      }),
    )
    .default(false),
  nag_alpha: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description:
          "\n            The alpha value for NAG. This value is used as a final weighting\n            factor for steering the normalized guidance (positive and negative prompts)\n            in the direction of the positive prompt. Higher values will result in less\n            steering on the normalized guidance where lower values will result in\n            considering the positive prompt guidance more.\n        ",
      }),
    )
    .default(0.25),
  base_shift: z
    .optional(
      z.number().gte(0.01).lte(5).register(z.globalRegistry, {
        description: "Base shift for the scheduled timesteps",
      }),
    )
    .default(0.5),
  max_shift: z
    .optional(
      z.number().gte(0.01).lte(5).register(z.globalRegistry, {
        description: "Max shift for the scheduled timesteps",
      }),
    )
    .default(1.15),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  reference_start: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            The percentage of the total timesteps when the reference guidance is to bestarted.\n        ",
      }),
    )
    .default(0),
  controlnets: z
    .optional(
      z.array(zControlNet).register(z.globalRegistry, {
        description:
          "\n            The controlnets to use for the image generation. Only one controlnet is supported at the moment.\n        ",
      }),
    )
    .default([]),
});

/**
 * LivePortraitImageOutput
 */
export const zLivePortraitImageOutput = z.object({
  image: zImage,
});

/**
 * LivePortraitImageInput
 */
export const zLivePortraitImageInput = z.object({
  smile: z
    .optional(
      z.number().gte(-2).lte(2).register(z.globalRegistry, {
        description: "Amount to smile",
      }),
    )
    .default(0),
  eyebrow: z
    .optional(
      z.number().gte(-30).lte(30).register(z.globalRegistry, {
        description: "Amount to raise or lower eyebrows",
      }),
    )
    .default(0),
  rotate_roll: z
    .optional(
      z.number().gte(-45).lte(45).register(z.globalRegistry, {
        description: "Amount to rotate the face in roll",
      }),
    )
    .default(0),
  wink: z
    .optional(
      z.number().gte(0).lte(25).register(z.globalRegistry, {
        description: "Amount to wink",
      }),
    )
    .default(0),
  rotate_pitch: z
    .optional(
      z.number().gte(-45).lte(45).register(z.globalRegistry, {
        description: "Amount to rotate the face in pitch",
      }),
    )
    .default(0),
  blink: z
    .optional(
      z.number().gte(-30).lte(30).register(z.globalRegistry, {
        description: "Amount to blink the eyes",
      }),
    )
    .default(0),
  dsize: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Size of the output image.",
      }),
    )
    .default(512),
  vy_ratio: z
    .optional(
      z.number().register(z.globalRegistry, {
        description:
          "Vertical offset ratio for face crop. Positive values move up, negative values move down.",
      }),
    )
    .default(-0.125),
  scale: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: "Scaling factor for the face crop.",
      }),
    )
    .default(2.3),
  pupil_x: z
    .optional(
      z.number().gte(-45).lte(45).register(z.globalRegistry, {
        description: "Amount to move pupils horizontally",
      }),
    )
    .default(0),
  flag_pasteback: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to paste-back/stitch the animated face cropping from the face-cropping space to the original image space.",
      }),
    )
    .default(true),
  eee: z
    .optional(
      z.number().gte(-40).lte(40).register(z.globalRegistry, {
        description: "Amount to shape mouth in 'eee' position",
      }),
    )
    .default(0),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n        Whether to enable the safety checker. If enabled, the model will check if the input image contains a face before processing it.\n        The safety checker will process the input image\n        ",
      }),
    )
    .default(false),
  vx_ratio: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: "Horizontal offset ratio for face crop.",
      }),
    )
    .default(0),
  pupil_y: z
    .optional(
      z.number().gte(-45).lte(45).register(z.globalRegistry, {
        description: "Amount to move pupils vertically",
      }),
    )
    .default(0),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "Output format",
    }),
  ),
  rotate_yaw: z
    .optional(
      z.number().gte(-45).lte(45).register(z.globalRegistry, {
        description: "Amount to rotate the face in yaw",
      }),
    )
    .default(0),
  flag_do_rot: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to conduct the rotation when flag_do_crop is True.",
      }),
    )
    .default(true),
  woo: z
    .optional(
      z.number().gte(-100).lte(100).register(z.globalRegistry, {
        description: "Amount to shape mouth in 'woo' position",
      }),
    )
    .default(0),
  aaa: z
    .optional(
      z.number().gte(-200).lte(200).register(z.globalRegistry, {
        description: "Amount to open mouth in 'aaa' shape",
      }),
    )
    .default(0),
  image_url: z.union([z.string(), z.string()]),
  flag_do_crop: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to crop the source portrait to the face-cropping space.",
      }),
    )
    .default(true),
  flag_lip_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to set the lip to closed state before animation. Only takes effect when flag_eye_retargeting and flag_lip_retargeting are False.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zBirefnetV2Output = z.object({
  image: zImageFile,
  mask_image: z.optional(zImageFile),
});

/**
 * InputV2
 */
export const zBirefnetV2Input = z.object({
  operating_resolution: z.optional(
    z.enum(["1024x1024", "2048x2048", "2304x2304"]).register(z.globalRegistry, {
      description:
        "The resolution to operate on. The higher the resolution, the more accurate the output will be for high res input images. The '2304x2304' option is only available for the 'General Use (Dynamic)' model.",
    }),
  ),
  output_format: z.optional(
    z.enum(["webp", "png", "gif"]).register(z.globalRegistry, {
      description: "The format of the output image",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  model: z.optional(
    z
      .enum([
        "General Use (Light)",
        "General Use (Light 2K)",
        "General Use (Heavy)",
        "Matting",
        "Portrait",
        "General Use (Dynamic)",
      ])
      .register(z.globalRegistry, {
        description:
          "\n            Model to use for background removal.\n            The 'General Use (Light)' model is the original model used in the BiRefNet repository.\n            The 'General Use (Light 2K)' model is the original model used in the BiRefNet repository but trained with 2K images.\n            The 'General Use (Heavy)' model is a slower but more accurate model.\n            The 'Matting' model is a model trained specifically for matting images.\n            The 'Portrait' model is a model trained specifically for portrait images.\n            The 'General Use (Dynamic)' model supports dynamic resolutions from 256x256 to 2304x2304.\n            The 'General Use (Light)' model is recommended for most use cases.\n\n            The corresponding models are as follows:\n            - 'General Use (Light)': BiRefNet\n            - 'General Use (Light 2K)': BiRefNet_lite-2K\n            - 'General Use (Heavy)': BiRefNet_lite\n            - 'Matting': BiRefNet-matting\n            - 'Portrait': BiRefNet-portrait\n            - 'General Use (Dynamic)': BiRefNet_dynamic\n        ",
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  output_mask: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to output the mask used to remove the background",
      }),
    )
    .default(false),
  refine_foreground: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to refine the foreground using the estimated mask",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zFluxPulidOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * FluxPulidInput
 */
export const zFluxPulidInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  id_weight: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The weight of the ID loss.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  start_step: z
    .optional(
      z.int().gte(0).lte(50).register(z.globalRegistry, {
        description: "The number of steps to start the CFG from.",
      }),
    )
    .default(0),
  reference_image_url: z.union([z.string(), z.string()]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  max_sequence_length: z.optional(
    z.enum(["128", "256", "512"]).register(z.globalRegistry, {
      description: "The maximum sequence length for the model.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(4),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(20),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The prompt to generate an image from.",
      }),
    )
    .default(""),
  true_cfg: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: "The weight of the CFG loss.",
      }),
    )
    .default(1),
});

/**
 * Output
 */
export const zFluxDifferentialDiffusionOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * DiffInput
 */
export const zFluxDifferentialDiffusionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "The strength to use for image-to-image. 1.0 is completely remakes the image while 0.0 preserves the original.",
      }),
    )
    .default(0.85),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  change_map_image_url: z.union([z.string(), z.string()]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
});

/**
 * Output
 */
export const zIclightV2Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseInput
 */
export const zIclightV2Input = z.object({
  initial_latent: z.optional(
    z
      .enum(["None", "Left", "Right", "Top", "Bottom"])
      .register(z.globalRegistry, {
        description:
          "\n            Provide lighting conditions for the model\n        ",
      }),
  ),
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  background_threshold: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "Threshold for the background removal algorithm. A high threshold will produce sharper masks. Note: This parameter is currently deprecated and has no effect on the output.",
      }),
    )
    .default(0.67),
  mask_image_url: z.optional(z.union([z.string(), z.string()])),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(5),
  lowres_denoise: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description: "Strength for low-resolution pass.",
      }),
    )
    .default(0.98),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Negative Prompt for the image",
      }),
    )
    .default(""),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  hr_downscale: z.optional(z.number().gte(0.01).lte(1)).default(0.5),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  highres_denoise: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "Strength for high-resolution pass. Only used if enable_hr_fix is True.",
      }),
    )
    .default(0.95),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enable_hr_fix: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Use HR fix",
      }),
    )
    .default(false),
  cfg: z
    .optional(
      z.number().gte(0.01).lte(5).register(z.globalRegistry, {
        description:
          "The real classifier-free-guidance scale for the generation.",
      }),
    )
    .default(1),
});

/**
 * Output
 */
export const zKolorsImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * KolorsImg2ImgInput
 */
export const zKolorsImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and\n            uploaded before returning the response. This will increase the latency of\n            the function but it allows you to get the image directly in the response\n            without going through the CDN.\n        ",
      }),
    )
    .default(false),
  scheduler: z.optional(
    z
      .enum([
        "EulerDiscreteScheduler",
        "EulerAncestralDiscreteScheduler",
        "DPMSolverMultistepScheduler",
        "DPMSolverMultistepScheduler_SDE_karras",
        "UniPCMultistepScheduler",
        "DEISMultistepScheduler",
      ])
      .register(z.globalRegistry, {
        description: "The scheduler to use for the model.",
      }),
  ),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "The strength to use for image-to-image. 1.0 is completely remakes the image while 0.0 preserves the original.",
      }),
    )
    .default(0.85),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show\n            you.\n        ",
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(150).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(50),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Seed",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small\n            details (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Enable safety checker.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zFluxDevReduxOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseReduxInput
 */
export const zFluxDevReduxInput = z.object({
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
});

/**
 * Output
 */
export const zFluxProV1FillOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z
    .array(zRegistryImageFastSdxlModelsImage)
    .register(z.globalRegistry, {
      description: "The generated image files info.",
    }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * FluxProFillInput
 */
export const zFluxProV1FillInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to fill the masked part of the image.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.",
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  mask_url: z.union([z.string(), z.string()]),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enhance the prompt for better results.",
      }),
    )
    .default(false),
});

/**
 * Output
 */
export const zFluxProV11UltraReduxOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z
    .array(zRegistryImageFastSdxlModelsImage)
    .register(z.globalRegistry, {
      description: "The generated image files info.",
    }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * FluxProUltraTextToImageInputRedux
 */
export const zFluxProV11UltraReduxInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The prompt to generate an image from.",
      }),
    )
    .default(""),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z.union([
      z.enum([
        "21:9",
        "16:9",
        "4:3",
        "3:2",
        "1:1",
        "2:3",
        "3:4",
        "9:16",
        "9:21",
      ]),
      z.string(),
    ]),
  ),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enhance the prompt for better results.",
      }),
    )
    .default(false),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.",
    }),
  ),
  image_prompt_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The strength of the image prompt, between 0 and 1.",
      }),
    )
    .default(0.1),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  raw: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Generate less processed, more natural-looking images.",
      }),
    )
    .default(false),
});

/**
 * Output
 */
export const zFluxLoraDepthOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * DepthInput
 */
export const zFluxLoraDepthInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "The number of images to generate. This is always set to 1 for streaming output.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
});

/**
 * Output
 */
export const zFluxProV11ReduxOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z
    .array(zRegistryImageFastSdxlModelsImage)
    .register(z.globalRegistry, {
      description: "The generated image files info.",
    }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * FluxProRedux
 */
export const zFluxProV11ReduxInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The prompt to generate an image from.",
      }),
    )
    .default(""),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enhance the prompt for better results.",
      }),
    )
    .default(false),
});

/**
 * Output
 */
export const zFluxSchnellReduxOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * SchnellReduxInput
 */
export const zFluxSchnellReduxInput = z.object({
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(12).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(4),
});

/**
 * Output
 */
export const zIdeogramV2TurboRemixOutput = z.object({
  images: z.array(zFileType2),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for the random number generator",
  }),
});

/**
 * RemixImageInput
 */
export const zIdeogramV2TurboRemixInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to remix the image with",
  }),
  aspect_ratio: z.optional(
    z
      .enum([
        "10:16",
        "16:10",
        "9:16",
        "16:9",
        "4:3",
        "3:4",
        "1:1",
        "1:3",
        "3:1",
        "3:2",
        "2:3",
      ])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image",
      }),
  ),
  style: z.optional(
    z
      .enum(["auto", "general", "realistic", "design", "render_3D", "anime"])
      .register(z.globalRegistry, {
        description: "The style of the generated image",
      }),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to expand the prompt with MagicPrompt functionality.",
      }),
    )
    .default(true),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description: "Strength of the input image in the remix",
      }),
    )
    .default(0.8),
  seed: z.optional(z.union([z.int(), z.unknown()])),
});

/**
 * Output
 */
export const zIdeogramV2TurboEditOutput = z.object({
  images: z.array(zFileType2),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for the random number generator",
  }),
});

/**
 * EditImageInput
 */
export const zIdeogramV2TurboEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to fill the masked part of the image.",
  }),
  style: z.optional(
    z
      .enum(["auto", "general", "realistic", "design", "render_3D", "anime"])
      .register(z.globalRegistry, {
        description: "The style of the generated image",
      }),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to expand the prompt with MagicPrompt functionality.",
      }),
    )
    .default(true),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  mask_url: z.union([z.string(), z.string()]),
});

/**
 * Output
 */
export const zIdeogramV2RemixOutput = z.object({
  images: z.array(zFileType2),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for the random number generator",
  }),
});

/**
 * RemixImageInput
 */
export const zIdeogramV2RemixInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to remix the image with",
  }),
  aspect_ratio: z.optional(
    z
      .enum([
        "10:16",
        "16:10",
        "9:16",
        "16:9",
        "4:3",
        "3:4",
        "1:1",
        "1:3",
        "3:1",
        "3:2",
        "2:3",
      ])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image",
      }),
  ),
  style: z.optional(
    z
      .enum(["auto", "general", "realistic", "design", "render_3D", "anime"])
      .register(z.globalRegistry, {
        description: "The style of the generated image",
      }),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to expand the prompt with MagicPrompt functionality.",
      }),
    )
    .default(true),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description: "Strength of the input image in the remix",
      }),
    )
    .default(0.8),
  seed: z.optional(z.union([z.int(), z.unknown()])),
});

/**
 * Output
 */
export const zIdeogramV2EditOutput = z.object({
  images: z.array(zFileType2),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for the random number generator",
  }),
});

/**
 * EditImageInput
 */
export const zIdeogramV2EditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to fill the masked part of the image.",
  }),
  style: z.optional(
    z
      .enum(["auto", "general", "realistic", "design", "render_3D", "anime"])
      .register(z.globalRegistry, {
        description: "The style of the generated image",
      }),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to expand the prompt with MagicPrompt functionality.",
      }),
    )
    .default(true),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  mask_url: z.union([z.string(), z.string()]),
});

/**
 * VTONOutput
 */
export const zLeffaVirtualTryonOutput = z.object({
  image: zImage,
  seed: z.int().register(z.globalRegistry, {
    description: "The seed for the inference.",
  }),
  has_nsfw_concepts: z.boolean().register(z.globalRegistry, {
    description: "Whether the image contains NSFW concepts.",
  }),
});

/**
 * VTONInput
 */
export const zLeffaVirtualTryonInput = z.object({
  garment_image_url: z.union([z.string(), z.string()]),
  human_image_url: z.union([z.string(), z.string()]),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  garment_type: z
    .enum(["upper_body", "lower_body", "dresses"])
    .register(z.globalRegistry, {
      description: "The type of the garment used for virtual try-on.",
    }),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your input when generating the image.\n        ",
      }),
    )
    .default(2.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(50),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same input given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * PoseTransferOutput
 */
export const zLeffaPoseTransferOutput = z.object({
  image: zImage,
  seed: z.int().register(z.globalRegistry, {
    description: "The seed for the inference.",
  }),
  has_nsfw_concepts: z.boolean().register(z.globalRegistry, {
    description: "Whether the image contains NSFW concepts.",
  }),
});

/**
 * PoseTransferInput
 */
export const zLeffaPoseTransferInput = z.object({
  pose_image_url: z.union([z.string(), z.string()]),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your input when generating the image.\n        ",
      }),
    )
    .default(2.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(50),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same input given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  person_image_url: z.union([z.string(), z.string()]),
});

/**
 * CATVTONOutput
 */
export const zCatVtonOutput = z.object({
  image: zImage,
});

/**
 * CATVTONInput
 */
export const zCatVtonInput = z.object({
  garment_image_url: z.union([z.string(), z.string()]),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  human_image_url: z.union([z.string(), z.string()]),
  cloth_type: z
    .enum(["upper", "lower", "overall", "inner", "outer"])
    .register(z.globalRegistry, {
      description:
        "\n        Type of the Cloth to be tried on.\n\n        Options:\n        upper: Upper body cloth\n        lower: Lower body cloth\n        overall: Full body cloth\n        inner: Inner cloth, like T-shirt inside a jacket\n        outer: Outer cloth, like a jacket over a T-shirt\n        ",
    }),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(2.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same input given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * ImageFillInput
 */
export const zImageFillInputType2 = z.object({
  in_context_fill: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Uses the provided fill image in context with the base image to fill in more faithfully. Will increase price.",
      }),
    )
    .default(false),
  use_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to use the prompt as well in the generation, along with the redux image.",
      }),
    )
    .default(false),
  fill_image_url: z.optional(z.union([z.array(z.string()), z.string()])),
});

/**
 * Output
 */
export const zFluxLoraFillOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * FillInput
 */
export const zFluxLoraFillInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The prompt to generate an image from.",
      }),
    )
    .default(""),
  resize_to_original: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Resizes the image back to the original size. Use when you wish to preserve the exact image size as the originally provided image.",
      }),
    )
    .default(false),
  paste_back: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Specifies whether to paste-back the original image onto to the non-inpainted areas of the output",
      }),
    )
    .default(true),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  guidance_scale: z
    .optional(
      z.number().gte(28).lte(35).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(30),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "The number of images to generate. This is always set to 1 for streaming output.",
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  fill_image: z.optional(zImageFillInputType2),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  mask_url: z.union([z.string(), z.string()]),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * BGReplaceOutput
 */
export const zBriaBackgroundReplaceOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed value used for generation.",
  }),
});

/**
 * BGReplaceInput
 */
export const zBriaBackgroundReplaceInput = z.object({
  prompt: z.optional(
    z.string().min(1).register(z.globalRegistry, {
      description: "The prompt you would like to use to generate images.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "Number of Images to generate.",
      }),
    )
    .default(1),
  ref_image_url: z.optional(z.union([z.string(), z.string()])),
  refine_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to refine prompt",
      }),
    )
    .default(true),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  fast: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use the fast model",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().gte(0).lte(2147483647).register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The negative prompt you would like to use to generate images.",
      }),
    )
    .default(""),
});

/**
 * BGRemoveOutput
 */
export const zBriaBackgroundRemoveOutput = z.object({
  image: zImage,
});

/**
 * BGRemoveInput
 */
export const zBriaBackgroundRemoveInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * ProductShotOutput
 */
export const zBriaProductShotOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated images",
  }),
});

/**
 * ProductShotInput
 */
export const zBriaProductShotInput = z.object({
  ref_image_url: z.optional(z.union([z.string(), z.string()])),
  manual_placement_selection: z.optional(
    z
      .enum([
        "upper_left",
        "upper_right",
        "bottom_left",
        "bottom_right",
        "right_center",
        "left_center",
        "upper_center",
        "bottom_center",
        "center_vertical",
        "center_horizontal",
      ])
      .register(z.globalRegistry, {
        description:
          "If you've selected placement_type=manual_placement, you should use this parameter to specify which placements/positions you would like to use from the list. You can select more than one placement in one request.",
      }),
  ),
  num_results: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "The number of lifestyle product shots you would like to generate. You will get num_results x 10 results when placement_type=automatic and according to the number of required placements x num_results if placement_type=manual_placement.",
      }),
    )
    .default(1),
  padding_values: z.optional(
    z.array(z.int()).register(z.globalRegistry, {
      description:
        "The desired padding in pixels around the product, when using placement_type=manual_padding. The order of the values is [left, right, top, bottom]. For optimal results, the total number of pixels, including padding, should be around 1,000,000. It is recommended to first use the product cutout API, get the cutout and understand the size of the result, and then define the required padding and use the cutout as an input for this API.",
    }),
  ),
  shot_size: z
    .optional(
      z.array(z.int()).register(z.globalRegistry, {
        description:
          "The desired size of the final product shot. For optimal results, the total number of pixels should be around 1,000,000. This parameter is only relevant when placement_type=automatic or placement_type=manual_placement.",
      }),
    )
    .default([1000, 1000]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  placement_type: z.optional(
    z
      .enum(["original", "automatic", "manual_placement", "manual_padding"])
      .register(z.globalRegistry, {
        description:
          "This parameter allows you to control the positioning of the product in the image. Choosing 'original' will preserve the original position of the product in the image. Choosing 'automatic' will generate results with the 10 recommended positions for the product. Choosing 'manual_placement' will allow you to select predefined positions (using the parameter 'manual_placement_selection'). Selecting 'manual_padding' will allow you to control the position and size of the image by defining the desired padding in pixels around the product.",
      }),
  ),
  original_quality: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "This flag is only relevant when placement_type=original. If true, the output image retains the original input image's size; otherwise, the image is scaled to 1 megapixel (1MP) while preserving its aspect ratio.",
      }),
    )
    .default(false),
  fast: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use the fast model",
      }),
    )
    .default(true),
  optimize_description: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to optimize the scene description",
      }),
    )
    .default(true),
  scene_description: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "Text description of the new scene or background for the provided product shot. Bria currently supports prompts in English only, excluding special characters.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * GenFillOutput
 */
export const zBriaGenfillOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "Generated Images",
  }),
});

/**
 * GenFillInput
 */
export const zBriaGenfillInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt you would like to use to generate images.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "Number of Images to generate.",
      }),
    )
    .default(1),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().gte(0).lte(2147483647).register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  mask_url: z.union([z.string(), z.string()]),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The negative prompt you would like to use to generate images.",
      }),
    )
    .default(""),
});

/**
 * ImageExpansionOutput
 */
export const zBriaExpandOutput = z.object({
  image: zImage,
  seed: z.int().register(z.globalRegistry, {
    description: "Seed value used for generation.",
  }),
});

/**
 * ImageExpansionInput
 */
export const zBriaExpandInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Text on which you wish to base the image expansion. This parameter is optional. Bria currently supports prompts in English only, excluding special characters.",
      }),
    )
    .default(""),
  aspect_ratio: z.optional(
    z
      .enum(["1:1", "2:3", "3:2", "3:4", "4:3", "4:5", "5:4", "9:16", "16:9"])
      .register(z.globalRegistry, {
        description:
          "The desired aspect ratio of the final image. Will be used over original_image_size and original_image_location if provided.",
      }),
  ),
  original_image_location: z.optional(
    z.array(z.int()).register(z.globalRegistry, {
      description:
        "The desired location of the original image, inside the full canvas. Provide the location of the upper left corner of the original image. The location can also be outside the canvas (the original image will be cropped). Will be ignored if aspect_ratio is provided.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  original_image_size: z.optional(
    z.array(z.int()).register(z.globalRegistry, {
      description:
        "The desired size of the original image, inside the full canvas. Ensure that the ratio of input image foreground or main subject to the canvas area is greater than 15% to achieve optimal results. Will be ignored if aspect_ratio is provided.",
    }),
  ),
  canvas_size: z.array(z.int()).register(z.globalRegistry, {
    description:
      "The desired size of the final image, after the expansion. should have an area of less than 5000x5000 pixels.",
  }),
  seed: z.optional(
    z.int().gte(0).lte(2147483647).register(z.globalRegistry, {
      description:
        "You can choose whether you want your generated expension to be random or predictable. You can recreate the same result in the future by using the seed value of a result from the response. You can exclude this parameter if you are not interested in recreating your results. This parameter is optional.",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The negative prompt you would like to use to generate images.",
      }),
    )
    .default(""),
});

/**
 * EraserOutput
 */
export const zBriaEraserOutput = z.object({
  image: zImage,
});

/**
 * EraserInput
 */
export const zBriaEraserInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  preserve_alpha: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, attempts to preserve the alpha channel of the input image.\n        ",
      }),
    )
    .default(false),
  mask_url: z.union([z.string(), z.string()]),
  mask_type: z.optional(
    z.enum(["manual", "automatic"]).register(z.globalRegistry, {
      description:
        "You can use this parameter to specify the type of the input mask from the list. 'manual' opttion should be used in cases in which the mask had been generated by a user (e.g. with a brush tool), and 'automatic' mask type should be used when mask had been generated by an algorithm like 'SAM'.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * DetectionOutput
 */
export const zMoondreamNextDetectionOutput = z.object({
  image: z.optional(zImage),
  text_output: z.string().register(z.globalRegistry, {
    description: "Detection results as text",
  }),
});

/**
 * DetectionInput
 */
export const zMoondreamNextDetectionInput = z.object({
  detection_prompt: z.string().register(z.globalRegistry, {
    description: "Text description of what to detect",
  }),
  use_ensemble: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use ensemble for gaze detection",
      }),
    )
    .default(false),
  task_type: z
    .enum(["bbox_detection", "point_detection", "gaze_detection"])
    .register(z.globalRegistry, {
      description: "Type of detection to perform",
    }),
  show_visualization: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to show visualization for detection",
      }),
    )
    .default(true),
  combine_points: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to combine points into a single point for point detection. This has no effect for bbox detection or gaze detection.",
      }),
    )
    .default(false),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * Output
 */
export const zFluxProV1FillFinetunedOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z
    .array(zRegistryImageFastSdxlModelsImage)
    .register(z.globalRegistry, {
      description: "The generated image files info.",
    }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * FluxProFillFinetunedInput
 */
export const zFluxProV1FillFinetunedInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to fill the masked part of the image.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  finetune_strength: z.number().gte(0).lte(2).register(z.globalRegistry, {
    description:
      "\n        Controls finetune influence.\n        Increase this value if your target concept isn't showing up strongly enough.\n        The optimal setting depends on your finetune and prompt\n        ",
  }),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  finetune_id: z.string().register(z.globalRegistry, {
    description: "References your specific model",
  }),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.",
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  mask_url: z.union([z.string(), z.string()]),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enhance the prompt for better results.",
      }),
    )
    .default(false),
});

/**
 * Output
 */
export const zFluxLoraCannyOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * CannyInput
 */
export const zFluxLoraCannyInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(20).lte(40).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(30),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * TryOnOutput
 */
export const zKlingV15KolorsVirtualTryOnOutput = z.object({
  image: zImage,
});

/**
 * TryOnRequest
 */
export const zKlingV15KolorsVirtualTryOnInput = z.object({
  garment_image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If true, the function will return the image in the response.",
      }),
    )
    .default(false),
  human_image_url: z.union([z.string(), z.string()]),
});

/**
 * ConformerOutput
 */
export const zCodeformerOutput = z.object({
  image: zImage,
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * CodeformerInput
 */
export const zCodeformerInput = z.object({
  aligned: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Should faces etc should be aligned.",
      }),
    )
    .default(false),
  image_url: z.union([z.string(), z.string()]),
  upscale_factor: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: "Upscaling factor",
      }),
    )
    .default(2),
  fidelity: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: "Weight of the fidelity factor.",
      }),
    )
    .default(0.5),
  face_upscale: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Should faces be upscaled",
      }),
    )
    .default(true),
  only_center_face: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Should only center face be restored",
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Random seed for reproducible generation.",
    }),
  ),
});

/**
 * UpscaleOutput
 */
export const zIdeogramUpscaleOutput = z.object({
  images: z.array(zFileType2),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for the random number generator",
  }),
});

/**
 * UpscaleImageInput
 */
export const zIdeogramUpscaleInput = z.object({
  prompt: z.optional(z.union([z.string(), z.unknown()])),
  detail: z
    .optional(
      z.int().gte(1).lte(100).register(z.globalRegistry, {
        description: "The detail of the upscaled image",
      }),
    )
    .default(50),
  resemblance: z
    .optional(
      z.int().gte(1).lte(100).register(z.globalRegistry, {
        description:
          "The resemblance of the upscaled image to the original image",
      }),
    )
    .default(50),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to expand the prompt with MagicPrompt functionality.",
      }),
    )
    .default(false),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
});

/**
 * Output
 */
export const zFluxControlLoraDepthImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * ImageToImageInput
 */
export const zFluxControlLoraDepthImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  control_lora_strength: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description: "The strength of the control lora.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.",
      }),
    )
    .default(0.85),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  control_lora_image_url: z.union([z.string(), z.string()]),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * Output
 */
export const zFluxControlLoraCannyImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * ImageToImageInput
 */
export const zFluxControlLoraCannyImageToImageInput = z.object({
  control_lora_strength: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description: "The strength of the control lora.",
      }),
    )
    .default(1),
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.",
      }),
    )
    .default(0.85),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  control_lora_image_url: z.optional(z.union([z.string(), z.string()])),
});

/**
 * Ben2OutputImage
 */
export const zBenV2ImageOutput = z.object({
  image: zImage,
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * Ben2InputImage
 */
export const zBenV2ImageInput = z.object({
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Random seed for reproducible generation.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * FlowEditOutput
 */
export const zFloweditOutput = z.object({
  image: zImage,
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * FlowEditInput
 */
export const zFloweditInput = z.object({
  src_guidance_scale: z
    .optional(
      z.int().gte(0).lte(30).register(z.globalRegistry, {
        description: "Guidance scale for the source.",
      }),
    )
    .default(1.5),
  n_min: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Minimum step for improved style edits",
      }),
    )
    .default(0),
  n_max: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Control the strength of the edit",
      }),
    )
    .default(23),
  image_url: z.union([z.string(), z.string()]),
  source_prompt: z.string().register(z.globalRegistry, {
    description: "Prompt of the image to be used.",
  }),
  tar_guidance_scale: z
    .optional(
      z.int().gte(0).lte(30).register(z.globalRegistry, {
        description: "Guidance scale for target.",
      }),
    )
    .default(5.5),
  target_prompt: z.string().register(z.globalRegistry, {
    description: "Prompt of the image to be made.",
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed for reproducible generation. If set none, a random seed will be used.",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Steps for which the model should run.",
      }),
    )
    .default(28),
  n_avg: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Average step count",
      }),
    )
    .default(1),
});

/**
 * ProcessedOutput
 */
export const zPostProcessingOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The processed images",
  }),
});

/**
 * ImageProcessingInput
 */
export const zPostProcessingInput = z.object({
  blue_shift: z
    .optional(
      z.int().gte(-20).lte(20).register(z.globalRegistry, {
        description: "Blue channel shift amount",
      }),
    )
    .default(0),
  vertex_y: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Vertex Y position",
      }),
    )
    .default(0.5),
  green_direction: z.optional(
    z.enum(["horizontal", "vertical"]).register(z.globalRegistry, {
      description: "Green channel shift direction",
    }),
  ),
  enable_glow: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Enable glow effect",
      }),
    )
    .default(false),
  dodge_burn_mode: z.optional(
    z
      .enum([
        "dodge",
        "burn",
        "dodge_and_burn",
        "burn_and_dodge",
        "color_dodge",
        "color_burn",
        "linear_dodge",
        "linear_burn",
      ])
      .register(z.globalRegistry, {
        description: "Dodge and burn mode",
      }),
  ),
  glow_intensity: z
    .optional(
      z.number().gte(0).lte(5).register(z.globalRegistry, {
        description: "Glow intensity",
      }),
    )
    .default(1),
  blur_sigma: z
    .optional(
      z.number().gte(0.1).lte(10).register(z.globalRegistry, {
        description: "Sigma for Gaussian blur",
      }),
    )
    .default(1),
  desaturate_method: z.optional(
    z
      .enum([
        "luminance (Rec.709)",
        "luminance (Rec.601)",
        "average",
        "lightness",
      ])
      .register(z.globalRegistry, {
        description: "Desaturation method",
      }),
  ),
  enable_blur: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Enable blur effect",
      }),
    )
    .default(false),
  blur_radius: z
    .optional(
      z.int().gte(0).lte(31).register(z.globalRegistry, {
        description: "Blur radius",
      }),
    )
    .default(3),
  grain_style: z.optional(
    z
      .enum(["modern", "analog", "kodak", "fuji", "cinematic", "newspaper"])
      .register(z.globalRegistry, {
        description: "Style of film grain to apply",
      }),
  ),
  cas_amount: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "CAS sharpening amount",
      }),
    )
    .default(0.8),
  gamma: z
    .optional(
      z.number().gte(0.2).lte(2.2).register(z.globalRegistry, {
        description: "Gamma adjustment",
      }),
    )
    .default(1),
  tint_mode: z.optional(
    z
      .enum([
        "sepia",
        "red",
        "green",
        "blue",
        "cyan",
        "magenta",
        "yellow",
        "purple",
        "orange",
        "warm",
        "cool",
        "lime",
        "navy",
        "vintage",
        "rose",
        "teal",
        "maroon",
        "peach",
        "lavender",
        "olive",
      ])
      .register(z.globalRegistry, {
        description: "Tint color mode",
      }),
  ),
  blur_type: z.optional(
    z.enum(["gaussian", "kuwahara"]).register(z.globalRegistry, {
      description: "Type of blur to apply",
    }),
  ),
  enable_vignette: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Enable vignette effect",
      }),
    )
    .default(false),
  dissolve_image_url: z.optional(z.union([z.string(), z.string()])),
  red_shift: z
    .optional(
      z.int().gte(-20).lte(20).register(z.globalRegistry, {
        description: "Red channel shift amount",
      }),
    )
    .default(0),
  enable_desaturate: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Enable desaturation effect",
      }),
    )
    .default(false),
  grain_intensity: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Film grain intensity (when enabled)",
      }),
    )
    .default(0.4),
  dodge_burn_intensity: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Dodge and burn intensity",
      }),
    )
    .default(0.5),
  smart_sharpen_strength: z
    .optional(
      z.number().gte(0).lte(25).register(z.globalRegistry, {
        description: "Smart sharpen strength",
      }),
    )
    .default(5),
  red_direction: z.optional(
    z.enum(["horizontal", "vertical"]).register(z.globalRegistry, {
      description: "Red channel shift direction",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  vertex_x: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Vertex X position",
      }),
    )
    .default(0.5),
  tint_strength: z
    .optional(
      z.number().gte(0.1).lte(1).register(z.globalRegistry, {
        description: "Tint strength",
      }),
    )
    .default(1),
  enable_dissolve: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Enable dissolve effect",
      }),
    )
    .default(false),
  enable_parabolize: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Enable parabolize effect",
      }),
    )
    .default(false),
  enable_grain: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Enable film grain effect",
      }),
    )
    .default(false),
  solarize_threshold: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Solarize threshold",
      }),
    )
    .default(0.5),
  enable_sharpen: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Enable sharpen effect",
      }),
    )
    .default(false),
  enable_dodge_burn: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Enable dodge and burn effect",
      }),
    )
    .default(false),
  glow_radius: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Glow blur radius",
      }),
    )
    .default(5),
  sharpen_alpha: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: "Sharpen strength (for basic mode)",
      }),
    )
    .default(1),
  enable_color_correction: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Enable color correction",
      }),
    )
    .default(false),
  contrast: z
    .optional(
      z.number().gte(-100).lte(100).register(z.globalRegistry, {
        description: "Contrast adjustment",
      }),
    )
    .default(0),
  enable_solarize: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Enable solarize effect",
      }),
    )
    .default(false),
  noise_radius: z
    .optional(
      z.int().gte(1).lte(25).register(z.globalRegistry, {
        description: "Noise radius for smart sharpen",
      }),
    )
    .default(7),
  grain_scale: z
    .optional(
      z.number().gte(1).lte(100).register(z.globalRegistry, {
        description: "Film grain scale (when enabled)",
      }),
    )
    .default(10),
  temperature: z
    .optional(
      z.number().gte(-100).lte(100).register(z.globalRegistry, {
        description: "Color temperature adjustment",
      }),
    )
    .default(0),
  brightness: z
    .optional(
      z.number().gte(-100).lte(100).register(z.globalRegistry, {
        description: "Brightness adjustment",
      }),
    )
    .default(0),
  blue_direction: z.optional(
    z.enum(["horizontal", "vertical"]).register(z.globalRegistry, {
      description: "Blue channel shift direction",
    }),
  ),
  dissolve_factor: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Dissolve blend factor",
      }),
    )
    .default(0.5),
  sharpen_mode: z.optional(
    z.enum(["basic", "smart", "cas"]).register(z.globalRegistry, {
      description: "Type of sharpening to apply",
    }),
  ),
  vignette_strength: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: "Vignette strength (when enabled)",
      }),
    )
    .default(0.5),
  sharpen_radius: z
    .optional(
      z.int().gte(1).lte(15).register(z.globalRegistry, {
        description: "Sharpen radius (for basic mode)",
      }),
    )
    .default(1),
  parabolize_coeff: z
    .optional(
      z.number().gte(-10).lte(10).register(z.globalRegistry, {
        description: "Parabolize coefficient",
      }),
    )
    .default(1),
  saturation: z
    .optional(
      z.number().gte(-100).lte(100).register(z.globalRegistry, {
        description: "Saturation adjustment",
      }),
    )
    .default(0),
  enable_tint: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Enable color tint effect",
      }),
    )
    .default(false),
  green_shift: z
    .optional(
      z.int().gte(-20).lte(20).register(z.globalRegistry, {
        description: "Green channel shift amount",
      }),
    )
    .default(0),
  preserve_edges: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Edge preservation factor",
      }),
    )
    .default(0.75),
  desaturate_factor: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Desaturation factor",
      }),
    )
    .default(1),
  smart_sharpen_ratio: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Smart sharpen blend ratio",
      }),
    )
    .default(0.5),
  enable_chromatic: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Enable chromatic aberration",
      }),
    )
    .default(false),
});

/**
 * NafnetOutputDenoise
 */
export const zNafnetDenoiseOutput = z.object({
  image: zImage,
});

/**
 * NafnetInputDenoise
 */
export const zNafnetDenoiseInput = z.object({
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "seed to be used for generation",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * NafnetOutput
 */
export const zNafnetDeblurOutput = z.object({
  image: zImage,
});

/**
 * NafnetInput
 */
export const zNafnetDeblurInput = z.object({
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "seed to be used for generation",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * Output
 */
export const zDrctSuperResolutionOutput = z.object({
  image: zImage,
});

/**
 * Input
 */
export const zDrctSuperResolutionInput = z.object({
  upscale_factor: z.optional(
    z.literal(4).register(z.globalRegistry, {
      description: "Upscaling factor.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * SAM2AutomaticSegmentationOutput
 */
export const zSam2AutoSegmentOutput = z.object({
  combined_mask: zImage,
  individual_masks: z.array(zImage).register(z.globalRegistry, {
    description: "Individual segmentation masks.",
  }),
});

/**
 * SAM2AutomaticSegmentationInput
 */
export const zSam2AutoSegmentInput = z.object({
  points_per_side: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Number of points to sample along each side of the image.",
      }),
    )
    .default(32),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  min_mask_region_area: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Minimum area of a mask region.",
      }),
    )
    .default(100),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  pred_iou_thresh: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: "Threshold for predicted IOU score.",
      }),
    )
    .default(0.88),
  stability_score_thresh: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: "Threshold for stability score.",
      }),
    )
    .default(0.95),
});

/**
 * DDColorOutput
 */
export const zDdcolorOutput = z.object({
  image: zImage,
});

/**
 * DDColorInput
 */
export const zDdcolorInput = z.object({
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "seed to be used for generation",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * ImageOutput
 */
export const zEvfSamOutput = z.object({
  image: zFile,
});

/**
 * ImageInput
 */
export const zEvfSamInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate segmentation from.",
  }),
  use_grounding_dino: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Use GroundingDINO instead of SAM for segmentation",
      }),
    )
    .default(false),
  semantic_type: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Enable semantic level segmentation for body parts, background or multi objects",
      }),
    )
    .default(false),
  fill_holes: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Fill holes in the mask using morphological operations",
      }),
    )
    .default(false),
  expand_mask: z
    .optional(
      z.int().gte(0).lte(20).register(z.globalRegistry, {
        description: "Expand/dilate the mask by specified pixels",
      }),
    )
    .default(0),
  mask_only: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Output only the binary mask instead of masked image",
      }),
    )
    .default(true),
  revert_mask: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Invert the mask (background becomes foreground and vice versa)",
      }),
    )
    .default(false),
  blur_mask: z
    .optional(
      z.int().gte(0).lte(50).register(z.globalRegistry, {
        description:
          "Apply Gaussian blur to the mask. Value determines kernel size (must be odd number)",
      }),
    )
    .default(0),
  negative_prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "Areas to exclude from segmentation (will be subtracted from prompt results)",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * Output
 */
export const zIdeogramV2aTurboRemixOutput = z.object({
  images: z.array(zFileType2),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for the random number generator",
  }),
});

/**
 * RemixImageInput
 */
export const zIdeogramV2aTurboRemixInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to remix the image with",
  }),
  aspect_ratio: z.optional(
    z
      .enum([
        "10:16",
        "16:10",
        "9:16",
        "16:9",
        "4:3",
        "3:4",
        "1:1",
        "1:3",
        "3:1",
        "3:2",
        "2:3",
      ])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image",
      }),
  ),
  style: z.optional(
    z
      .enum(["auto", "general", "realistic", "design", "render_3D", "anime"])
      .register(z.globalRegistry, {
        description: "The style of the generated image",
      }),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to expand the prompt with MagicPrompt functionality.",
      }),
    )
    .default(true),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description: "Strength of the input image in the remix",
      }),
    )
    .default(0.8),
  seed: z.optional(z.union([z.int(), z.unknown()])),
});

/**
 * Output
 */
export const zIdeogramV2aRemixOutput = z.object({
  images: z.array(zFileType2),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for the random number generator",
  }),
});

/**
 * RemixImageInput
 */
export const zIdeogramV2aRemixInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to remix the image with",
  }),
  aspect_ratio: z.optional(
    z
      .enum([
        "10:16",
        "16:10",
        "9:16",
        "16:9",
        "4:3",
        "3:4",
        "1:1",
        "1:3",
        "3:1",
        "3:2",
        "2:3",
      ])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image",
      }),
  ),
  style: z.optional(
    z
      .enum(["auto", "general", "realistic", "design", "render_3D", "anime"])
      .register(z.globalRegistry, {
        description: "The style of the generated image",
      }),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to expand the prompt with MagicPrompt functionality.",
      }),
    )
    .default(true),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description: "Strength of the input image in the remix",
      }),
    )
    .default(0.8),
  seed: z.optional(z.union([z.int(), z.unknown()])),
});

/**
 * SwinSrOutput
 */
export const zSwin2SrOutput = z.object({
  image: zImage,
});

/**
 * SwinSrInput
 */
export const zSwin2SrInput = z.object({
  task: z.optional(
    z
      .enum(["classical_sr", "compressed_sr", "real_sr"])
      .register(z.globalRegistry, {
        description: "Task to perform",
      }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "seed to be used for generation",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * DocResOutput
 */
export const zDocresOutput = z.object({
  image: zImage,
});

/**
 * DocResInput
 */
export const zDocresInput = z.object({
  task: z
    .enum(["deshadowing", "appearance", "deblurring", "binarization"])
    .register(z.globalRegistry, {
      description: "Task to perform",
    }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * DocResOutput
 */
export const zDocresDewarpOutput = z.object({
  image: zImage,
});

/**
 * DocResInputDewarp
 */
export const zDocresDewarpInput = z.object({
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * Output
 */
export const zJuggernautFluxProImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * DevImageToImageInput
 */
export const zJuggernautFluxProImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "The strength of the initial image. Higher strength values are better for this model.",
      }),
    )
    .default(0.95),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(40),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zJuggernautFluxBaseImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * DevImageToImageInput
 */
export const zJuggernautFluxBaseImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "The strength of the initial image. Higher strength values are better for this model.",
      }),
    )
    .default(0.95),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(40),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * WatermarkOutput
 */
export const zInvisibleWatermarkOutput = z.object({
  image: z.optional(zImage),
  extracted_watermark: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The extracted watermark text (when decoding)",
    }),
  ),
  length: z
    .optional(
      z.int().register(z.globalRegistry, {
        description:
          "Length of the watermark bits used (helpful for future decoding)",
      }),
    )
    .default(0),
});

/**
 * WatermarkInput
 */
export const zInvisibleWatermarkInput = z.object({
  decode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to decode a watermark from the image instead of encoding",
      }),
    )
    .default(false),
  watermark: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Text to use as watermark (for encoding only)",
      }),
    )
    .default("watermark"),
  length: z
    .optional(
      z.int().register(z.globalRegistry, {
        description:
          "Length of watermark bits to decode (required when decode=True)",
      }),
    )
    .default(0),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * GeminiImageOutput
 */
export const zGeminiFlashEditMultiOutput = z.object({
  description: z.string().register(z.globalRegistry, {
    description: "Text description or response from Gemini",
  }),
  image: zImageType3,
});

/**
 * GeminiMultiImageRequest
 */
export const zGeminiFlashEditMultiInput = z.object({
  prompt: z.string().min(3).max(5000).register(z.globalRegistry, {
    description: "The prompt for image generation or editing",
  }),
  input_image_urls: z
    .array(z.string())
    .min(1)
    .max(10)
    .register(z.globalRegistry, {
      description: "List of URLs of input images for editing",
    }),
});

/**
 * GeminiImageOutput
 */
export const zGeminiFlashEditOutput = z.object({
  description: z.string().register(z.globalRegistry, {
    description: "Text description or response from Gemini",
  }),
  image: zImageType3,
});

/**
 * GeminiImageRequest
 */
export const zGeminiFlashEditInput = z.object({
  prompt: z.string().min(3).max(5000).register(z.globalRegistry, {
    description: "The prompt for image generation or editing",
  }),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * MixDehazeNetOutput
 */
export const zMixDehazeNetOutput = z.object({
  image: zImage,
});

/**
 * MixDehazeNetInput
 */
export const zMixDehazeNetInput = z.object({
  model: z.optional(
    z.enum(["indoor", "outdoor"]).register(z.globalRegistry, {
      description: "Model to be used for dehazing",
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "seed to be used for generation",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * TheraOutput
 */
export const zTheraOutput = z.object({
  image: zImage,
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TheraInput
 */
export const zTheraInput = z.object({
  upscale_factor: z
    .optional(
      z.number().gte(1).lte(6).register(z.globalRegistry, {
        description: "The upscaling factor for the image.",
      }),
    )
    .default(2),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Random seed for reproducible generation.",
    }),
  ),
  backbone: z.enum(["edsr", "rdn"]).register(z.globalRegistry, {
    description: "Backbone to use for upscaling",
  }),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * Output
 */
export const zGhiblifyOutput = z.object({
  image: zImageType3,
});

/**
 * Input
 */
export const zGhiblifyInput = z.object({
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enable the safety checker.",
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * StarVectorOutput
 */
export const zStarVectorOutput = z.object({
  image: zFileType2,
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * StarVectorInput
 */
export const zStarVectorInput = z.object({
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "seed to be used for generation",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * EraseOutput
 */
export const zFinegrainEraserOutput = z.object({
  image: zFile,
  used_seed: z.int().register(z.globalRegistry, {
    description: "Seed used for generation",
  }),
});

/**
 * PromptEraseRequest
 */
export const zFinegrainEraserInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "Text description of what to erase",
  }),
  mode: z.optional(
    z.enum(["express", "standard", "premium"]).register(z.globalRegistry, {
      description: "Erase quality mode",
    }),
  ),
  seed: z.optional(
    z.int().gte(0).lte(999).register(z.globalRegistry, {
      description: "Random seed for reproducible generation",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * BoxPromptBase
 */
export const zBoxPromptBase = z.object({
  y_min: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Y Min Coordinate of the box",
      }),
    )
    .default(0),
  x_max: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "X Max Coordinate of the prompt",
      }),
    )
    .default(0),
  x_min: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "X Min Coordinate of the box",
      }),
    )
    .default(0),
  y_max: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Y Max Coordinate of the prompt",
      }),
    )
    .default(0),
});

/**
 * EraseOutput
 */
export const zFinegrainEraserBboxOutput = z.object({
  image: zFile,
  used_seed: z.int().register(z.globalRegistry, {
    description: "Seed used for generation",
  }),
});

/**
 * BBoxEraseRequest
 */
export const zFinegrainEraserBboxInput = z.object({
  mode: z.optional(
    z.enum(["express", "standard", "premium"]).register(z.globalRegistry, {
      description: "Erase quality mode",
    }),
  ),
  seed: z.optional(
    z.int().gte(0).lte(999).register(z.globalRegistry, {
      description: "Random seed for reproducible generation",
    }),
  ),
  box_prompts: z.array(zBoxPromptBase).register(z.globalRegistry, {
    description:
      "List of bounding box coordinates to erase (only one box prompt is supported)",
  }),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * EraseOutput
 */
export const zFinegrainEraserMaskOutput = z.object({
  image: zFile,
  used_seed: z.int().register(z.globalRegistry, {
    description: "Seed used for generation",
  }),
});

/**
 * MaskEraseRequest
 */
export const zFinegrainEraserMaskInput = z.object({
  mode: z.optional(
    z.enum(["express", "standard", "premium"]).register(z.globalRegistry, {
      description: "Erase quality mode",
    }),
  ),
  seed: z.optional(
    z.int().gte(0).lte(999).register(z.globalRegistry, {
      description: "Random seed for reproducible generation",
    }),
  ),
  mask_url: z.union([z.string(), z.string()]),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * Output
 */
export const zCartoonifyOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * CartoonifyInput
 */
export const zCartoonifyInput = z.object({
  use_cfg_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use CFG zero",
      }),
    )
    .default(false),
  image_url: z.union([z.string(), z.string()]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "Guidance scale for the generation",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps",
      }),
    )
    .default(28),
  scale: z
    .optional(
      z.number().gte(0.1).lte(2).register(z.globalRegistry, {
        description: "Scale factor for the Pixar effect",
      }),
    )
    .default(1),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enable the safety checker",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The seed for image generation. Same seed with same parameters will generate same image.",
    }),
  ),
});

/**
 * ImageOutput
 */
export const zInstantCharacterOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated images",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageInput
 */
export const zInstantCharacterInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  scale: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description:
          "The scale of the subject image. Higher values will make the subject image more prominent in the generated image.",
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zPlushifyOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * PlushifyInput
 */
export const zPlushifyInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Prompt for the generation. Default is empty which is usually best, but sometimes it can help to add a description of the subject.",
      }),
    )
    .default(""),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "Number of images to generate",
      }),
    )
    .default(1),
  use_cfg_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use CFG zero",
      }),
    )
    .default(false),
  image_url: z.union([z.string(), z.string()]),
  scale: z
    .optional(
      z.number().gte(0.1).lte(2).register(z.globalRegistry, {
        description: "Scale factor for the Cartoon effect",
      }),
    )
    .default(1),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps",
      }),
    )
    .default(28),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "Guidance scale for the generation",
      }),
    )
    .default(3.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enable the safety checker",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The seed for image generation. Same seed with same parameters will generate same image.",
    }),
  ),
});

/**
 * Output
 */
export const zFashnTryonV15Output = z.object({
  images: z.array(zFile),
});

/**
 * Input
 */
export const zFashnTryonV15Input = z.object({
  model_image: z.string().register(z.globalRegistry, {
    description: "URL or base64 of the model image",
  }),
  moderation_level: z.optional(
    z.enum(["none", "permissive", "conservative"]).register(z.globalRegistry, {
      description:
        "Content moderation level for garment images. 'none' disables moderation, 'permissive' blocks only explicit content, 'conservative' also blocks underwear and swimwear.",
    }),
  ),
  garment_photo_type: z.optional(
    z.enum(["auto", "model", "flat-lay"]).register(z.globalRegistry, {
      description:
        "Specifies the type of garment photo to optimize internal parameters for better performance. 'model' is for photos of garments on a model, 'flat-lay' is for flat-lay or ghost mannequin images, and 'auto' attempts to automatically detect the photo type.",
    }),
  ),
  garment_image: z.string().register(z.globalRegistry, {
    description: "URL or base64 of the garment image",
  }),
  category: z.optional(
    z
      .enum(["tops", "bottoms", "one-pieces", "auto"])
      .register(z.globalRegistry, {
        description:
          "Category of the garment to try-on. 'auto' will attempt to automatically detect the category of the garment.",
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  segmentation_free: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Disables human parsing on the model image.",
      }),
    )
    .default(true),
  num_samples: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "Number of images to generate in a single run. Image generation has a random element in it, so trying multiple images at once increases the chances of getting a good result.",
      }),
    )
    .default(1),
  mode: z.optional(
    z.enum(["performance", "balanced", "quality"]).register(z.globalRegistry, {
      description:
        "Specifies the mode of operation. 'performance' mode is faster but may sacrifice quality, 'balanced' mode is a balance between speed and quality, and 'quality' mode is slower but produces higher quality results.",
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Sets random operations to a fixed state. Use the same seed to reproduce results with the same inputs, or different seed to force different results.",
    }),
  ),
  output_format: z.optional(
    z.enum(["png", "jpeg"]).register(z.globalRegistry, {
      description:
        "Output format of the generated images. 'png' is highest quality, while 'jpeg' is faster",
    }),
  ),
});

/**
 * Output
 */
export const zJuggernautFluxLoraInpaintingOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * InpaintInput
 */
export const zJuggernautFluxLoraInpaintingInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.",
      }),
    )
    .default(0.85),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  mask_url: z.union([z.string(), z.string()]),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * EditImageResponse
 */
export const zGptImage1EditImageOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images.",
  }),
});

/**
 * EditImageRequest
 */
export const zGptImage1EditImageInput = z.object({
  prompt: z.string().min(2).register(z.globalRegistry, {
    description: "The prompt for image generation",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "Number of images to generate",
      }),
    )
    .default(1),
  image_size: z.optional(
    z
      .enum(["auto", "1024x1024", "1536x1024", "1024x1536"])
      .register(z.globalRegistry, {
        description: "Aspect ratio for the generated image",
      }),
  ),
  background: z.optional(
    z.enum(["auto", "transparent", "opaque"]).register(z.globalRegistry, {
      description: "Background for the generated image",
    }),
  ),
  quality: z.optional(
    z.enum(["auto", "low", "medium", "high"]).register(z.globalRegistry, {
      description: "Quality for the generated image",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "Output format for the images",
    }),
  ),
  input_fidelity: z.optional(
    z.enum(["low", "high"]).register(z.globalRegistry, {
      description: "Input fidelity for the generated image",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "The URLs of the images to use as a reference for the generation.",
  }),
});

/**
 * UNOOutput
 */
export const zUnoOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used to generate the image.",
  }),
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The URLs of the generated images.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * UNOInput
 */
export const zUnoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  input_image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: "URL of images to use while generating the image.",
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed for reproducible generation. If set none, a random seed will be used.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * Image2SVGOutput
 */
export const zImage2SvgOutput = z.object({
  images: z.array(zFile).register(z.globalRegistry, {
    description: "The converted SVG file",
  }),
});

/**
 * Image2SVGInput
 */
export const zImage2SvgInput = z.object({
  splice_threshold: z
    .optional(
      z.int().gte(0).lte(90).register(z.globalRegistry, {
        description: "Splice threshold for joining paths",
      }),
    )
    .default(45),
  hierarchical: z.optional(
    z.enum(["stacked", "cutout"]).register(z.globalRegistry, {
      description: "Hierarchical mode: stacked or cutout",
    }),
  ),
  color_precision: z
    .optional(
      z.int().gte(1).lte(10).register(z.globalRegistry, {
        description: "Color quantization level",
      }),
    )
    .default(6),
  colormode: z.optional(
    z.enum(["color", "binary"]).register(z.globalRegistry, {
      description: "Choose between color or binary (black and white) output",
    }),
  ),
  max_iterations: z
    .optional(
      z.int().gte(1).lte(20).register(z.globalRegistry, {
        description: "Maximum number of iterations for optimization",
      }),
    )
    .default(10),
  length_threshold: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: "Length threshold for curves/lines",
      }),
    )
    .default(4),
  image_url: z.union([z.string(), z.string()]),
  mode: z.optional(
    z.enum(["spline", "polygon"]).register(z.globalRegistry, {
      description: "Mode: spline (curved) or polygon (straight lines)",
    }),
  ),
  corner_threshold: z
    .optional(
      z.int().gte(0).lte(180).register(z.globalRegistry, {
        description: "Corner detection threshold in degrees",
      }),
    )
    .default(60),
  path_precision: z
    .optional(
      z.int().gte(1).lte(10).register(z.globalRegistry, {
        description: "Decimal precision for path coordinates",
      }),
    )
    .default(3),
  filter_speckle: z
    .optional(
      z.int().gte(0).lte(20).register(z.globalRegistry, {
        description: "Filter out small speckles and noise",
      }),
    )
    .default(4),
  layer_difference: z
    .optional(
      z.int().gte(1).lte(32).register(z.globalRegistry, {
        description: "Layer difference threshold for hierarchical mode",
      }),
    )
    .default(16),
});

/**
 * ImageOutput
 */
export const zStep1xEditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated images",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageInput
 */
export const zStep1xEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(4),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(30),
});

/**
 * EditOutputV3
 */
export const zIdeogramV3EditOutput = z.object({
  images: z.array(zFileType2),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for the random number generator",
  }),
});

/**
 * EditImageInputV3
 */
export const zIdeogramV3EditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to fill the masked part of the image.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "Number of images to generate.",
      }),
    )
    .default(1),
  style_preset: z.optional(
    z.union([
      z.enum([
        "80S_ILLUSTRATION",
        "90S_NOSTALGIA",
        "ABSTRACT_ORGANIC",
        "ANALOG_NOSTALGIA",
        "ART_BRUT",
        "ART_DECO",
        "ART_POSTER",
        "AURA",
        "AVANT_GARDE",
        "BAUHAUS",
        "BLUEPRINT",
        "BLURRY_MOTION",
        "BRIGHT_ART",
        "C4D_CARTOON",
        "CHILDRENS_BOOK",
        "COLLAGE",
        "COLORING_BOOK_I",
        "COLORING_BOOK_II",
        "CUBISM",
        "DARK_AURA",
        "DOODLE",
        "DOUBLE_EXPOSURE",
        "DRAMATIC_CINEMA",
        "EDITORIAL",
        "EMOTIONAL_MINIMAL",
        "ETHEREAL_PARTY",
        "EXPIRED_FILM",
        "FLAT_ART",
        "FLAT_VECTOR",
        "FOREST_REVERIE",
        "GEO_MINIMALIST",
        "GLASS_PRISM",
        "GOLDEN_HOUR",
        "GRAFFITI_I",
        "GRAFFITI_II",
        "HALFTONE_PRINT",
        "HIGH_CONTRAST",
        "HIPPIE_ERA",
        "ICONIC",
        "JAPANDI_FUSION",
        "JAZZY",
        "LONG_EXPOSURE",
        "MAGAZINE_EDITORIAL",
        "MINIMAL_ILLUSTRATION",
        "MIXED_MEDIA",
        "MONOCHROME",
        "NIGHTLIFE",
        "OIL_PAINTING",
        "OLD_CARTOONS",
        "PAINT_GESTURE",
        "POP_ART",
        "RETRO_ETCHING",
        "RIVIERA_POP",
        "SPOTLIGHT_80S",
        "STYLIZED_RED",
        "SURREAL_COLLAGE",
        "TRAVEL_POSTER",
        "VINTAGE_GEO",
        "VINTAGE_POSTER",
        "WATERCOLOR",
        "WEIRD",
        "WOODBLOCK_PRINT",
      ]),
      z.unknown(),
    ]),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Determine if MagicPrompt should be used in generating the request or not.",
      }),
    )
    .default(true),
  rendering_speed: z.optional(
    z.enum(["TURBO", "BALANCED", "QUALITY"]).register(z.globalRegistry, {
      description: "The rendering speed to use.",
    }),
  ),
  style_codes: z.optional(z.union([z.array(z.string()), z.unknown()])),
  color_palette: z.optional(z.union([zColorPalette, z.unknown()])),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  mask_url: z.union([z.string(), z.string()]),
  image_urls: z.optional(z.union([z.array(z.string()), z.unknown()])),
});

/**
 * RemixOutputV3
 */
export const zIdeogramV3RemixOutput = z.object({
  images: z.array(zFileType2),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for the random number generator",
  }),
});

/**
 * RemixImageInputV3
 */
export const zIdeogramV3RemixInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to remix the image with",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
      z.unknown(),
    ]),
  ),
  style: z.optional(
    z.union([z.enum(["AUTO", "GENERAL", "REALISTIC", "DESIGN"]), z.unknown()]),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Determine if MagicPrompt should be used in generating the request or not.",
      }),
    )
    .default(true),
  rendering_speed: z.optional(
    z.enum(["TURBO", "BALANCED", "QUALITY"]).register(z.globalRegistry, {
      description: "The rendering speed to use.",
    }),
  ),
  image_urls: z.optional(z.union([z.array(z.string()), z.unknown()])),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Description of what to exclude from an image. Descriptions in the prompt take precedence to descriptions in the negative prompt.",
      }),
    )
    .default(""),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "Number of images to generate.",
      }),
    )
    .default(1),
  image_url: z.union([z.string(), z.string()]),
  style_codes: z.optional(z.union([z.array(z.string()), z.unknown()])),
  color_palette: z.optional(z.union([zColorPalette, z.unknown()])),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description: "Strength of the input image in the remix",
      }),
    )
    .default(0.8),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
});

/**
 * ReplaceBackgroundOutputV3
 */
export const zIdeogramV3ReplaceBackgroundOutput = z.object({
  images: z.array(zFileType2),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for the random number generator",
  }),
});

/**
 * ReplaceBackgroundInputV3
 */
export const zIdeogramV3ReplaceBackgroundInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "Cyber punk city with neon lights and skyscrappers",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "Number of images to generate.",
      }),
    )
    .default(1),
  style: z.optional(
    z.union([z.enum(["AUTO", "GENERAL", "REALISTIC", "DESIGN"]), z.unknown()]),
  ),
  style_preset: z.optional(
    z.union([
      z.enum([
        "80S_ILLUSTRATION",
        "90S_NOSTALGIA",
        "ABSTRACT_ORGANIC",
        "ANALOG_NOSTALGIA",
        "ART_BRUT",
        "ART_DECO",
        "ART_POSTER",
        "AURA",
        "AVANT_GARDE",
        "BAUHAUS",
        "BLUEPRINT",
        "BLURRY_MOTION",
        "BRIGHT_ART",
        "C4D_CARTOON",
        "CHILDRENS_BOOK",
        "COLLAGE",
        "COLORING_BOOK_I",
        "COLORING_BOOK_II",
        "CUBISM",
        "DARK_AURA",
        "DOODLE",
        "DOUBLE_EXPOSURE",
        "DRAMATIC_CINEMA",
        "EDITORIAL",
        "EMOTIONAL_MINIMAL",
        "ETHEREAL_PARTY",
        "EXPIRED_FILM",
        "FLAT_ART",
        "FLAT_VECTOR",
        "FOREST_REVERIE",
        "GEO_MINIMALIST",
        "GLASS_PRISM",
        "GOLDEN_HOUR",
        "GRAFFITI_I",
        "GRAFFITI_II",
        "HALFTONE_PRINT",
        "HIGH_CONTRAST",
        "HIPPIE_ERA",
        "ICONIC",
        "JAPANDI_FUSION",
        "JAZZY",
        "LONG_EXPOSURE",
        "MAGAZINE_EDITORIAL",
        "MINIMAL_ILLUSTRATION",
        "MIXED_MEDIA",
        "MONOCHROME",
        "NIGHTLIFE",
        "OIL_PAINTING",
        "OLD_CARTOONS",
        "PAINT_GESTURE",
        "POP_ART",
        "RETRO_ETCHING",
        "RIVIERA_POP",
        "SPOTLIGHT_80S",
        "STYLIZED_RED",
        "SURREAL_COLLAGE",
        "TRAVEL_POSTER",
        "VINTAGE_GEO",
        "VINTAGE_POSTER",
        "WATERCOLOR",
        "WEIRD",
        "WOODBLOCK_PRINT",
      ]),
      z.unknown(),
    ]),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Determine if MagicPrompt should be used in generating the request or not.",
      }),
    )
    .default(true),
  rendering_speed: z.optional(
    z.enum(["TURBO", "BALANCED", "QUALITY"]).register(z.globalRegistry, {
      description: "The rendering speed to use.",
    }),
  ),
  style_codes: z.optional(z.union([z.array(z.string()), z.unknown()])),
  color_palette: z.optional(z.union([zColorPalette, z.unknown()])),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  image_urls: z.optional(z.union([z.array(z.string()), z.unknown()])),
});

/**
 * ReframeOutputV3
 */
export const zIdeogramV3ReframeOutput = z.object({
  images: z.array(zFileType2),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for the random number generator",
  }),
});

/**
 * ReframeImageInputV3
 */
export const zIdeogramV3ReframeInput = z.object({
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "Number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.union([
    zImageSize,
    z.enum([
      "square_hd",
      "square",
      "portrait_4_3",
      "portrait_16_9",
      "landscape_4_3",
      "landscape_16_9",
    ]),
  ]),
  style: z.optional(
    z.union([z.enum(["AUTO", "GENERAL", "REALISTIC", "DESIGN"]), z.unknown()]),
  ),
  style_preset: z.optional(
    z.union([
      z.enum([
        "80S_ILLUSTRATION",
        "90S_NOSTALGIA",
        "ABSTRACT_ORGANIC",
        "ANALOG_NOSTALGIA",
        "ART_BRUT",
        "ART_DECO",
        "ART_POSTER",
        "AURA",
        "AVANT_GARDE",
        "BAUHAUS",
        "BLUEPRINT",
        "BLURRY_MOTION",
        "BRIGHT_ART",
        "C4D_CARTOON",
        "CHILDRENS_BOOK",
        "COLLAGE",
        "COLORING_BOOK_I",
        "COLORING_BOOK_II",
        "CUBISM",
        "DARK_AURA",
        "DOODLE",
        "DOUBLE_EXPOSURE",
        "DRAMATIC_CINEMA",
        "EDITORIAL",
        "EMOTIONAL_MINIMAL",
        "ETHEREAL_PARTY",
        "EXPIRED_FILM",
        "FLAT_ART",
        "FLAT_VECTOR",
        "FOREST_REVERIE",
        "GEO_MINIMALIST",
        "GLASS_PRISM",
        "GOLDEN_HOUR",
        "GRAFFITI_I",
        "GRAFFITI_II",
        "HALFTONE_PRINT",
        "HIGH_CONTRAST",
        "HIPPIE_ERA",
        "ICONIC",
        "JAPANDI_FUSION",
        "JAZZY",
        "LONG_EXPOSURE",
        "MAGAZINE_EDITORIAL",
        "MINIMAL_ILLUSTRATION",
        "MIXED_MEDIA",
        "MONOCHROME",
        "NIGHTLIFE",
        "OIL_PAINTING",
        "OLD_CARTOONS",
        "PAINT_GESTURE",
        "POP_ART",
        "RETRO_ETCHING",
        "RIVIERA_POP",
        "SPOTLIGHT_80S",
        "STYLIZED_RED",
        "SURREAL_COLLAGE",
        "TRAVEL_POSTER",
        "VINTAGE_GEO",
        "VINTAGE_POSTER",
        "WATERCOLOR",
        "WEIRD",
        "WOODBLOCK_PRINT",
      ]),
      z.unknown(),
    ]),
  ),
  image_url: z.union([z.string(), z.string()]),
  style_codes: z.optional(z.union([z.array(z.string()), z.unknown()])),
  color_palette: z.optional(z.union([zColorPalette, z.unknown()])),
  rendering_speed: z.optional(
    z.enum(["TURBO", "BALANCED", "QUALITY"]).register(z.globalRegistry, {
      description: "The rendering speed to use.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  image_urls: z.optional(z.union([z.array(z.string()), z.unknown()])),
});

/**
 * Img2ImgOutput
 */
export const zHidreamI1FullImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated images",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * ImageToImageInput
 */
export const zHidreamI1FullImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoraWeightType3).register(z.globalRegistry, {
        description:
          "A list of LoRAs to apply to the model. Each LoRA specifies its path, scale, and optional weight name.",
      }),
    )
    .default([]),
  strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Denoising strength for image-to-image generation.",
      }),
    )
    .default(0.75),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(50),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * MiniMaxTextToImageWithReferenceOutput
 */
export const zMinimaxImage01SubjectReferenceOutput = z.object({
  images: z.array(zFile).register(z.globalRegistry, {
    description: "Generated images",
  }),
});

/**
 * MiniMaxTextToImageWithReferenceRequest
 */
export const zMinimaxImage01SubjectReferenceInput = z.object({
  prompt: z.string().min(1).max(1500).register(z.globalRegistry, {
    description: "Text prompt for image generation (max 1500 characters)",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(9).register(z.globalRegistry, {
        description: "Number of images to generate (1-9)",
      }),
    )
    .default(1),
  prompt_optimizer: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enable automatic prompt optimization",
      }),
    )
    .default(false),
  aspect_ratio: z.optional(
    z
      .enum(["1:1", "16:9", "4:3", "3:2", "2:3", "3:4", "9:16", "21:9"])
      .register(z.globalRegistry, {
        description: "Aspect ratio of the generated image",
      }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * ImageToImageOutput
 */
export const zRecraftV3ImageToImageOutput = z.object({
  images: z.array(zFile).register(z.globalRegistry, {
    description: "The generated images",
  }),
});

/**
 * ImageToImageInput
 */
export const zRecraftV3ImageToImageInput = z.object({
  prompt: z.string().max(1000).register(z.globalRegistry, {
    description: "A text description of areas to change.",
  }),
  style: z.optional(
    z
      .enum([
        "any",
        "realistic_image",
        "digital_illustration",
        "vector_illustration",
        "realistic_image/b_and_w",
        "realistic_image/hard_flash",
        "realistic_image/hdr",
        "realistic_image/natural_light",
        "realistic_image/studio_portrait",
        "realistic_image/enterprise",
        "realistic_image/motion_blur",
        "realistic_image/evening_light",
        "realistic_image/faded_nostalgia",
        "realistic_image/forest_life",
        "realistic_image/mystic_naturalism",
        "realistic_image/natural_tones",
        "realistic_image/organic_calm",
        "realistic_image/real_life_glow",
        "realistic_image/retro_realism",
        "realistic_image/retro_snapshot",
        "realistic_image/urban_drama",
        "realistic_image/village_realism",
        "realistic_image/warm_folk",
        "digital_illustration/pixel_art",
        "digital_illustration/hand_drawn",
        "digital_illustration/grain",
        "digital_illustration/infantile_sketch",
        "digital_illustration/2d_art_poster",
        "digital_illustration/handmade_3d",
        "digital_illustration/hand_drawn_outline",
        "digital_illustration/engraving_color",
        "digital_illustration/2d_art_poster_2",
        "digital_illustration/antiquarian",
        "digital_illustration/bold_fantasy",
        "digital_illustration/child_book",
        "digital_illustration/child_books",
        "digital_illustration/cover",
        "digital_illustration/crosshatch",
        "digital_illustration/digital_engraving",
        "digital_illustration/expressionism",
        "digital_illustration/freehand_details",
        "digital_illustration/grain_20",
        "digital_illustration/graphic_intensity",
        "digital_illustration/hard_comics",
        "digital_illustration/long_shadow",
        "digital_illustration/modern_folk",
        "digital_illustration/multicolor",
        "digital_illustration/neon_calm",
        "digital_illustration/noir",
        "digital_illustration/nostalgic_pastel",
        "digital_illustration/outline_details",
        "digital_illustration/pastel_gradient",
        "digital_illustration/pastel_sketch",
        "digital_illustration/pop_art",
        "digital_illustration/pop_renaissance",
        "digital_illustration/street_art",
        "digital_illustration/tablet_sketch",
        "digital_illustration/urban_glow",
        "digital_illustration/urban_sketching",
        "digital_illustration/vanilla_dreams",
        "digital_illustration/young_adult_book",
        "digital_illustration/young_adult_book_2",
        "vector_illustration/bold_stroke",
        "vector_illustration/chemistry",
        "vector_illustration/colored_stencil",
        "vector_illustration/contour_pop_art",
        "vector_illustration/cosmics",
        "vector_illustration/cutout",
        "vector_illustration/depressive",
        "vector_illustration/editorial",
        "vector_illustration/emotional_flat",
        "vector_illustration/infographical",
        "vector_illustration/marker_outline",
        "vector_illustration/mosaic",
        "vector_illustration/naivector",
        "vector_illustration/roundish_flat",
        "vector_illustration/segmented_colors",
        "vector_illustration/sharp_contrast",
        "vector_illustration/thin",
        "vector_illustration/vector_photo",
        "vector_illustration/vivid_shapes",
        "vector_illustration/engraving",
        "vector_illustration/line_art",
        "vector_illustration/line_circuit",
        "vector_illustration/linocut",
      ])
      .register(z.globalRegistry, {
        description:
          "The style of the generated images. Vector images cost 2X as much.",
      }),
  ),
  style_id: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The ID of the custom style reference (optional)",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "Defines the difference with the original image, should lie in [0, 1], where 0 means almost identical, and 1 means miserable similarity",
      }),
    )
    .default(0.5),
  colors: z
    .optional(
      z.array(zRgbColor).register(z.globalRegistry, {
        description: "An array of preferable colors",
      }),
    )
    .default([]),
  negative_prompt: z.optional(
    z.string().max(1000).register(z.globalRegistry, {
      description: "A text description of undesired elements on an image",
    }),
  ),
});

/**
 * UpscaleOutput
 */
export const zRecraftUpscaleCrispOutput = z.object({
  image: zFile,
});

/**
 * UpscaleInput
 */
export const zRecraftUpscaleCrispInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(false),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * UpscaleOutput
 */
export const zRecraftUpscaleCreativeOutput = z.object({
  image: zFile,
});

/**
 * UpscaleInput
 */
export const zRecraftUpscaleCreativeInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(false),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * ImageOutput
 */
export const zRembgEnhanceOutput = z.object({
  image: zFileType2,
});

/**
 * ImageInput
 */
export const zRembgEnhanceInput = z.object({
  image_url: z.union([z.string(), z.string()]),
});

/**
 * ImageEditOutput
 */
export const zBagelEditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The edited images.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * ImageEditInput
 */
export const zBagelEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to edit the image with.",
  }),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The seed to use for the generation.",
    }),
  ),
  use_thought: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to use thought tokens for generation. If set to true, the model will "think" to potentially improve generation quality. Increases generation time and increases the cost by 20%.',
      }),
    )
    .default(false),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * KontextEditOutput
 */
export const zFluxKontextDevOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * BaseKontextEditInput
 */
export const zFluxKontextDevInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to edit the image.",
  }),
  resolution_mode: z.optional(
    z
      .enum([
        "auto",
        "match_input",
        "1:1",
        "16:9",
        "21:9",
        "3:2",
        "2:3",
        "4:5",
        "5:4",
        "3:4",
        "4:3",
        "9:16",
        "9:21",
      ])
      .register(z.globalRegistry, {
        description:
          "\n             Determines how the output resolution is set for image editing.\n             - `auto`: The model selects an optimal resolution from a predefined set that best matches the input image's aspect ratio. This is the recommended setting for most use cases as it's what the model was trained on.\n             - `match_input`: The model will attempt to use the same resolution as the input image. The resolution will be adjusted to be compatible with the model's requirements (e.g. dimensions must be multiples of 16 and within supported limits).\n             Apart from these, a few aspect ratios are also supported.\n             ",
      }),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "Output format",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(2.5),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
});

/**
 * Image
 *
 * Represents an image file.
 */
export const zFalToolkitImageImageImage = z
  .object({
    file_size: z.optional(
      z.int().register(z.globalRegistry, {
        description: "The size of the file in bytes.",
      }),
    ),
    height: z.optional(
      z.int().register(z.globalRegistry, {
        description: "The height of the image in pixels.",
      }),
    ),
    url: z.string().register(z.globalRegistry, {
      description: "The URL where the file can be downloaded from.",
    }),
    width: z.optional(
      z.int().register(z.globalRegistry, {
        description: "The width of the image in pixels.",
      }),
    ),
    file_name: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          "The name of the file. It will be auto-generated if not provided.",
      }),
    ),
    content_type: z.optional(
      z.string().register(z.globalRegistry, {
        description: "The mime type of the file.",
      }),
    ),
    file_data: z.optional(
      z.string().register(z.globalRegistry, {
        description: "File data",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "Represents an image file.",
  });

/**
 * FluxKontextOutput
 */
export const zFluxProKontextMaxOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zFalToolkitImageImageImage).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * FluxKontextInput
 */
export const zFluxProKontextMaxInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z
      .enum(["21:9", "16:9", "4:3", "3:2", "1:1", "2:3", "3:4", "9:16", "9:21"])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enhance the prompt for better results.",
      }),
    )
    .default(false),
});

/**
 * Output
 */
export const zFluxProKontextMultiOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z
    .array(zRegistryImageFastSdxlModelsImage)
    .register(z.globalRegistry, {
      description: "The generated image files info.",
    }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * FluxKontextMultiInput
 */
export const zFluxProKontextMultiInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z
      .enum(["21:9", "16:9", "4:3", "3:2", "1:1", "2:3", "3:4", "9:16", "9:21"])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: "Image prompt for the omni model.",
  }),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enhance the prompt for better results.",
      }),
    )
    .default(false),
});

/**
 * Output
 */
export const zFluxProKontextMaxMultiOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z
    .array(zRegistryImageFastSdxlModelsImage)
    .register(z.globalRegistry, {
      description: "The generated image files info.",
    }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * FluxKontextMultiInput
 */
export const zFluxProKontextMaxMultiInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z
      .enum(["21:9", "16:9", "4:3", "3:2", "1:1", "2:3", "3:4", "9:16", "9:21"])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: "Image prompt for the omni model.",
  }),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enhance the prompt for better results.",
      }),
    )
    .default(false),
});

/**
 * AgeProgressionOutput
 */
export const zImageEditingAgeProgressionOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * AgeProgressionInput
 */
export const zImageEditingAgeProgressionInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The age change to apply.",
      }),
    )
    .default("20 years older"),
  aspect_ratio: z.optional(
    z
      .enum(["21:9", "16:9", "4:3", "3:2", "1:1", "2:3", "3:4", "9:16", "9:21"])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps for sampling.",
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The same seed and the same prompt given to the same version of the model will output the same image every time.",
    }),
  ),
});

/**
 * BackgroundChangeOutput
 */
export const zImageEditingBackgroundChangeOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * BackgroundChangeInput
 */
export const zImageEditingBackgroundChangeInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The desired background to apply.",
      }),
    )
    .default("beach sunset with palm trees"),
  aspect_ratio: z.optional(
    z
      .enum(["21:9", "16:9", "4:3", "3:2", "1:1", "2:3", "3:4", "9:16", "9:21"])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps for sampling.",
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The same seed and the same prompt given to the same version of the model will output the same image every time.",
    }),
  ),
});

/**
 * CartoonifyOutput
 */
export const zImageEditingCartoonifyOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * BaseInput
 */
export const zImageEditingCartoonifyInput = z.object({
  aspect_ratio: z.optional(
    z
      .enum(["21:9", "16:9", "4:3", "3:2", "1:1", "2:3", "3:4", "9:16", "9:21"])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps for sampling.",
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The same seed and the same prompt given to the same version of the model will output the same image every time.",
    }),
  ),
});

/**
 * ColorCorrectionOutput
 */
export const zImageEditingColorCorrectionOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * BaseInput
 */
export const zImageEditingColorCorrectionInput = z.object({
  aspect_ratio: z.optional(
    z
      .enum(["21:9", "16:9", "4:3", "3:2", "1:1", "2:3", "3:4", "9:16", "9:21"])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps for sampling.",
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The same seed and the same prompt given to the same version of the model will output the same image every time.",
    }),
  ),
});

/**
 * ExpressionChangeOutput
 */
export const zImageEditingExpressionChangeOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * ExpressionChangeInput
 */
export const zImageEditingExpressionChangeInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The desired facial expression to apply.",
      }),
    )
    .default("sad"),
  aspect_ratio: z.optional(
    z
      .enum(["21:9", "16:9", "4:3", "3:2", "1:1", "2:3", "3:4", "9:16", "9:21"])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps for sampling.",
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The same seed and the same prompt given to the same version of the model will output the same image every time.",
    }),
  ),
});

/**
 * FaceEnhancementOutput
 */
export const zImageEditingFaceEnhancementOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * BaseInput
 */
export const zImageEditingFaceEnhancementInput = z.object({
  aspect_ratio: z.optional(
    z
      .enum(["21:9", "16:9", "4:3", "3:2", "1:1", "2:3", "3:4", "9:16", "9:21"])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps for sampling.",
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The same seed and the same prompt given to the same version of the model will output the same image every time.",
    }),
  ),
});

/**
 * HairChangeOutput
 */
export const zImageEditingHairChangeOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * HairChangeInput
 */
export const zImageEditingHairChangeInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The desired hair style to apply.",
      }),
    )
    .default("bald"),
  aspect_ratio: z.optional(
    z
      .enum(["21:9", "16:9", "4:3", "3:2", "1:1", "2:3", "3:4", "9:16", "9:21"])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps for sampling.",
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The same seed and the same prompt given to the same version of the model will output the same image every time.",
    }),
  ),
});

/**
 * ObjectRemovalOutput
 */
export const zImageEditingObjectRemovalOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * ObjectRemovalInput
 */
export const zImageEditingObjectRemovalInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Specify which objects to remove from the image.",
      }),
    )
    .default("background people"),
  aspect_ratio: z.optional(
    z
      .enum(["21:9", "16:9", "4:3", "3:2", "1:1", "2:3", "3:4", "9:16", "9:21"])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps for sampling.",
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The same seed and the same prompt given to the same version of the model will output the same image every time.",
    }),
  ),
});

/**
 * ProfessionalPhotoOutput
 */
export const zImageEditingProfessionalPhotoOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * BaseInput
 */
export const zImageEditingProfessionalPhotoInput = z.object({
  aspect_ratio: z.optional(
    z
      .enum(["21:9", "16:9", "4:3", "3:2", "1:1", "2:3", "3:4", "9:16", "9:21"])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps for sampling.",
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The same seed and the same prompt given to the same version of the model will output the same image every time.",
    }),
  ),
});

/**
 * SceneCompositionOutput
 */
export const zImageEditingSceneCompositionOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * SceneCompositionInput
 */
export const zImageEditingSceneCompositionInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Describe the scene where you want to place the subject.",
      }),
    )
    .default("enchanted forest"),
  aspect_ratio: z.optional(
    z
      .enum(["21:9", "16:9", "4:3", "3:2", "1:1", "2:3", "3:4", "9:16", "9:21"])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps for sampling.",
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The same seed and the same prompt given to the same version of the model will output the same image every time.",
    }),
  ),
});

/**
 * StyleTransferOutput
 */
export const zImageEditingStyleTransferOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * StyleTransferInput
 */
export const zImageEditingStyleTransferInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The artistic style to apply.",
      }),
    )
    .default("Van Gogh's Starry Night"),
  aspect_ratio: z.optional(
    z
      .enum(["21:9", "16:9", "4:3", "3:2", "1:1", "2:3", "3:4", "9:16", "9:21"])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps for sampling.",
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The same seed and the same prompt given to the same version of the model will output the same image every time.",
    }),
  ),
});

/**
 * TimeOfDayOutput
 */
export const zImageEditingTimeOfDayOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * TimeOfDayInput
 */
export const zImageEditingTimeOfDayInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The time of day to transform the scene to.",
      }),
    )
    .default("golden hour"),
  aspect_ratio: z.optional(
    z
      .enum(["21:9", "16:9", "4:3", "3:2", "1:1", "2:3", "3:4", "9:16", "9:21"])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps for sampling.",
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The same seed and the same prompt given to the same version of the model will output the same image every time.",
    }),
  ),
});

/**
 * WeatherEffectOutput
 */
export const zImageEditingWeatherEffectOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * WeatherEffectInput
 */
export const zImageEditingWeatherEffectInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The weather effect to apply.",
      }),
    )
    .default("heavy snowfall"),
  aspect_ratio: z.optional(
    z
      .enum(["21:9", "16:9", "4:3", "3:2", "1:1", "2:3", "3:4", "9:16", "9:21"])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps for sampling.",
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The same seed and the same prompt given to the same version of the model will output the same image every time.",
    }),
  ),
});

/**
 * PhotoRestorationOutput
 */
export const zImageEditingPhotoRestorationOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * PhotoRestorationInput
 *
 * Input model for photo restoration endpoint.
 */
export const zImageEditingPhotoRestorationInput = z
  .object({
    aspect_ratio: z.optional(
      z
        .enum([
          "21:9",
          "16:9",
          "4:3",
          "3:2",
          "1:1",
          "2:3",
          "3:4",
          "9:16",
          "9:21",
        ])
        .register(z.globalRegistry, {
          description: "The aspect ratio of the generated image.",
        }),
    ),
    output_format: z.optional(
      z.enum(["jpeg", "png"]).register(z.globalRegistry, {
        description: "The format of the generated image.",
      }),
    ),
    image_url: z.union([z.string(), z.string()]),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
        }),
      )
      .default(false),
    safety_tolerance: z.optional(
      z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
        description:
          "The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.",
      }),
    ),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
        }),
      )
      .default(3.5),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: "Number of inference steps for sampling.",
        }),
      )
      .default(30),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          "The same seed and the same prompt given to the same version of the model will output the same image every time.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "Input model for photo restoration endpoint.",
  });

/**
 * TextRemovalOutput
 */
export const zImageEditingTextRemovalOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * TextRemovalInput
 *
 * Input model for text removal endpoint.
 */
export const zImageEditingTextRemovalInput = z
  .object({
    aspect_ratio: z.optional(
      z
        .enum([
          "21:9",
          "16:9",
          "4:3",
          "3:2",
          "1:1",
          "2:3",
          "3:4",
          "9:16",
          "9:21",
        ])
        .register(z.globalRegistry, {
          description: "The aspect ratio of the generated image.",
        }),
    ),
    output_format: z.optional(
      z.enum(["jpeg", "png"]).register(z.globalRegistry, {
        description: "The format of the generated image.",
      }),
    ),
    image_url: z.union([z.string(), z.string()]),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
        }),
      )
      .default(false),
    safety_tolerance: z.optional(
      z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
        description:
          "The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.",
      }),
    ),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
        }),
      )
      .default(3.5),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: "Number of inference steps for sampling.",
        }),
      )
      .default(30),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          "The same seed and the same prompt given to the same version of the model will output the same image every time.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "Input model for text removal endpoint.",
  });

/**
 * Output
 */
export const zFlux1DevImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseFlux1ImageToInput
 */
export const zFlux1DevImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "The strength of the initial image. Higher strength values are better for this model.",
      }),
    )
    .default(0.95),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(40),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ",
      }),
    )
    .default(3.5),
});

/**
 * Output
 */
export const zFlux1DevReduxOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseFlux1ReduxInput
 */
export const zFlux1DevReduxInput = z.object({
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ",
      }),
    )
    .default(3.5),
});

/**
 * Output
 */
export const zFlux1SchnellReduxOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * SchnellFlux1ReduxInput
 */
export const zFlux1SchnellReduxInput = z.object({
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(12).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(4),
  seed: z.optional(z.union([z.int(), z.unknown()])),
});

/**
 * T2IOutput
 */
export const zLumaPhotonReframeOutput = z.object({
  images: z.array(zFile).register(z.globalRegistry, {
    description: "The generated image",
  }),
});

/**
 * ReframeImageRequest
 */
export const zLumaPhotonReframeInput = z.object({
  prompt: z.optional(
    z.string().min(3).max(5000).register(z.globalRegistry, {
      description: "Optional prompt for reframing",
    }),
  ),
  aspect_ratio: z
    .enum(["1:1", "16:9", "9:16", "4:3", "3:4", "21:9", "9:21"])
    .register(z.globalRegistry, {
      description: "The aspect ratio of the reframed image",
    }),
  y_start: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Start Y coordinate for reframing",
    }),
  ),
  x_end: z.optional(
    z.int().register(z.globalRegistry, {
      description: "End X coordinate for reframing",
    }),
  ),
  y_end: z.optional(
    z.int().register(z.globalRegistry, {
      description: "End Y coordinate for reframing",
    }),
  ),
  grid_position_y: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Y position of the grid for reframing",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  grid_position_x: z.optional(
    z.int().register(z.globalRegistry, {
      description: "X position of the grid for reframing",
    }),
  ),
  x_start: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Start X coordinate for reframing",
    }),
  ),
});

/**
 * T2IOutput
 */
export const zLumaPhotonFlashReframeOutput = z.object({
  images: z.array(zFile).register(z.globalRegistry, {
    description: "The generated image",
  }),
});

/**
 * ReframeImageRequest
 */
export const zLumaPhotonFlashReframeInput = z.object({
  prompt: z.optional(
    z.string().min(3).max(5000).register(z.globalRegistry, {
      description: "Optional prompt for reframing",
    }),
  ),
  aspect_ratio: z
    .enum(["1:1", "16:9", "9:16", "4:3", "3:4", "21:9", "9:21"])
    .register(z.globalRegistry, {
      description: "The aspect ratio of the reframed image",
    }),
  y_start: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Start Y coordinate for reframing",
    }),
  ),
  x_end: z.optional(
    z.int().register(z.globalRegistry, {
      description: "End X coordinate for reframing",
    }),
  ),
  y_end: z.optional(
    z.int().register(z.globalRegistry, {
      description: "End Y coordinate for reframing",
    }),
  ),
  grid_position_y: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Y position of the grid for reframing",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  grid_position_x: z.optional(
    z.int().register(z.globalRegistry, {
      description: "X position of the grid for reframing",
    }),
  ),
  x_start: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Start X coordinate for reframing",
    }),
  ),
});

/**
 * BabyVersionOutput
 */
export const zImageEditingBabyVersionOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * BabyVersionInput
 *
 * Input model for baby version endpoint.
 */
export const zImageEditingBabyVersionInput = z
  .object({
    aspect_ratio: z.optional(
      z
        .enum([
          "21:9",
          "16:9",
          "4:3",
          "3:2",
          "1:1",
          "2:3",
          "3:4",
          "9:16",
          "9:21",
        ])
        .register(z.globalRegistry, {
          description: "The aspect ratio of the generated image.",
        }),
    ),
    output_format: z.optional(
      z.enum(["jpeg", "png"]).register(z.globalRegistry, {
        description: "The format of the generated image.",
      }),
    ),
    image_url: z.union([z.string(), z.string()]),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
        }),
      )
      .default(false),
    safety_tolerance: z.optional(
      z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
        description:
          "The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.",
      }),
    ),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
        }),
      )
      .default(3.5),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: "Number of inference steps for sampling.",
        }),
      )
      .default(30),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          "The same seed and the same prompt given to the same version of the model will output the same image every time.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "Input model for baby version endpoint.",
  });

/**
 * ReframeOutput
 */
export const zImageEditingReframeOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * ReframeInput
 */
export const zImageEditingReframeInput = z.object({
  aspect_ratio: z.optional(
    z
      .enum(["21:9", "16:9", "4:3", "3:2", "1:1", "2:3", "3:4", "9:16", "9:21"])
      .register(z.globalRegistry, {
        description: "The desired aspect ratio for the reframed image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps for sampling.",
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The same seed and the same prompt given to the same version of the model will output the same image every time.",
    }),
  ),
});

/**
 * T2IOutput
 */
export const zLumaPhotonModifyOutput = z.object({
  images: z.array(zFile).register(z.globalRegistry, {
    description: "The generated image",
  }),
});

/**
 * ModifyImageRequest
 */
export const zLumaPhotonModifyInput = z.object({
  prompt: z.optional(
    z.string().min(3).max(5000).register(z.globalRegistry, {
      description: "Instruction for modifying the image",
    }),
  ),
  aspect_ratio: z
    .enum(["1:1", "16:9", "9:16", "4:3", "3:4", "21:9", "9:21"])
    .register(z.globalRegistry, {
      description: "The aspect ratio of the reframed image",
    }),
  strength: z.number().gte(0).lte(1).register(z.globalRegistry, {
    description:
      "The strength of the initial image. Higher strength values are corresponding to more influence of the initial image on the output.",
  }),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * T2IOutput
 */
export const zLumaPhotonFlashModifyOutput = z.object({
  images: z.array(zFile).register(z.globalRegistry, {
    description: "The generated image",
  }),
});

/**
 * ModifyImageRequest
 */
export const zLumaPhotonFlashModifyInput = z.object({
  prompt: z.optional(
    z.string().min(3).max(5000).register(z.globalRegistry, {
      description: "Instruction for modifying the image",
    }),
  ),
  aspect_ratio: z
    .enum(["1:1", "16:9", "9:16", "4:3", "3:4", "21:9", "9:21"])
    .register(z.globalRegistry, {
      description: "The aspect ratio of the reframed image",
    }),
  strength: z.number().gte(0).lte(1).register(z.globalRegistry, {
    description:
      "The strength of the initial image. Higher strength values are corresponding to more influence of the initial image on the output.",
  }),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * FrameOutput
 */
export const zFfmpegApiExtractFrameOutput = z.object({
  images: z.array(zImageType3),
});

/**
 * FrameInput
 */
export const zFfmpegApiExtractFrameInput = z.object({
  video_url: z.union([z.string(), z.string()]),
  frame_type: z.optional(
    z.enum(["first", "middle", "last"]).register(z.globalRegistry, {
      description:
        "Type of frame to extract: first, middle, or last frame of the video",
    }),
  ),
});

/**
 * VectorizeOutput
 */
export const zRecraftVectorizeOutput = z.object({
  image: zFile,
});

/**
 * VectorizeInput
 */
export const zRecraftVectorizeInput = z.object({
  image_url: z.union([z.string(), z.string()]),
});

/**
 * Output
 */
export const zObjectRemovalOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated images with objects removed.",
  }),
});

/**
 * PromptInput
 */
export const zObjectRemovalInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "Text description of the object to remove.",
  }),
  mask_expansion: z
    .optional(
      z.int().gte(0).lte(50).register(z.globalRegistry, {
        description: "Amount of pixels to expand the mask by. Range: 0-50",
      }),
    )
    .default(15),
  model: z.optional(
    z.enum(["low_quality", "medium_quality", "high_quality", "best_quality"]),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * Output
 */
export const zObjectRemovalMaskOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated images with objects removed.",
  }),
});

/**
 * MaskInput
 */
export const zObjectRemovalMaskInput = z.object({
  model: z.optional(
    z.enum(["low_quality", "medium_quality", "high_quality", "best_quality"]),
  ),
  mask_expansion: z
    .optional(
      z.int().gte(0).lte(50).register(z.globalRegistry, {
        description: "Amount of pixels to expand the mask by. Range: 0-50",
      }),
    )
    .default(15),
  mask_url: z.union([z.string(), z.string()]),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * BBoxPromptBase
 */
export const zBBoxPromptBase = z.object({
  y_min: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Y Min Coordinate of the box (0-1)",
      }),
    )
    .default(0),
  x_max: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "X Max Coordinate of the prompt (0-1)",
      }),
    )
    .default(0),
  x_min: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "X Min Coordinate of the box (0-1)",
      }),
    )
    .default(0),
  y_max: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Y Max Coordinate of the prompt (0-1)",
      }),
    )
    .default(0),
});

/**
 * Output
 */
export const zObjectRemovalBboxOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated images with objects removed.",
  }),
});

/**
 * BboxInput
 */
export const zObjectRemovalBboxInput = z.object({
  model: z.optional(
    z.enum(["low_quality", "medium_quality", "high_quality", "best_quality"]),
  ),
  mask_expansion: z
    .optional(
      z.int().gte(0).lte(50).register(z.globalRegistry, {
        description: "Amount of pixels to expand the mask by. Range: 0-50",
      }),
    )
    .default(15),
  box_prompts: z
    .optional(
      z.array(zBBoxPromptBase).register(z.globalRegistry, {
        description:
          "List of bounding box coordinates to erase (only one box prompt is supported)",
      }),
    )
    .default([]),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * Output
 */
export const zPasdOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated super-resolved images",
  }),
  timings: z.optional(
    z.record(z.string(), z.number()).register(z.globalRegistry, {
      description: "Timing information for different processing stages",
    }),
  ),
});

/**
 * Input
 */
export const zPasdInput = z.object({
  conditioning_scale: z
    .optional(
      z.number().gte(0.1).lte(1).register(z.globalRegistry, {
        description: "ControlNet conditioning scale (0.1-1.0)",
      }),
    )
    .default(0.8),
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Additional prompt to guide super-resolution",
      }),
    )
    .default(""),
  image_url: z.union([z.string(), z.string()]),
  steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps (10-50)",
      }),
    )
    .default(25),
  scale: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "Upscaling factor (1-4x)",
      }),
    )
    .default(2),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description: "Guidance scale for diffusion (1.0-20.0)",
      }),
    )
    .default(7),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Negative prompt to avoid unwanted artifacts",
      }),
    )
    .default(
      "blurry, dirty, messy, frames, deformed, dotted, noise, raster lines, unclear, lowres, over-smoothed, painting, ai generated",
    ),
});

/**
 * Output
 */
export const zChainOfZoomOutput = z.object({
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "List of intermediate images",
  }),
  zoom_center: z.array(z.number()).register(z.globalRegistry, {
    description: "Center coordinates used for zoom",
  }),
  scale: z.number().register(z.globalRegistry, {
    description: "Actual linear zoom scale applied",
  }),
});

/**
 * Input
 */
export const zChainOfZoomInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  center_y: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Y coordinate of zoom center (0-1)",
      }),
    )
    .default(0.5),
  scale: z
    .optional(
      z.number().gte(1).lte(8).register(z.globalRegistry, {
        description: "Zoom scale in powers of 2",
      }),
    )
    .default(5),
  center_x: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "X coordinate of zoom center (0-1)",
      }),
    )
    .default(0.5),
  user_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Additional prompt text to guide the zoom enhancement",
      }),
    )
    .default(""),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * V16Output
 */
export const zFashnTryonV16Output = z.object({
  images: z.array(zFile),
});

/**
 * V16Input
 */
export const zFashnTryonV16Input = z.object({
  model_image: z.string().register(z.globalRegistry, {
    description: "URL or base64 of the model image",
  }),
  moderation_level: z.optional(
    z.enum(["none", "permissive", "conservative"]).register(z.globalRegistry, {
      description:
        "Content moderation level for garment images. 'none' disables moderation, 'permissive' blocks only explicit content, 'conservative' also blocks underwear and swimwear.",
    }),
  ),
  garment_photo_type: z.optional(
    z.enum(["auto", "model", "flat-lay"]).register(z.globalRegistry, {
      description:
        "Specifies the type of garment photo to optimize internal parameters for better performance. 'model' is for photos of garments on a model, 'flat-lay' is for flat-lay or ghost mannequin images, and 'auto' attempts to automatically detect the photo type.",
    }),
  ),
  garment_image: z.string().register(z.globalRegistry, {
    description: "URL or base64 of the garment image",
  }),
  category: z.optional(
    z
      .enum(["tops", "bottoms", "one-pieces", "auto"])
      .register(z.globalRegistry, {
        description:
          "Category of the garment to try-on. 'auto' will attempt to automatically detect the category of the garment.",
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  segmentation_free: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Disables human parsing on the model image.",
      }),
    )
    .default(true),
  num_samples: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "Number of images to generate in a single run. Image generation has a random element in it, so trying multiple images at once increases the chances of getting a good result.",
      }),
    )
    .default(1),
  mode: z.optional(
    z.enum(["performance", "balanced", "quality"]).register(z.globalRegistry, {
      description:
        "Specifies the mode of operation. 'performance' mode is faster but may sacrifice quality, 'balanced' mode is a balance between speed and quality, and 'quality' mode is slower but produces higher quality results.",
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Sets random operations to a fixed state. Use the same seed to reproduce results with the same inputs, or different seed to force different results.",
    }),
  ),
  output_format: z.optional(
    z.enum(["png", "jpeg"]).register(z.globalRegistry, {
      description:
        "Output format of the generated images. 'png' is highest quality, while 'jpeg' is faster",
    }),
  ),
});

/**
 * KontextEditOutput
 */
export const zFluxKontextLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseKontextEditInput
 */
export const zFluxKontextLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to edit the image.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  resolution_mode: z.optional(
    z
      .enum([
        "auto",
        "match_input",
        "1:1",
        "16:9",
        "21:9",
        "3:2",
        "2:3",
        "4:5",
        "5:4",
        "3:4",
        "4:3",
        "9:16",
        "9:21",
      ])
      .register(z.globalRegistry, {
        description:
          "\n            Determines how the output resolution is set for image editing.\n            - `auto`: The model selects an optimal resolution from a predefined set that best matches the input image's aspect ratio. This is the recommended setting for most use cases as it's what the model was trained on.\n            - `match_input`: The model will attempt to use the same resolution as the input image. The resolution will be adjusted to be compatible with the model's requirements (e.g. dimensions must be multiples of 16 and within supported limits).\n            Apart from these, a few aspect ratios are also supported.\n            ",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(2.5),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(30),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * PlushieStyleOutput
 */
export const zImageEditingPlushieStyleOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * PlushieStyleInput
 *
 * Input model for plushie style endpoint.
 */
export const zImageEditingPlushieStyleInput = z
  .object({
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the LoRA effect.",
        }),
      )
      .default(1),
    image_url: z.union([z.string(), z.string()]),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
        }),
      )
      .default(3.5),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: "Number of inference steps for sampling.",
        }),
      )
      .default(30),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          "The same seed and the same prompt given to the same version of the model will output the same image every time.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "Input model for plushie style endpoint.",
  });

/**
 * WojakStyleOutput
 */
export const zImageEditingWojakStyleOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * WojakStyleInput
 *
 * Input model for wojak style endpoint.
 */
export const zImageEditingWojakStyleInput = z
  .object({
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the LoRA effect.",
        }),
      )
      .default(1),
    image_url: z.union([z.string(), z.string()]),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
        }),
      )
      .default(3.5),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: "Number of inference steps for sampling.",
        }),
      )
      .default(30),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          "The same seed and the same prompt given to the same version of the model will output the same image every time.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "Input model for wojak style endpoint.",
  });

/**
 * BroccoliHaircutOutput
 */
export const zImageEditingBroccoliHaircutOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * BroccoliHaircutInput
 *
 * Input model for broccoli haircut endpoint.
 */
export const zImageEditingBroccoliHaircutInput = z
  .object({
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the LoRA effect.",
        }),
      )
      .default(1),
    image_url: z.union([z.string(), z.string()]),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
        }),
      )
      .default(3.5),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: "Number of inference steps for sampling.",
        }),
      )
      .default(30),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          "The same seed and the same prompt given to the same version of the model will output the same image every time.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "Input model for broccoli haircut endpoint.",
  });

/**
 * ImageUpscaleOutput
 */
export const zTopazUpscaleImageOutput = z.object({
  image: zFile,
});

/**
 * ImageUpscaleRequest
 */
export const zTopazUpscaleImageInput = z.object({
  face_enhancement_creativity: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "Creativity level for face enhancement. 0.0 means no creativity, 1.0 means maximum creativity. Ignored if face ehnancement is disabled.",
      }),
    )
    .default(0),
  face_enhancement_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "Strength of the face enhancement. 0.0 means no enhancement, 1.0 means maximum enhancement. Ignored if face ehnancement is disabled.",
      }),
    )
    .default(0.8),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "Output format of the upscaled image.",
    }),
  ),
  face_enhancement: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to apply face enhancement to the image.",
      }),
    )
    .default(true),
  image_url: z.union([z.string(), z.string()]),
  model: z.optional(
    z
      .enum([
        "Low Resolution V2",
        "Standard V2",
        "CGI",
        "High Fidelity V2",
        "Text Refine",
        "Recovery",
        "Redefine",
        "Recovery V2",
      ])
      .register(z.globalRegistry, {
        description: "Model to use for image enhancement.",
      }),
  ),
  subject_detection: z.optional(
    z.enum(["All", "Foreground", "Background"]).register(z.globalRegistry, {
      description: "Subject detection mode for the image enhancement.",
    }),
  ),
  crop_to_fill: z.optional(z.boolean()).default(false),
  upscale_factor: z
    .optional(
      z.number().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "Factor to upscale the video by (e.g. 2.0 doubles width and height)",
      }),
    )
    .default(2),
});

/**
 * YouTubeThumbnailsOutput
 */
export const zImageEditingYoutubeThumbnailsOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * YouTubeThumbnailsInput
 *
 * Input model for YouTube thumbnails endpoint.
 */
export const zImageEditingYoutubeThumbnailsInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The text to include in the YouTube thumbnail.",
        }),
      )
      .default("Generate youtube thumbnails"),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the LoRA effect.",
        }),
      )
      .default(0.5),
    image_url: z.union([z.string(), z.string()]),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
        }),
      )
      .default(3.5),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: "Number of inference steps for sampling.",
        }),
      )
      .default(30),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          "The same seed and the same prompt given to the same version of the model will output the same image every time.",
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: "Input model for YouTube thumbnails endpoint.",
  });

/**
 * BlurOutput
 */
export const zPostProcessingBlurOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The processed images with blur effect",
  }),
});

/**
 * BlurInput
 */
export const zPostProcessingBlurInput = z.object({
  blur_sigma: z
    .optional(
      z.number().gte(0.1).lte(10).register(z.globalRegistry, {
        description: "Sigma for Gaussian blur",
      }),
    )
    .default(1),
  blur_radius: z
    .optional(
      z.int().gte(0).lte(31).register(z.globalRegistry, {
        description: "Blur radius",
      }),
    )
    .default(3),
  blur_type: z.optional(
    z.enum(["gaussian", "kuwahara"]).register(z.globalRegistry, {
      description: "Type of blur to apply",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * ChromaticAberrationOutput
 */
export const zPostProcessingChromaticAberrationOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The processed images with chromatic aberration effect",
  }),
});

/**
 * ChromaticAberrationInput
 */
export const zPostProcessingChromaticAberrationInput = z.object({
  blue_shift: z
    .optional(
      z.int().gte(-20).lte(20).register(z.globalRegistry, {
        description: "Blue channel shift amount",
      }),
    )
    .default(0),
  red_shift: z
    .optional(
      z.int().gte(-20).lte(20).register(z.globalRegistry, {
        description: "Red channel shift amount",
      }),
    )
    .default(0),
  green_direction: z.optional(
    z.enum(["horizontal", "vertical"]).register(z.globalRegistry, {
      description: "Green channel shift direction",
    }),
  ),
  blue_direction: z.optional(
    z.enum(["horizontal", "vertical"]).register(z.globalRegistry, {
      description: "Blue channel shift direction",
    }),
  ),
  red_direction: z.optional(
    z.enum(["horizontal", "vertical"]).register(z.globalRegistry, {
      description: "Red channel shift direction",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  green_shift: z
    .optional(
      z.int().gte(-20).lte(20).register(z.globalRegistry, {
        description: "Green channel shift amount",
      }),
    )
    .default(0),
});

/**
 * ColorCorrectionOutput
 */
export const zPostProcessingColorCorrectionOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The processed images with color correction",
  }),
});

/**
 * ColorCorrectionInput
 */
export const zPostProcessingColorCorrectionInput = z.object({
  gamma: z
    .optional(
      z.number().gte(0.2).lte(2.2).register(z.globalRegistry, {
        description: "Gamma adjustment",
      }),
    )
    .default(1),
  saturation: z
    .optional(
      z.number().gte(-100).lte(100).register(z.globalRegistry, {
        description: "Saturation adjustment",
      }),
    )
    .default(0),
  temperature: z
    .optional(
      z.number().gte(-100).lte(100).register(z.globalRegistry, {
        description: "Color temperature adjustment",
      }),
    )
    .default(0),
  brightness: z
    .optional(
      z.number().gte(-100).lte(100).register(z.globalRegistry, {
        description: "Brightness adjustment",
      }),
    )
    .default(0),
  contrast: z
    .optional(
      z.number().gte(-100).lte(100).register(z.globalRegistry, {
        description: "Contrast adjustment",
      }),
    )
    .default(0),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * ColorTintOutput
 */
export const zPostProcessingColorTintOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The processed images with color tint effect",
  }),
});

/**
 * ColorTintInput
 */
export const zPostProcessingColorTintInput = z.object({
  tint_strength: z
    .optional(
      z.number().gte(0.1).lte(1).register(z.globalRegistry, {
        description: "Tint strength",
      }),
    )
    .default(1),
  tint_mode: z.optional(
    z
      .enum([
        "sepia",
        "red",
        "green",
        "blue",
        "cyan",
        "magenta",
        "yellow",
        "purple",
        "orange",
        "warm",
        "cool",
        "lime",
        "navy",
        "vintage",
        "rose",
        "teal",
        "maroon",
        "peach",
        "lavender",
        "olive",
      ])
      .register(z.globalRegistry, {
        description: "Tint color mode",
      }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * DesaturateOutput
 */
export const zPostProcessingDesaturateOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The processed images with desaturation effect",
  }),
});

/**
 * DesaturateInput
 */
export const zPostProcessingDesaturateInput = z.object({
  desaturate_method: z.optional(
    z
      .enum([
        "luminance (Rec.709)",
        "luminance (Rec.601)",
        "average",
        "lightness",
      ])
      .register(z.globalRegistry, {
        description: "Desaturation method",
      }),
  ),
  desaturate_factor: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Desaturation factor",
      }),
    )
    .default(1),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * DissolveOutput
 */
export const zPostProcessingDissolveOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The processed images with dissolve effect",
  }),
});

/**
 * DissolveInput
 */
export const zPostProcessingDissolveInput = z.object({
  dissolve_factor: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Dissolve blend factor",
      }),
    )
    .default(0.5),
  dissolve_image_url: z.union([z.string(), z.string()]),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * DodgeBurnOutput
 */
export const zPostProcessingDodgeBurnOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The processed images with dodge and burn effect",
  }),
});

/**
 * DodgeBurnInput
 */
export const zPostProcessingDodgeBurnInput = z.object({
  dodge_burn_mode: z.optional(
    z
      .enum([
        "dodge",
        "burn",
        "dodge_and_burn",
        "burn_and_dodge",
        "color_dodge",
        "color_burn",
        "linear_dodge",
        "linear_burn",
      ])
      .register(z.globalRegistry, {
        description: "Dodge and burn mode",
      }),
  ),
  dodge_burn_intensity: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Dodge and burn intensity",
      }),
    )
    .default(0.5),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * GrainOutput
 */
export const zPostProcessingGrainOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The processed images with grain effect",
  }),
});

/**
 * GrainInput
 */
export const zPostProcessingGrainInput = z.object({
  grain_style: z.optional(
    z
      .enum(["modern", "analog", "kodak", "fuji", "cinematic", "newspaper"])
      .register(z.globalRegistry, {
        description: "Style of film grain to apply",
      }),
  ),
  grain_intensity: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Film grain intensity",
      }),
    )
    .default(0.4),
  grain_scale: z
    .optional(
      z.number().gte(1).lte(100).register(z.globalRegistry, {
        description: "Film grain scale",
      }),
    )
    .default(10),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * ParabolizeOutput
 */
export const zPostProcessingParabolizeOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The processed images with parabolize effect",
  }),
});

/**
 * ParabolizeInput
 */
export const zPostProcessingParabolizeInput = z.object({
  parabolize_coeff: z
    .optional(
      z.number().gte(-10).lte(10).register(z.globalRegistry, {
        description: "Parabolize coefficient",
      }),
    )
    .default(1),
  vertex_y: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Vertex Y position",
      }),
    )
    .default(0.5),
  vertex_x: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Vertex X position",
      }),
    )
    .default(0.5),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * SharpenOutput
 */
export const zPostProcessingSharpenOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The processed images with sharpen effect",
  }),
});

/**
 * SharpenInput
 */
export const zPostProcessingSharpenInput = z.object({
  sharpen_mode: z.optional(
    z.enum(["basic", "smart", "cas"]).register(z.globalRegistry, {
      description: "Type of sharpening to apply",
    }),
  ),
  sharpen_alpha: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: "Sharpen strength (for basic mode)",
      }),
    )
    .default(1),
  noise_radius: z
    .optional(
      z.int().gte(1).lte(25).register(z.globalRegistry, {
        description: "Noise radius for smart sharpen",
      }),
    )
    .default(7),
  sharpen_radius: z
    .optional(
      z.int().gte(1).lte(15).register(z.globalRegistry, {
        description: "Sharpen radius (for basic mode)",
      }),
    )
    .default(1),
  image_url: z.union([z.string(), z.string()]),
  smart_sharpen_strength: z
    .optional(
      z.number().gte(0).lte(25).register(z.globalRegistry, {
        description: "Smart sharpen strength",
      }),
    )
    .default(5),
  cas_amount: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "CAS sharpening amount",
      }),
    )
    .default(0.8),
  preserve_edges: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Edge preservation factor",
      }),
    )
    .default(0.75),
  smart_sharpen_ratio: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Smart sharpen blend ratio",
      }),
    )
    .default(0.5),
});

/**
 * SolarizeOutput
 */
export const zPostProcessingSolarizeOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The processed images with solarize effect",
  }),
});

/**
 * SolarizeInput
 */
export const zPostProcessingSolarizeInput = z.object({
  solarize_threshold: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Solarize threshold",
      }),
    )
    .default(0.5),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * VignetteOutput
 */
export const zPostProcessingVignetteOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The processed images with vignette effect",
  }),
});

/**
 * VignetteInput
 */
export const zPostProcessingVignetteInput = z.object({
  vignette_strength: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: "Vignette strength",
      }),
    )
    .default(0.5),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * RealismOutput
 */
export const zImageEditingRealismOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * RealismInput
 *
 * Input model for realism enhancement endpoint.
 */
export const zImageEditingRealismInput = z
  .object({
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the LoRA effect.",
        }),
      )
      .default(0.6),
    image_url: z.union([z.string(), z.string()]),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
        }),
      )
      .default(3.5),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: "Number of inference steps for sampling.",
        }),
      )
      .default(30),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          "The same seed and the same prompt given to the same version of the model will output the same image every time.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "Input model for realism enhancement endpoint.",
  });

/**
 * ReimagineOutput
 */
export const zBriaReimagineOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "The generated images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed value used for generation.",
  }),
});

/**
 * ReimagineInput
 */
export const zBriaReimagineInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt you would like to use to generate images.",
  }),
  num_results: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "How many images you would like to generate. When using any Guidance Method, Value is set to 1.",
      }),
    )
    .default(1),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  structure_ref_influence: z
    .optional(
      z.number().register(z.globalRegistry, {
        description:
          "The influence of the structure reference on the generated image.",
      }),
    )
    .default(0.75),
  fast: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use the fast model",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().gte(0).lte(2147483647).register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(20).lte(50).register(z.globalRegistry, {
        description:
          "The number of iterations the model goes through to refine the generated image. This parameter is optional.",
      }),
    )
    .default(30),
  structure_image_url: z.optional(z.union([z.string(), z.string()])),
});

/**
 * Output
 */
export const zCalligrapherOutput = z.object({
  images: z.array(zImage),
});

/**
 * Input
 */
export const zCalligrapherInput = z.object({
  use_context: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to prepend context reference to the input",
      }),
    )
    .default(true),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "How many images to generate",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  auto_mask_generation: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to automatically generate mask from detected text",
      }),
    )
    .default(false),
  reference_image_url: z.optional(z.union([z.string(), z.string()])),
  source_image_url: z.union([z.string(), z.string()]),
  prompt: z.string().register(z.globalRegistry, {
    description: "Text prompt to inpaint or customize",
  }),
  mask_image_url: z.optional(z.union([z.string(), z.string()])),
  source_text: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Source text to replace (if empty, masks all detected text)",
      }),
    )
    .default(""),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps (1-100)",
      }),
    )
    .default(50),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Random seed for reproducibility",
    }),
  ),
  cfg_scale: z
    .optional(
      z.number().gte(0).lte(5).register(z.globalRegistry, {
        description: "Guidance or strength scale for the model",
      }),
    )
    .default(1),
});

/**
 * VideoFile
 */
export const zVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The size of the file in bytes.",
    }),
  ),
  duration: z.optional(
    z.number().register(z.globalRegistry, {
      description: "The duration of the video",
    }),
  ),
  height: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The height of the video",
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: "The URL where the file can be downloaded from.",
  }),
  width: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The width of the video",
    }),
  ),
  fps: z.optional(
    z.number().register(z.globalRegistry, {
      description: "The FPS of the video",
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "The name of the file. It will be auto-generated if not provided.",
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The mime type of the file.",
    }),
  ),
  num_frames: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The number of frames in the video",
    }),
  ),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: "File data",
    }),
  ),
});

/**
 * FILMImageOutput
 */
export const zFilmOutput = z.object({
  images: z
    .optional(
      z.array(zImageFile).register(z.globalRegistry, {
        description: "The generated frames as individual images.",
      }),
    )
    .default([]),
  video: z.optional(zVideoFile),
});

/**
 * FILMImageInput
 */
export const zFilmInput = z.object({
  video_write_mode: z.optional(
    z.enum(["fast", "balanced", "small"]).register(z.globalRegistry, {
      description:
        "The write mode of the output video. Only applicable if output_type is 'video'.",
    }),
  ),
  num_frames: z
    .optional(
      z.int().gte(1).lte(64).register(z.globalRegistry, {
        description:
          "The number of frames to generate between the input images.",
      }),
    )
    .default(1),
  include_start: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to include the start image in the output.",
      }),
    )
    .default(false),
  video_quality: z.optional(
    z.enum(["low", "medium", "high", "maximum"]).register(z.globalRegistry, {
      description:
        "The quality of the output video. Only applicable if output_type is 'video'.",
    }),
  ),
  include_end: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to include the end image in the output.",
      }),
    )
    .default(false),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  fps: z
    .optional(
      z.int().gte(1).lte(60).register(z.globalRegistry, {
        description:
          "Frames per second for the output video. Only applicable if output_type is 'video'.",
      }),
    )
    .default(8),
  start_image_url: z.union([z.string(), z.string()]),
  end_image_url: z.union([z.string(), z.string()]),
  image_format: z.optional(
    z.enum(["png", "jpeg"]).register(z.globalRegistry, {
      description:
        "The format of the output images. Only applicable if output_type is 'images'.",
    }),
  ),
  output_type: z.optional(
    z.enum(["images", "video"]).register(z.globalRegistry, {
      description:
        "The type of output to generate; either individual images or a video.",
    }),
  ),
});

/**
 * RIFEImageOutput
 */
export const zRifeOutput = z.object({
  images: z
    .optional(
      z.array(zImage).register(z.globalRegistry, {
        description: "The generated frames as individual images.",
      }),
    )
    .default([]),
  video: z.optional(zFile),
});

/**
 * RIFEImageInput
 */
export const zRifeInput = z.object({
  output_format: z.optional(
    z.enum(["png", "jpeg"]).register(z.globalRegistry, {
      description:
        "The format of the output images. Only applicable if output_type is 'images'.",
    }),
  ),
  fps: z
    .optional(
      z.int().gte(1).lte(60).register(z.globalRegistry, {
        description:
          "Frames per second for the output video. Only applicable if output_type is 'video'.",
      }),
    )
    .default(8),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  include_end: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to include the end image in the output.",
      }),
    )
    .default(false),
  include_start: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to include the start image in the output.",
      }),
    )
    .default(false),
  num_frames: z
    .optional(
      z.int().gte(1).lte(64).register(z.globalRegistry, {
        description:
          "The number of frames to generate between the input images.",
      }),
    )
    .default(1),
  end_image_url: z.union([z.string(), z.string()]),
  output_type: z.optional(
    z.enum(["images", "video"]).register(z.globalRegistry, {
      description:
        "The type of output to generate; either individual images or a video.",
    }),
  ),
  start_image_url: z.union([z.string(), z.string()]),
});

/**
 * Output
 */
export const zHidreamE11Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseInput
 */
export const zHidreamE11Input = z.object({
  prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The prompt to generate an image from.",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your initial image when looking for a related image to show you.\n        ",
      }),
    )
    .default(2),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(50),
  target_image_description: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "The description of the target image after your edits have been made. Leave this blank to allow the model to use its own imagination.",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default("low resolution, blur"),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * RetouchOutput
 */
export const zImageEditingRetouchOutput = z.object({
  images: z.array(zImage),
  seed: z.int(),
});

/**
 * RetouchInput
 *
 * Input model for retouch endpoint.
 */
export const zImageEditingRetouchInput = z
  .object({
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the LoRA effect.",
        }),
      )
      .default(1),
    image_url: z.union([z.string(), z.string()]),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
        }),
      )
      .default(3.5),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: "Number of inference steps for sampling.",
        }),
      )
      .default(30),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          "The same seed and the same prompt given to the same version of the model will output the same image every time.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "Input model for retouch endpoint.",
  });

/**
 * ImageToPanoramaResponse
 */
export const zHunyuanWorldOutput = z.object({
  image: zImage,
});

/**
 * ImageToPanoramaRequest
 */
export const zHunyuanWorldInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to use for the panorama generation.",
  }),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * KontextInpaintOutput
 */
export const zFluxKontextLoraInpaintOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseKontextInpaintInput
 */
export const zFluxKontextLoraInpaintInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt for the image to image task.",
  }),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  reference_image_url: z.union([z.string(), z.string()]),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(2.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "The strength of the initial image. Higher strength values are better for this model.",
      }),
    )
    .default(0.88),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(30),
  mask_url: z.union([z.string(), z.string()]),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * KreaReduxOutput
 */
export const zFlux1KreaReduxOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated images.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseKreaFlux1ReduxInput
 */
export const zFlux1KreaReduxInput = z.object({
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ",
      }),
    )
    .default(4.5),
});

/**
 * KreaOutput
 */
export const zFlux1KreaImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated images.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseKreaFlux1ImageToInput
 */
export const zFlux1KreaImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "The strength of the initial image. Higher strength values are better for this model.",
      }),
    )
    .default(0.95),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(40),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ",
      }),
    )
    .default(4.5),
});

/**
 * KreaReduxOutput
 */
export const zFluxKreaReduxOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated images.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseKreaReduxInput
 */
export const zFluxKreaReduxInput = z.object({
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ",
      }),
    )
    .default(4.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
});

/**
 * Output
 */
export const zFluxKreaImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseKreaImageToInput
 */
export const zFluxKreaImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "The strength of the initial image. Higher strength values are better for this model.",
      }),
    )
    .default(0.95),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ",
      }),
    )
    .default(4.5),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(40),
});

/**
 * Output
 */
export const zFluxKreaLoraImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * ImageToImageInput
 */
export const zFluxKreaLoraImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "The number of images to generate. This is always set to 1 for streaming output.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.",
      }),
    )
    .default(0.85),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * Output
 */
export const zFluxKreaLoraInpaintingOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * InpaintInput
 */
export const zFluxKreaLoraInpaintingInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "The number of images to generate. This is always set to 1 for streaming output.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.",
      }),
    )
    .default(0.85),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  mask_url: z.union([z.string(), z.string()]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * CharacterRemixOutputV3
 */
export const zIdeogramCharacterRemixOutput = z.object({
  images: z.array(zFileType2),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for the random number generator",
  }),
});

/**
 * CharacterRemixInputV3
 */
export const zIdeogramCharacterRemixInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to remix the image with",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
      z.unknown(),
    ]),
  ),
  style: z.optional(
    z.enum(["AUTO", "REALISTIC", "FICTION"]).register(z.globalRegistry, {
      description:
        "The style type to generate with. Cannot be used with style_codes.",
    }),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Determine if MagicPrompt should be used in generating the request or not.",
      }),
    )
    .default(true),
  rendering_speed: z.optional(
    z.enum(["TURBO", "BALANCED", "QUALITY"]).register(z.globalRegistry, {
      description: "The rendering speed to use.",
    }),
  ),
  reference_mask_urls: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        "A set of masks to apply to the character references. Currently only 1 mask is supported, rest will be ignored. (maximum total size 10MB across all character references). The masks should be in JPEG, PNG or WebP format",
    }),
  ),
  reference_image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "A set of images to use as character references. Currently only 1 image is supported, rest will be ignored. (maximum total size 10MB across all character references). The images should be in JPEG, PNG or WebP format",
  }),
  image_urls: z.optional(z.union([z.array(z.string()), z.unknown()])),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Description of what to exclude from an image. Descriptions in the prompt take precedence to descriptions in the negative prompt.",
      }),
    )
    .default(""),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "Number of images to generate.",
      }),
    )
    .default(1),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  color_palette: z.optional(z.union([zColorPalette, z.unknown()])),
  style_codes: z.optional(z.union([z.array(z.string()), z.unknown()])),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description: "Strength of the input image in the remix",
      }),
    )
    .default(0.8),
  seed: z.optional(z.union([z.int(), z.unknown()])),
});

/**
 * CharacterOutputV3
 */
export const zIdeogramCharacterOutput = z.object({
  images: z.array(zFileType2),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for the random number generator",
  }),
});

/**
 * BaseCharacterInputV3
 */
export const zIdeogramCharacterInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to fill the masked part of the image.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
      z.unknown(),
    ]),
  ),
  style: z.optional(
    z.enum(["AUTO", "REALISTIC", "FICTION"]).register(z.globalRegistry, {
      description:
        "The style type to generate with. Cannot be used with style_codes.",
    }),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Determine if MagicPrompt should be used in generating the request or not.",
      }),
    )
    .default(true),
  reference_mask_urls: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        "A set of masks to apply to the character references. Currently only 1 mask is supported, rest will be ignored. (maximum total size 10MB across all character references). The masks should be in JPEG, PNG or WebP format",
    }),
  ),
  rendering_speed: z.optional(
    z.enum(["TURBO", "BALANCED", "QUALITY"]).register(z.globalRegistry, {
      description: "The rendering speed to use.",
    }),
  ),
  reference_image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "A set of images to use as character references. Currently only 1 image is supported, rest will be ignored. (maximum total size 10MB across all character references). The images should be in JPEG, PNG or WebP format",
  }),
  image_urls: z.optional(z.union([z.array(z.string()), z.unknown()])),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Description of what to exclude from an image. Descriptions in the prompt take precedence to descriptions in the negative prompt.",
      }),
    )
    .default(""),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "Number of images to generate.",
      }),
    )
    .default(1),
  style_codes: z.optional(z.union([z.array(z.string()), z.unknown()])),
  color_palette: z.optional(z.union([zColorPalette, z.unknown()])),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
});

/**
 * CharacterEditOutputV3
 */
export const zIdeogramCharacterEditOutput = z.object({
  images: z.array(zFileType2),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for the random number generator",
  }),
});

/**
 * CharacterEditInputV3
 */
export const zIdeogramCharacterEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to fill the masked part of the image.",
  }),
  style: z.optional(
    z.enum(["AUTO", "REALISTIC", "FICTION"]).register(z.globalRegistry, {
      description:
        "The style type to generate with. Cannot be used with style_codes.",
    }),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Determine if MagicPrompt should be used in generating the request or not.",
      }),
    )
    .default(true),
  rendering_speed: z.optional(
    z.enum(["TURBO", "BALANCED", "QUALITY"]).register(z.globalRegistry, {
      description: "The rendering speed to use.",
    }),
  ),
  reference_mask_urls: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        "A set of masks to apply to the character references. Currently only 1 mask is supported, rest will be ignored. (maximum total size 10MB across all character references). The masks should be in JPEG, PNG or WebP format",
    }),
  ),
  reference_image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "A set of images to use as character references. Currently only 1 image is supported, rest will be ignored. (maximum total size 10MB across all character references). The images should be in JPEG, PNG or WebP format",
  }),
  image_urls: z.optional(z.union([z.array(z.string()), z.unknown()])),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "Number of images to generate.",
      }),
    )
    .default(1),
  image_url: z.union([z.string(), z.string()]),
  style_codes: z.optional(z.union([z.array(z.string()), z.unknown()])),
  color_palette: z.optional(z.union([zColorPalette, z.unknown()])),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  mask_url: z.union([z.string(), z.string()]),
});

/**
 * QwenImageOutput
 */
export const zQwenImageEditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseQwenEditImageInput
 */
export const zQwenImageEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate the image with",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(4),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The negative prompt for the generation",
      }),
    )
    .default(" "),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * NextStepResponse
 */
export const zNextstep1Output = z.object({
  image: z
    .object({
      file_size: z.optional(z.union([z.int(), z.unknown()])),
      height: z.optional(z.union([z.int(), z.unknown()])),
      file_name: z.optional(z.union([z.string(), z.unknown()])),
      content_type: z.optional(z.union([z.string(), z.unknown()])),
      url: z.string().register(z.globalRegistry, {
        description: "The URL where the file can be downloaded from.",
      }),
      width: z.optional(z.union([z.int(), z.unknown()])),
    })
    .register(z.globalRegistry, {
      description: "Generated image",
    }),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for random number generation",
  }),
});

/**
 * NextStepEditRequest
 */
export const zNextstep1Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to edit the image.",
  }),
  negative_prompt: z.string().register(z.globalRegistry, {
    description:
      "The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n        ",
  }),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * NanoBananaImageToImageOutput
 */
export const zNanoBananaEditOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The edited images.",
  }),
  description: z.string().register(z.globalRegistry, {
    description: "The description of the generated images.",
  }),
});

/**
 * NanoBananaImageToImageInput
 */
export const zNanoBananaEditInput = z.object({
  prompt: z.string().min(3).max(50000).register(z.globalRegistry, {
    description: "The prompt for image editing.",
  }),
  aspect_ratio: z.optional(
    z
      .enum([
        "auto",
        "21:9",
        "16:9",
        "3:2",
        "4:3",
        "5:4",
        "1:1",
        "4:5",
        "3:4",
        "2:3",
        "9:16",
      ])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "The URLs of the images to use for image-to-image generation or image editing.",
  }),
  limit_generations: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.",
      }),
    )
    .default(false),
});

/**
 * OutputModel
 */
export const zReimagine32Output = z.object({
  image: zImageType3,
});

/**
 * InputModel
 */
export const zReimagine32Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "Prompt for image generation.",
  }),
  depth_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Depth image preprocess.",
      }),
    )
    .default(true),
  canny_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Canny image preprocess.",
      }),
    )
    .default(true),
  depth_image_url: z.optional(z.union([z.string(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: "Guidance scale for text.",
      }),
    )
    .default(5),
  canny_image_url: z.optional(z.union([z.string(), z.unknown()])),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Negative prompt for image generation.",
      }),
    )
    .default(
      "Logo,Watermark,Ugly,Morbid,Extra fingers,Poorly drawn hands,Mutation,Blurry,Extra limbs,Gross proportions,Missing arms,Mutated hands,Long neck,Duplicate,Mutilated,Mutilated hands,Poorly drawn face,Deformed,Bad anatomy,Cloned face,Malformed limbs,Missing legs,Too many fingers",
    ),
  depth_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Depth control strength (0.0 to 1.0).",
      }),
    )
    .default(0.5),
  aspect_ratio: z.optional(
    z
      .enum(["1:1", "2:3", "3:2", "3:4", "4:3", "4:5", "5:4", "9:16", "16:9"])
      .register(z.globalRegistry, {
        description:
          "Aspect ratio. Options: 1:1, 2:3, 3:2, 3:4, 4:3, 4:5, 5:4, 9:16, 16:9",
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If true, returns the image directly in the response (increases latency).",
      }),
    )
    .default(false),
  prompt_enhancer: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to improve the prompt.",
      }),
    )
    .default(true),
  truncate_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to truncate the prompt.",
      }),
    )
    .default(true),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Random seed for reproducibility.",
      }),
    )
    .default(5555),
  canny_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Canny edge control strength (0.0 to 1.0).",
      }),
    )
    .default(0.5),
  num_inference_steps: z
    .optional(
      z.int().gte(20).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps.",
      }),
    )
    .default(30),
});

/**
 * QwenImageI2IOutput
 */
export const zQwenImageImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * QwenImageI2IInput
 */
export const zQwenImageImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate the image with",
  }),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "Acceleration level for image generation. Options: 'none', 'regular', 'high'. Higher acceleration increases speed. 'regular' balances speed and quality. 'high' is recommended for images without text.",
    }),
  ),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use up to 3 LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(2.5),
  use_turbo: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Enable turbo mode for faster generation with high quality. When enabled, uses optimized settings (10 steps, CFG=1.2).",
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The negative prompt for the generation",
      }),
    )
    .default(" "),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "Denoising strength. 1.0 = fully remake; 0.0 = preserve original.",
      }),
    )
    .default(0.6),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(250).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * NanoBananaImageToImageOutput
 */
export const zGemini25FlashImageEditOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The edited images.",
  }),
  description: z.string().register(z.globalRegistry, {
    description: "The description of the generated images.",
  }),
});

/**
 * NanoBananaImageToImageInput
 */
export const zGemini25FlashImageEditInput = z.object({
  prompt: z.string().min(3).max(50000).register(z.globalRegistry, {
    description: "The prompt for image editing.",
  }),
  aspect_ratio: z.optional(
    z
      .enum([
        "auto",
        "21:9",
        "16:9",
        "3:2",
        "4:3",
        "5:4",
        "1:1",
        "4:5",
        "3:4",
        "2:3",
        "9:16",
      ])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "The URLs of the images to use for image-to-image generation or image editing.",
  }),
  limit_generations: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.",
      }),
    )
    .default(false),
});

/**
 * USOOutputImage
 */
export const zUsoOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generation",
  }),
  images: z.array(zImage).register(z.globalRegistry, {
    description:
      "The generated images with applied style and/or subject customization",
  }),
  timings: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: "Performance timings for different stages",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "NSFW detection results for each generated image",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for generation",
  }),
});

/**
 * USOInputImage
 */
export const zUsoInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Text prompt for generation. Can be empty for pure style transfer.",
      }),
    )
    .default(""),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "Number of images to generate in parallel.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description:
        "Output image format. PNG preserves transparency, JPEG is smaller.",
    }),
  ),
  keep_size: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Preserve the layout and dimensions of the input content image. Useful for style transfer.",
      }),
    )
    .default(false),
  input_image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "List of image URLs in order: [content_image, style_image, extra_style_image].",
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If true, wait for generation and upload before returning. Increases latency but provides immediate access to images.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "How closely to follow the prompt. Higher values stick closer to the prompt.",
      }),
    )
    .default(4),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description:
          "Number of denoising steps. More steps can improve quality but increase generation time.",
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed for reproducible generation. Use same seed for consistent results.",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "What you don't want in the image. Use it to exclude unwanted elements, styles, or artifacts.",
      }),
    )
    .default(""),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Enable NSFW content detection and filtering.",
      }),
    )
    .default(true),
});

/**
 * WanI2IResponse
 */
export const zWanV22A14bImageToImageOutput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The text prompt used for image generation.",
      }),
    )
    .default(""),
  image: zFile,
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation.",
  }),
});

/**
 * WanI2IRequest
 */
export const zWanV22A14bImageToImageInput = z.object({
  shift: z.optional(z.number().gte(1).lte(10)).default(2),
  prompt: z.string().register(z.globalRegistry, {
    description: "The text prompt to guide image generation.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular"]).register(z.globalRegistry, {
      description:
        "Acceleration level to use. The more acceleration, the faster the generation, but with lower quality. The recommended value is 'regular'.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, input data will be checked for safety before processing.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: "Classifier-free guidance scale.",
      }),
    )
    .default(3.5),
  image_format: z.optional(
    z.enum(["png", "jpeg"]).register(z.globalRegistry, {
      description: "The format of the output image.",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Negative prompt for video generation.",
      }),
    )
    .default(""),
  aspect_ratio: z.optional(
    z.enum(["auto", "16:9", "9:16", "1:1"]).register(z.globalRegistry, {
      description:
        "Aspect ratio of the generated image. If 'auto', the aspect ratio will be determined automatically based on the input image.",
    }),
  ),
  enable_output_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, output video will be checked for safety after generation.",
      }),
    )
    .default(false),
  image_url: z.union([z.string(), z.string()]),
  strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "Denoising strength. 1.0 = fully remake; 0.0 = preserve original.",
      }),
    )
    .default(0.5),
  guidance_scale_2: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "Guidance scale for the second stage of the model. This is used to control the adherence to the prompt in the second stage of the model.",
      }),
    )
    .default(4),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.",
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(40).register(z.globalRegistry, {
        description:
          "Number of inference steps for sampling. Higher values give better quality but take longer.",
      }),
    )
    .default(27),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed for reproducibility. If None, a random seed is chosen.",
    }),
  ),
});

/**
 * SeedDream4EditOutput
 */
export const zBytedanceSeedreamV4EditOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "Generated images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for generation",
  }),
});

/**
 * SeedDream4EditInput
 */
export const zBytedanceSeedreamV4EditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The text prompt used to edit the image",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(6).register(z.globalRegistry, {
        description:
          "Number of separate model generations to be run with the prompt.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
        "auto",
        "auto_2K",
        "auto_4K",
      ]),
    ]),
  ),
  enhance_prompt_mode: z.optional(
    z.enum(["standard", "fast"]).register(z.globalRegistry, {
      description:
        "The mode to use for enhancing prompt enhancement. Standard mode provides higher quality results but takes longer to generate. Fast mode provides average quality results but takes less time to generate.",
    }),
  ),
  max_images: z
    .optional(
      z.int().gte(1).lte(6).register(z.globalRegistry, {
        description:
          "If set to a number greater than one, enables multi-image generation. The model will potentially return up to `max_images` images every generation, and in total, `num_images` generations will be carried out. In total, the number of images generated will be between `num_images` and `max_images*num_images`. The total number of images (image inputs + image outputs) must not exceed 15",
      }),
    )
    .default(1),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed to control the stochasticity of image generation.",
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "List of URLs of input images for editing. Presently, up to 10 image inputs are allowed. If over 10 images are sent, only the last 10 will be used.",
  }),
});

/**
 * ReferenceToImageOutput
 */
export const zViduReferenceToImageOutput = z.object({
  image: zImage,
});

/**
 * ReferenceToImageRequest
 */
export const zViduReferenceToImageInput = z.object({
  prompt: z.string().max(1500).register(z.globalRegistry, {
    description: "Text prompt for video generation, max 1500 characters",
  }),
  aspect_ratio: z.optional(
    z.enum(["16:9", "9:16", "1:1"]).register(z.globalRegistry, {
      description: "The aspect ratio of the output video",
    }),
  ),
  reference_image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "URLs of the reference images to use for consistent subject appearance",
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Random seed for generation",
    }),
  ),
});

/**
 * QwenImageOutput
 */
export const zQwenImageEditLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseQwenEditImageLoRAInput
 */
export const zQwenImageEditLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate the image with",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use up to 3 LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(4),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The negative prompt for the generation",
      }),
    )
    .default(" "),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zFlux1SrpoImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseSRPOFlux1ImageToInput
 */
export const zFlux1SrpoImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "The strength of the initial image. Higher strength values are better for this model.",
      }),
    )
    .default(0.95),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(40),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ",
      }),
    )
    .default(4.5),
});

/**
 * Output
 */
export const zFluxSrpoImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseSRPOImageToInput
 */
export const zFluxSrpoImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "The strength of the initial image. Higher strength values are better for this model.",
      }),
    )
    .default(0.95),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ",
      }),
    )
    .default(4.5),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(40),
});

/**
 * QwenImageInpaintOutput
 */
export const zQwenImageEditInpaintOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseQwenEditInpaintImageInput
 */
export const zQwenImageEditInpaintInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate the image with",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(4),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The negative prompt for the generation",
      }),
    )
    .default(" "),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description: "Strength of noising process for inpainting",
      }),
    )
    .default(0.93),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  mask_url: z.union([z.string(), z.string()]),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(30),
});

/**
 * MakeupApplicationOutput
 */
export const zImageAppsV2MakeupApplicationOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "Portrait with applied makeup",
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: "Total inference time in milliseconds",
  }),
});

/**
 * AspectRatio
 *
 * Aspect ratio model that calculates 4K resolution dimensions
 */
export const zAspectRatio = z
  .object({
    ratio: z.optional(
      z.enum(["1:1", "16:9", "9:16", "4:3", "3:4"]).register(z.globalRegistry, {
        description: "Aspect ratio for 4K resolution output",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "Aspect ratio model that calculates 4K resolution dimensions",
  });

/**
 * MakeupApplicationInput
 */
export const zImageAppsV2MakeupApplicationInput = z.object({
  aspect_ratio: z.optional(zAspectRatio),
  intensity: z.optional(z.enum(["light", "medium", "heavy", "dramatic"])),
  makeup_style: z.optional(
    z.enum([
      "natural",
      "glamorous",
      "smoky_eyes",
      "bold_lips",
      "no_makeup",
      "remove_makeup",
      "dramatic",
      "bridal",
      "professional",
      "korean_style",
      "artistic",
    ]),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * AgeModifyOutput
 */
export const zImageAppsV2AgeModifyOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "Portrait with modified age",
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: "Total inference time in milliseconds",
  }),
});

/**
 * AgeModifyInput
 */
export const zImageAppsV2AgeModifyInput = z.object({
  image_url: z.union([z.string(), z.string()]),
  aspect_ratio: z.optional(zAspectRatio),
  preserve_identity: z.optional(z.boolean()).default(true),
  target_age: z.optional(z.int().gte(6).lte(100)).default(30),
});

/**
 * CityTeleportOutput
 */
export const zImageAppsV2CityTeleportOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "Person teleported to city location",
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: "Total inference time in milliseconds",
  }),
});

/**
 * CityTeleportInput
 */
export const zImageAppsV2CityTeleportInput = z.object({
  city_image_url: z.optional(z.union([z.string(), z.unknown()])),
  aspect_ratio: z.optional(zAspectRatio),
  city_name: z.string().register(z.globalRegistry, {
    description: "City name (used when city_image_url is not provided)",
  }),
  photo_shot: z.optional(
    z
      .enum([
        "extreme_close_up",
        "close_up",
        "medium_close_up",
        "medium_shot",
        "medium_long_shot",
        "long_shot",
        "extreme_long_shot",
        "full_body",
      ])
      .register(z.globalRegistry, {
        description: "Type of photo shot",
      }),
  ),
  camera_angle: z.optional(
    z
      .enum([
        "eye_level",
        "low_angle",
        "high_angle",
        "dutch_angle",
        "birds_eye_view",
        "worms_eye_view",
        "overhead",
        "side_angle",
      ])
      .register(z.globalRegistry, {
        description: "Camera angle for the shot",
      }),
  ),
  person_image_url: z.union([z.string(), z.string()]),
});

/**
 * ExpressionChangeOutput
 */
export const zImageAppsV2ExpressionChangeOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "Portrait with changed expression",
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: "Total inference time in milliseconds",
  }),
});

/**
 * ExpressionChangeInput
 */
export const zImageAppsV2ExpressionChangeInput = z.object({
  aspect_ratio: z.optional(zAspectRatio),
  target_expression: z.optional(
    z.enum([
      "smile",
      "surprise",
      "glare",
      "panic",
      "shyness",
      "laugh",
      "cry",
      "angry",
      "sad",
      "happy",
      "excited",
      "shocked",
      "confused",
      "focused",
      "dreamy",
      "serious",
      "playful",
      "mysterious",
      "confident",
      "thoughtful",
    ]),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * HairChangeOutput
 */
export const zImageAppsV2HairChangeOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "Portrait with changed hair",
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: "Total inference time in milliseconds",
  }),
});

/**
 * HairChangeInput
 */
export const zImageAppsV2HairChangeInput = z.object({
  target_hairstyle: z.optional(
    z.enum([
      "short_hair",
      "medium_long_hair",
      "long_hair",
      "curly_hair",
      "wavy_hair",
      "high_ponytail",
      "bun",
      "bob_cut",
      "pixie_cut",
      "braids",
      "straight_hair",
      "afro",
      "dreadlocks",
      "buzz_cut",
      "mohawk",
      "bangs",
      "side_part",
      "middle_part",
    ]),
  ),
  aspect_ratio: z.optional(zAspectRatio),
  hair_color: z.optional(
    z.enum([
      "black",
      "dark_brown",
      "light_brown",
      "blonde",
      "platinum_blonde",
      "red",
      "auburn",
      "gray",
      "silver",
      "blue",
      "green",
      "purple",
      "pink",
      "rainbow",
      "natural",
      "highlights",
      "ombre",
      "balayage",
    ]),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * HeadshotOutput
 */
export const zImageAppsV2HeadshotPhotoOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "Professional headshot image",
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: "Total inference time in milliseconds",
  }),
});

/**
 * HeadshotInput
 */
export const zImageAppsV2HeadshotPhotoInput = z.object({
  aspect_ratio: z.optional(zAspectRatio),
  background_style: z.optional(
    z.enum(["professional", "corporate", "clean", "gradient"]),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * ObjectRemovalOutput
 */
export const zImageAppsV2ObjectRemovalOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "Image with object removed",
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: "Total inference time in milliseconds",
  }),
});

/**
 * ObjectRemovalInput
 */
export const zImageAppsV2ObjectRemovalInput = z.object({
  aspect_ratio: z.optional(zAspectRatio),
  object_to_remove: z.string().register(z.globalRegistry, {
    description: "Object to remove",
  }),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * PerspectiveOutput
 */
export const zImageAppsV2PerspectiveOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "Image with changed perspective",
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: "Total inference time in milliseconds",
  }),
});

/**
 * PerspectiveInput
 */
export const zImageAppsV2PerspectiveInput = z.object({
  aspect_ratio: z.optional(zAspectRatio),
  target_perspective: z.optional(
    z.enum([
      "front",
      "left_side",
      "right_side",
      "back",
      "top_down",
      "bottom_up",
      "birds_eye",
      "three_quarter_left",
      "three_quarter_right",
    ]),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * PhotographyEffectsOutput
 */
export const zImageAppsV2PhotographyEffectsOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "Image with photography effects",
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: "Total inference time in milliseconds",
  }),
});

/**
 * PhotographyEffectsInput
 */
export const zImageAppsV2PhotographyEffectsInput = z.object({
  effect_type: z.optional(
    z.enum([
      "film",
      "vintage_film",
      "portrait_photography",
      "fashion_photography",
      "street_photography",
      "sepia_tone",
      "film_grain",
      "light_leaks",
      "vignette_effect",
      "instant_camera",
      "golden_hour",
      "dramatic_lighting",
      "soft_focus",
      "bokeh_effect",
      "high_contrast",
      "double_exposure",
    ]),
  ),
  aspect_ratio: z.optional(zAspectRatio),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * PortraitOutput
 */
export const zImageAppsV2PortraitEnhanceOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "Enhanced portrait",
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: "Total inference time in milliseconds",
  }),
});

/**
 * PortraitInput
 */
export const zImageAppsV2PortraitEnhanceInput = z.object({
  aspect_ratio: z.optional(zAspectRatio),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * PhotoRestorationOutput
 */
export const zImageAppsV2PhotoRestorationOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "Restored photo",
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: "Total inference time in milliseconds",
  }),
});

/**
 * PhotoRestorationInput
 */
export const zImageAppsV2PhotoRestorationInput = z.object({
  enhance_resolution: z.optional(z.boolean()).default(true),
  aspect_ratio: z.optional(zAspectRatio),
  remove_scratches: z.optional(z.boolean()).default(true),
  fix_colors: z.optional(z.boolean()).default(true),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * StyleTransferOutput
 */
export const zImageAppsV2StyleTransferOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "Image with transferred style",
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: "Total inference time in milliseconds",
  }),
});

/**
 * StyleTransferInput
 */
export const zImageAppsV2StyleTransferInput = z.object({
  target_style: z.optional(
    z.enum([
      "anime_character",
      "cartoon_3d",
      "hand_drawn_animation",
      "cyberpunk_future",
      "anime_game_style",
      "comic_book_animation",
      "animated_series",
      "cartoon_animation",
      "lofi_aesthetic",
      "cottagecore",
      "dark_academia",
      "y2k",
      "vaporwave",
      "liminal_space",
      "weirdcore",
      "dreamcore",
      "synthwave",
      "outrun",
      "photorealistic",
      "hyperrealistic",
      "digital_art",
      "concept_art",
      "impressionist",
      "anime",
      "pixel_art",
      "claymation",
    ]),
  ),
  aspect_ratio: z.optional(zAspectRatio),
  style_reference_image_url: z.optional(z.union([z.string(), z.unknown()])),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * RelightingOutput
 */
export const zImageAppsV2RelightingOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "Image with new lighting",
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: "Total inference time in milliseconds",
  }),
});

/**
 * RelightingInput
 */
export const zImageAppsV2RelightingInput = z.object({
  aspect_ratio: z.optional(zAspectRatio),
  lighting_style: z.optional(
    z.enum([
      "natural",
      "studio",
      "golden_hour",
      "blue_hour",
      "dramatic",
      "soft",
      "hard",
      "backlight",
      "side_light",
      "front_light",
      "rim_light",
      "sunset",
      "sunrise",
      "neon",
      "candlelight",
      "moonlight",
      "spotlight",
      "ambient",
    ]),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * TextureTransformOutput
 */
export const zImageAppsV2TextureTransformOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "Image with transformed texture",
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: "Total inference time in milliseconds",
  }),
});

/**
 * TextureTransformInput
 */
export const zImageAppsV2TextureTransformInput = z.object({
  target_texture: z.optional(
    z.enum([
      "cotton",
      "denim",
      "wool",
      "felt",
      "wood",
      "leather",
      "velvet",
      "stone",
      "marble",
      "ceramic",
      "concrete",
      "brick",
      "clay",
      "foam",
      "glass",
      "metal",
      "silk",
      "fabric",
      "crystal",
      "rubber",
      "plastic",
      "lace",
    ]),
  ),
  aspect_ratio: z.optional(zAspectRatio),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * VirtualTryOnOutput
 */
export const zImageAppsV2VirtualTryOnOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "Person wearing the virtual clothing",
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: "Total inference time in milliseconds",
  }),
});

/**
 * VirtualTryOnInput
 */
export const zImageAppsV2VirtualTryOnInput = z.object({
  preserve_pose: z.optional(z.boolean()).default(true),
  aspect_ratio: z.optional(zAspectRatio),
  clothing_image_url: z.union([z.string(), z.string()]),
  person_image_url: z.union([z.string(), z.string()]),
});

/**
 * ProductPhotographyOutput
 */
export const zImageAppsV2ProductPhotographyOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "Professional studio product photography",
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: "Total inference time in milliseconds",
  }),
});

/**
 * ProductPhotographyInput
 */
export const zImageAppsV2ProductPhotographyInput = z.object({
  aspect_ratio: z.optional(zAspectRatio),
  product_image_url: z.union([z.string(), z.string()]),
});

/**
 * ProductHoldingOutput
 */
export const zImageAppsV2ProductHoldingOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "Person holding the product naturally",
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: "Total inference time in milliseconds",
  }),
});

/**
 * ProductHoldingInput
 */
export const zImageAppsV2ProductHoldingInput = z.object({
  aspect_ratio: z.optional(zAspectRatio),
  product_image_url: z.union([z.string(), z.string()]),
  person_image_url: z.union([z.string(), z.string()]),
});

/**
 * SeedVRImageOutput
 */
export const zSeedvrUpscaleImageOutput = z.object({
  image: zImageFileType2,
  seed: z.int().register(z.globalRegistry, {
    description: "The random seed used for the generation process.",
  }),
});

/**
 * SeedVRImageInput
 */
export const zSeedvrUpscaleImageInput = z.object({
  upscale_mode: z.optional(
    z.enum(["target", "factor"]).register(z.globalRegistry, {
      description:
        "The mode to use for the upscale. If 'target', the upscale factor will be calculated based on the target resolution. If 'factor', the upscale factor will be used directly.",
    }),
  ),
  noise_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The noise scale to use for the generation process.",
      }),
    )
    .default(0.1),
  output_format: z.optional(
    z.enum(["png", "jpg", "webp"]).register(z.globalRegistry, {
      description: "The format of the output image.",
    }),
  ),
  target_resolution: z.optional(
    z.enum(["720p", "1080p", "1440p", "2160p"]).register(z.globalRegistry, {
      description:
        "The target resolution to upscale to when `upscale_mode` is `target`.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  upscale_factor: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "Upscaling factor to be used. Will multiply the dimensions with this factor when `upscale_mode` is `factor`.",
      }),
    )
    .default(2),
  seed: z.optional(z.union([z.int(), z.unknown()])),
});

/**
 * QwenImageOutput
 */
export const zQwenImageEditPlusOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * BaseQwenEditImagePlusInput
 */
export const zQwenImageEditPlusInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate the image with",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular"]).register(z.globalRegistry, {
      description:
        "Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(4),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: "The URLs of the images to edit.",
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The negative prompt for the generation",
      }),
    )
    .default(" "),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(100).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(50),
});

/**
 * ImageToImageOutput
 *
 * Output for image editing
 */
export const zWan25PreviewImageToImageOutput = z
  .object({
    seeds: z.array(z.int()).register(z.globalRegistry, {
      description: "The seeds used for each generated image",
    }),
    images: z.array(zImageFile).register(z.globalRegistry, {
      description: "The edited images",
    }),
    actual_prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          "The original prompt (prompt expansion is not available for image editing)",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "Output for image editing",
  });

/**
 * ImageToImageInput
 *
 * Input for image editing
 */
export const zWan25PreviewImageToImageInput = z
  .object({
    prompt: z.string().min(1).register(z.globalRegistry, {
      description:
        "The text prompt describing how to edit the image. Max 2000 characters.",
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate. Values from 1 to 4.",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
      ]),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "If set to true, the safety checker will be enabled.",
        }),
      )
      .default(true),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          "Random seed for reproducibility. If None, a random seed is chosen.",
      }),
    ),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        "URLs of images to edit. For single-image editing, provide 1 URL. For multi-reference generation, provide up to 2 URLs. If more than 2 URLs are provided, only the first 2 will be used.",
    }),
    negative_prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          "Negative prompt to describe content to avoid. Max 500 characters.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "Input for image editing",
  });

/**
 * QwenImageOutput
 */
export const zQwenImageEditImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseQwenEditImg2ImgInput
 */
export const zQwenImageEditImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate the image with",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "Strength of the image-to-image transformation. Lower values preserve more of the original image.",
      }),
    )
    .default(0.94),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(4),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The negative prompt for the generation",
      }),
    )
    .default(" "),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * LucidFluxResponse
 */
export const zLucidfluxOutput = z.object({
  image: zImage,
  seed: z.int().register(z.globalRegistry, {
    description: "Seed used for random number generation",
  }),
});

/**
 * LucidFluxRequest
 */
export const zLucidfluxInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to edit the image.",
  }),
  guidance: z
    .optional(
      z.number().gte(1).lte(30).register(z.globalRegistry, {
        description: "The guidance to use for the diffusion process.",
      }),
    )
    .default(4),
  target_height: z
    .optional(
      z.int().gte(512).lte(1024).register(z.globalRegistry, {
        description: "The height of the output image.",
      }),
    )
    .default(1024),
  image_url: z.union([z.string(), z.string()]),
  target_width: z
    .optional(
      z.int().gte(512).lte(1024).register(z.globalRegistry, {
        description: "The width of the output image.",
      }),
    )
    .default(1024),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description:
          "Number of inference steps for sampling. Higher values give better quality but take longer.",
      }),
    )
    .default(50),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Seed used for random number generation",
      }),
    )
    .default(42),
});

/**
 * QwenImageOutput
 */
export const zQwenImageEditPlusLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * BaseQwenEditImagePlusLoRAInput
 */
export const zQwenImageEditPlusLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate the image with",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular"]).register(z.globalRegistry, {
      description:
        "Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use up to 3 LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(4),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: "The URLs of the images to edit.",
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The negative prompt for the generation",
      }),
    )
    .default(" "),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * DreamOmni2Response
 */
export const zDreamomni2EditOutput = z.object({
  image: zImage,
});

/**
 * DreamOmni2Request
 */
export const zDreamomni2EditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to edit the image.",
  }),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: "List of URLs of input images for editing.",
  }),
});

/**
 * Image2PixelOutput
 */
export const zImage2PixelOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description:
      "The processed pixel-art image (PNG) and the scaled image (PNG).",
  }),
  num_colors: z.int().register(z.globalRegistry, {
    description: "The number of colors in the processed media.",
  }),
  palette: z.array(z.string()).register(z.globalRegistry, {
    description: "The palette of the processed media.",
  }),
  pixel_scale: z.int().register(z.globalRegistry, {
    description: "The detected pixel scale of the input.",
  }),
});

/**
 * Image2PixelInput
 */
export const zImage2PixelInput = z.object({
  cleanup_morph: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Apply morphological operations to remove noise.",
      }),
    )
    .default(false),
  auto_color_detect: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Enable automatic detection of optimal number of colors.",
      }),
    )
    .default(false),
  alpha_threshold: z
    .optional(
      z.int().gte(0).lte(255).register(z.globalRegistry, {
        description: "Alpha binarization threshold (0-255).",
      }),
    )
    .default(128),
  snap_grid: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Align output to the pixel grid.",
      }),
    )
    .default(true),
  fixed_palette: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        "Optional fixed color palette as hex strings (e.g., ['#000000', '#ffffff']).",
    }),
  ),
  scale: z.optional(
    z.int().gte(1).lte(64).register(z.globalRegistry, {
      description: "Force a specific pixel scale. If None, auto-detect.",
    }),
  ),
  cleanup_jaggy: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Remove isolated diagonal pixels (jaggy edge cleanup).",
      }),
    )
    .default(false),
  trim_borders: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Trim borders of the image.",
      }),
    )
    .default(false),
  background_tolerance: z
    .optional(
      z.int().gte(0).lte(255).register(z.globalRegistry, {
        description: "Background tolerance (0-255).",
      }),
    )
    .default(0),
  detect_method: z.optional(
    z.enum(["auto", "runs", "edge"]).register(z.globalRegistry, {
      description: "Scale detection method to use.",
    }),
  ),
  transparent_background: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Remove background of the image. This will check for contiguous color regions from the edges after correction and make them transparent.",
      }),
    )
    .default(false),
  downscale_method: z.optional(
    z
      .enum(["dominant", "median", "mode", "mean", "content-adaptive"])
      .register(z.globalRegistry, {
        description: "Downscaling method to produce the pixel-art output.",
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  image_url: z.union([z.string(), z.string()]),
  background_mode: z.optional(
    z.enum(["edges", "corners", "midpoints"]).register(z.globalRegistry, {
      description:
        "Controls where to flood-fill from when removing the background.",
    }),
  ),
  max_colors: z
    .optional(
      z.int().gte(1).lte(256).register(z.globalRegistry, {
        description:
          "Maximum number of colors in the output palette. Set None to disable limit.",
      }),
    )
    .default(32),
  dominant_color_threshold: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Dominant color threshold (0.0-1.0).",
      }),
    )
    .default(0.05),
});

/**
 * ReveEditOutput
 *
 * Output for Reve image editing
 */
export const zReveEditOutput = z
  .object({
    images: z.array(zImage).register(z.globalRegistry, {
      description: "The edited images",
    }),
  })
  .register(z.globalRegistry, {
    description: "Output for Reve image editing",
  });

/**
 * ReveEditInput
 *
 * Input for Reve image editing
 */
export const zReveEditInput = z
  .object({
    prompt: z.string().min(1).max(2560).register(z.globalRegistry, {
      description: "The text description of how to edit the provided image.",
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
        }),
      )
      .default(false),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "Output format for the generated image.",
      }),
    ),
    image_url: z.union([z.string(), z.string()]),
  })
  .register(z.globalRegistry, {
    description: "Input for Reve image editing",
  });

/**
 * ReveRemixOutput
 *
 * Output for Reve image remixing
 */
export const zReveRemixOutput = z
  .object({
    images: z.array(zImage).register(z.globalRegistry, {
      description: "The remixed images",
    }),
  })
  .register(z.globalRegistry, {
    description: "Output for Reve image remixing",
  });

/**
 * ReveRemixInput
 *
 * Input for Reve image remixing
 */
export const zReveRemixInput = z
  .object({
    prompt: z.string().min(1).max(2560).register(z.globalRegistry, {
      description:
        "The text description of the desired image. May include XML img tags like <img>0</img> to refer to specific images by their index in the image_urls list.",
    }),
    aspect_ratio: z.optional(
      z
        .enum(["16:9", "9:16", "3:2", "2:3", "4:3", "3:4", "1:1"])
        .register(z.globalRegistry, {
          description:
            "The desired aspect ratio of the generated image. If not provided, will be smartly chosen by the model.",
        }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
        }),
      )
      .default(false),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "Output format for the generated image.",
      }),
    ),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        "List of URLs of reference images. Must provide between 1 and 6 images (inclusive). Each image must be less than 10 MB. Supports PNG, JPEG, WebP, AVIF, and HEIF formats.",
    }),
  })
  .register(z.globalRegistry, {
    description: "Input for Reve image remixing",
  });

/**
 * EditImageResponseMini
 */
export const zGptImage1MiniEditOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images.",
  }),
});

/**
 * EditImageRequestMini
 */
export const zGptImage1MiniEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt for image generation",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "Number of images to generate",
      }),
    )
    .default(1),
  image_size: z.optional(
    z
      .enum(["auto", "1024x1024", "1536x1024", "1024x1536"])
      .register(z.globalRegistry, {
        description: "Aspect ratio for the generated image",
      }),
  ),
  background: z.optional(
    z.enum(["auto", "transparent", "opaque"]).register(z.globalRegistry, {
      description: "Background for the generated image",
    }),
  ),
  quality: z.optional(
    z.enum(["auto", "low", "medium", "high"]).register(z.globalRegistry, {
      description: "Quality for the generated image",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "Output format for the images",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "The URLs of the images to use as a reference for the generation.",
  }),
});

/**
 * ChronoEditOutput
 *
 * Unified output model for all ChronoEdit operations
 */
export const zChronoEditOutput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: "The prompt used for the inference.",
    }),
    images: z.array(zImageFile).register(z.globalRegistry, {
      description: "The edited image.",
    }),
    seed: z.int().register(z.globalRegistry, {
      description: "The seed for the inference.",
    }),
  })
  .register(z.globalRegistry, {
    description: "Unified output model for all ChronoEdit operations",
  });

/**
 * ChronoEditInput
 *
 * Input model for ChronoEdit standard editing operations
 */
export const zChronoEditInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: "The prompt to edit the image.",
    }),
    resolution: z.optional(
      z.enum(["480p", "720p"]).register(z.globalRegistry, {
        description: "The resolution of the output image.",
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether to enable the safety checker.",
        }),
      )
      .default(true),
    output_format: z.optional(
      z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image.",
      }),
    ),
    image_url: z.union([z.string(), z.string()]),
    turbo_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Enable turbo mode to use for faster inference.",
        }),
      )
      .default(true),
    num_temporal_reasoning_steps: z
      .optional(
        z.int().gte(2).lte(12).register(z.globalRegistry, {
          description: "The number of temporal reasoning steps to perform.",
        }),
      )
      .default(8),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether to return the image in sync mode.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(10).register(z.globalRegistry, {
          description: "The guidance scale for the inference.",
        }),
      )
      .default(1),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(8),
    enable_temporal_reasoning: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether to enable temporal reasoning.",
        }),
      )
      .default(false),
    enable_prompt_expansion: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether to enable prompt expansion.",
        }),
      )
      .default(true),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: "The seed for the inference.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "Input model for ChronoEdit standard editing operations",
  });

/**
 * Emu35EditOutput
 */
export const zEmu35ImageEditImageOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The edited image.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed for the inference.",
  }),
});

/**
 * Emu35ImageEditInput
 */
export const zEmu35ImageEditImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to edit the image.",
  }),
  resolution: z.optional(
    z.enum(["480p", "720p"]).register(z.globalRegistry, {
      description: "The resolution of the output image.",
    }),
  ),
  aspect_ratio: z.optional(
    z
      .enum([
        "auto",
        "21:9",
        "16:9",
        "4:3",
        "3:2",
        "1:1",
        "2:3",
        "3:4",
        "9:16",
        "9:21",
      ])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the output image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the output image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to return the image in sync mode.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enable the safety checker.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The seed for the inference.",
    }),
  ),
});

/**
 * Output
 */
export const zFluxVisionUpscalerOutput = z.object({
  image: zImageType3,
  caption: z.string().register(z.globalRegistry, {
    description: "The VLM-generated caption describing the upscaled image.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used to generate the image.",
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: "The timings of the different steps in the workflow.",
  }),
});

/**
 * Input
 */
export const zFluxVisionUpscalerInput = z.object({
  guidance: z
    .optional(
      z.number().gte(1).lte(4).register(z.globalRegistry, {
        description:
          "CFG/guidance scale (1-4). Controls how closely the model follows the prompt.",
      }),
    )
    .default(1),
  creativity: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "The creativity of the model. The higher the creativity, the more the model will deviate from the original. Refers to the denoise strength of the sampling.",
      }),
    )
    .default(0.3),
  image_url: z.union([z.string(), z.string()]),
  upscale_factor: z
    .optional(
      z.number().gte(1).lte(4).register(z.globalRegistry, {
        description: "The upscale factor (1-4x).",
      }),
    )
    .default(2),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enable the safety checker.",
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps (4-50).",
      }),
    )
    .default(20),
});

/**
 * OutpaintOutput
 */
export const zImageAppsV2OutpaintOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "Outpainted image with extended scene",
  }),
});

/**
 * OutpaintInput
 */
export const zImageAppsV2OutpaintInput = z.object({
  prompt: z
    .optional(
      z.string().max(500).register(z.globalRegistry, {
        description:
          "Optional prompt to guide the outpainting. If provided, it will be appended to the base outpaint instruction. Example: 'with a beautiful sunset in the background'",
      }),
    )
    .default(""),
  expand_right: z
    .optional(
      z.int().gte(0).lte(700).register(z.globalRegistry, {
        description:
          "Number of pixels to add as black margin on the right side (0-700).",
      }),
    )
    .default(0),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "Number of images to generate.",
      }),
    )
    .default(1),
  zoom_out_percentage: z
    .optional(
      z.number().gte(0).lte(90).register(z.globalRegistry, {
        description:
          "Percentage to zoom out the image. If set, the image will be scaled down by this percentage and black margins will be added to maintain original size. Example: 50 means the image will be 50% of original size with black margins filling the rest.",
      }),
    )
    .default(20),
  output_format: z.optional(
    z.enum(["png", "jpeg", "jpg", "webp"]).register(z.globalRegistry, {
      description: "The format of the output image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If True, the function will wait for the image to be generated and uploaded before returning the response. If False, the function will return immediately and the image will be generated asynchronously.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  expand_left: z
    .optional(
      z.int().gte(0).lte(700).register(z.globalRegistry, {
        description:
          "Number of pixels to add as black margin on the left side (0-700).",
      }),
    )
    .default(0),
  expand_bottom: z
    .optional(
      z.int().gte(0).lte(700).register(z.globalRegistry, {
        description:
          "Number of pixels to add as black margin on the bottom side (0-700).",
      }),
    )
    .default(400),
  expand_top: z
    .optional(
      z.int().gte(0).lte(700).register(z.globalRegistry, {
        description:
          "Number of pixels to add as black margin on the top side (0-700).",
      }),
    )
    .default(0),
});

/**
 * ReveFastEditOutput
 *
 * Output for Reve fast image editing
 */
export const zReveFastEditOutput = z
  .object({
    images: z.array(zImage).register(z.globalRegistry, {
      description: "The edited images",
    }),
  })
  .register(z.globalRegistry, {
    description: "Output for Reve fast image editing",
  });

/**
 * ReveFastEditInput
 *
 * Input for Reve fast image editing
 */
export const zReveFastEditInput = z
  .object({
    prompt: z.string().min(1).max(2560).register(z.globalRegistry, {
      description: "The text description of how to edit the provided image.",
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
        }),
      )
      .default(false),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "Output format for the generated image.",
      }),
    ),
    image_url: z.union([z.string(), z.string()]),
  })
  .register(z.globalRegistry, {
    description: "Input for Reve fast image editing",
  });

/**
 * ReveRemixOutput
 *
 * Output for Reve image remixing
 */
export const zReveFastRemixOutput = z
  .object({
    images: z.array(zImage).register(z.globalRegistry, {
      description: "The remixed images",
    }),
  })
  .register(z.globalRegistry, {
    description: "Output for Reve image remixing",
  });

/**
 * ReveRemixInput
 *
 * Input for Reve image remixing
 */
export const zReveFastRemixInput = z
  .object({
    prompt: z.string().min(1).max(2560).register(z.globalRegistry, {
      description:
        "The text description of the desired image. May include XML img tags like <img>0</img> to refer to specific images by their index in the image_urls list.",
    }),
    aspect_ratio: z.optional(
      z
        .enum(["16:9", "9:16", "3:2", "2:3", "4:3", "3:4", "1:1"])
        .register(z.globalRegistry, {
          description:
            "The desired aspect ratio of the generated image. If not provided, will be smartly chosen by the model.",
        }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
        }),
      )
      .default(false),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "Output format for the generated image.",
      }),
    ),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        "List of URLs of reference images. Must provide between 1 and 6 images (inclusive). Each image must be less than 10 MB. Supports PNG, JPEG, WebP, AVIF, and HEIF formats.",
    }),
  })
  .register(z.globalRegistry, {
    description: "Input for Reve image remixing",
  });

/**
 * AddBackgroundOutput
 */
export const zQwenImageEditPlusLoraGalleryAddBackgroundOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated/edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * AddBackgroundInput
 *
 * Input model for Add Background endpoint - Remove white background and add a realistic scene
 */
export const zQwenImageEditPlusLoraGalleryAddBackgroundInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Describe the background/scene you want to add behind the object. The model will remove the white background and add the specified environment.",
        }),
      )
      .default(
        "Remove white background and add a realistic scene behind the object",
      ),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the LoRA effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        "The URLs of the images to edit. Provide an image with a white or clean background.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The negative prompt for the generation",
        }),
      )
      .default(" "),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Add Background endpoint - Remove white background and add a realistic scene",
  });

/**
 * FaceToFullPortraitOutput
 */
export const zQwenImageEditPlusLoraGalleryFaceToFullPortraitOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated/edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * FaceToFullPortraitInput
 *
 * Input model for Face to Full Portrait endpoint - Generate full portrait from a cropped face image
 */
export const zQwenImageEditPlusLoraGalleryFaceToFullPortraitInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Describe the full portrait you want to generate from the face. Include clothing, setting, pose, and style details.",
        }),
      )
      .default(
        "Photography. A portrait of the person in professional attire with natural lighting",
      ),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the LoRA effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        "The URL of the cropped face image. Provide a close-up face photo.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The negative prompt for the generation",
        }),
      )
      .default(" "),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Face to Full Portrait endpoint - Generate full portrait from a cropped face image",
  });

/**
 * GroupPhotoOutput
 */
export const zQwenImageEditPlusLoraGalleryGroupPhotoOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated/edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * GroupPhotoInput
 *
 * Input model for Group Photo endpoint - Create composite group photos with vintage/retro style
 */
export const zQwenImageEditPlusLoraGalleryGroupPhotoInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Describe the group photo scene, setting, and style. The model will maintain character consistency and add vintage effects like grain, blur, and retro filters.",
        }),
      )
      .default(
        "Two people standing next to each other outside with a landscape background",
      ),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the LoRA effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        "The URLs of the images to combine into a group photo. Provide 2 or more individual portrait images.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The negative prompt for the generation",
        }),
      )
      .default(" "),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Group Photo endpoint - Create composite group photos with vintage/retro style",
  });

/**
 * IntegrateProductOutput
 */
export const zQwenImageEditPlusLoraGalleryIntegrateProductOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated/edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * IntegrateProductInput
 *
 * Input model for Integrate Product endpoint - Blend and integrate products/elements into backgrounds
 */
export const zQwenImageEditPlusLoraGalleryIntegrateProductInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Describe how to blend and integrate the product/element into the background. The model will automatically correct perspective, lighting and shadows for natural integration.",
        }),
      )
      .default("Blend and integrate the product into the background"),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the LoRA effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        "The URL of the image with product to integrate into background.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The negative prompt for the generation",
        }),
      )
      .default(" "),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Integrate Product endpoint - Blend and integrate products/elements into backgrounds",
  });

/**
 * NextSceneOutput
 */
export const zQwenImageEditPlusLoraGalleryNextSceneOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated/edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * NextSceneInput
 *
 * Input model for Next Scene endpoint - Create cinematic shot progressions and scene transitions
 */
export const zQwenImageEditPlusLoraGalleryNextSceneInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Describe the camera movement, framing change, or scene transition. Start with 'Next Scene:' for best results. Examples: camera movements (dolly, push-in, pull-back), framing changes (wide to close-up), new elements entering frame.",
        }),
      )
      .default(
        "Next Scene: The camera moves forward revealing more of the scene",
      ),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the LoRA effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: "The URL of the image to create the next scene from.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The negative prompt for the generation",
        }),
      )
      .default(" "),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Next Scene endpoint - Create cinematic shot progressions and scene transitions",
  });

/**
 * RemoveElementOutput
 */
export const zQwenImageEditPlusLoraGalleryRemoveElementOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated/edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * RemoveElementInput
 *
 * Input model for Remove Element endpoint - Remove/delete elements (objects, people, text) from the image
 */
export const zQwenImageEditPlusLoraGalleryRemoveElementInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Specify what element(s) to remove from the image (objects, people, text, etc.). The model will cleanly remove the element while maintaining consistency of the rest of the image.",
        }),
      )
      .default("Remove the specified element from the scene"),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the LoRA effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: "The URL of the image containing elements to remove.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The negative prompt for the generation",
        }),
      )
      .default(" "),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Remove Element endpoint - Remove/delete elements (objects, people, text) from the image",
  });

/**
 * RemoveLightingOutput
 */
export const zQwenImageEditPlusLoraGalleryRemoveLightingOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated/edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * RemoveLightingInput
 *
 * Input model for Remove Lighting endpoint - Remove existing lighting and apply soft even lighting
 */
export const zQwenImageEditPlusLoraGalleryRemoveLightingInput = z
  .object({
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: "The URL of the image with lighting/shadows to remove.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The negative prompt for the generation",
        }),
      )
      .default(" "),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Remove Lighting endpoint - Remove existing lighting and apply soft even lighting",
  });

/**
 * ShirtDesignOutput
 */
export const zQwenImageEditPlusLoraGalleryShirtDesignOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated/edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * ShirtDesignInput
 *
 * Input model for Shirt Design endpoint - Put designs/graphics on people's shirts
 */
export const zQwenImageEditPlusLoraGalleryShirtDesignInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Describe what design to put on the shirt. The model will apply the design from your input image onto the person's shirt.",
        }),
      )
      .default("Put this design on their shirt"),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the LoRA effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        "The URLs of the images: first image is the person wearing a shirt, second image is the design/logo to put on the shirt.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The negative prompt for the generation",
        }),
      )
      .default(" "),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Shirt Design endpoint - Put designs/graphics on people's shirts",
  });

/**
 * MultipleAnglesOutput
 */
export const zQwenImageEditPlusLoraGalleryMultipleAnglesOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated/edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * MultipleAnglesInput
 *
 * Input model for Multiple Angles endpoint - Camera control with precise adjustments
 */
export const zQwenImageEditPlusLoraGalleryMultipleAnglesInput = z
  .object({
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    wide_angle_lens: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Enable wide-angle lens effect",
        }),
      )
      .default(false),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(1),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: "The URL of the image to adjust camera angle for.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The negative prompt for the generation",
        }),
      )
      .default(" "),
    vertical_angle: z
      .optional(
        z.number().gte(-1).lte(1).register(z.globalRegistry, {
          description:
            "Adjust vertical camera angle (-1=bird's-eye view/looking down, 0=neutral, 1=worm's-eye view/looking up)",
        }),
      )
      .default(0),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    move_forward: z
      .optional(
        z.number().gte(0).lte(10).register(z.globalRegistry, {
          description: "Move camera forward (0=no movement, 10=close-up)",
        }),
      )
      .default(0),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    rotate_right_left: z
      .optional(
        z.number().gte(-90).lte(90).register(z.globalRegistry, {
          description:
            "Rotate camera left (positive) or right (negative) in degrees. Positive values rotate left, negative values rotate right.",
        }),
      )
      .default(0),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the camera control effect.",
        }),
      )
      .default(1.25),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Multiple Angles endpoint - Camera control with precise adjustments",
  });

/**
 * NanoBananaImageToImageOutput
 */
export const zNanoBananaProEditOutput = z.object({
  images: z.array(zImageFileType2).register(z.globalRegistry, {
    description: "The edited images.",
  }),
  description: z.string().register(z.globalRegistry, {
    description: "The description of the generated images.",
  }),
});

/**
 * NanoBananaImageToImageInput
 */
export const zNanoBananaProEditInput = z.object({
  prompt: z.string().min(3).max(50000).register(z.globalRegistry, {
    description: "The prompt for image editing.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  enable_web_search: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Enable web search for the image generation task. This will allow the model to use the latest information from the web to generate the image.",
      }),
    )
    .default(false),
  aspect_ratio: z.optional(
    z.union([
      z.enum([
        "auto",
        "21:9",
        "16:9",
        "3:2",
        "4:3",
        "5:4",
        "1:1",
        "4:5",
        "3:4",
        "2:3",
        "9:16",
      ]),
      z.unknown(),
    ]),
  ),
  resolution: z.optional(
    z.enum(["1K", "2K", "4K"]).register(z.globalRegistry, {
      description: "The resolution of the image to generate.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "The URLs of the images to use for image-to-image generation or image editing.",
  }),
  limit_generations: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.",
      }),
    )
    .default(false),
});

/**
 * NanoBananaImageToImageOutput
 */
export const zGemini3ProImagePreviewEditOutput = z.object({
  images: z.array(zImageFileType2).register(z.globalRegistry, {
    description: "The edited images.",
  }),
  description: z.string().register(z.globalRegistry, {
    description: "The description of the generated images.",
  }),
});

/**
 * NanoBananaImageToImageInput
 */
export const zGemini3ProImagePreviewEditInput = z.object({
  prompt: z.string().min(3).max(50000).register(z.globalRegistry, {
    description: "The prompt for image editing.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  enable_web_search: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Enable web search for the image generation task. This will allow the model to use the latest information from the web to generate the image.",
      }),
    )
    .default(false),
  resolution: z.optional(
    z.enum(["1K", "2K", "4K"]).register(z.globalRegistry, {
      description: "The resolution of the image to generate.",
    }),
  ),
  aspect_ratio: z.optional(
    z.union([
      z.enum([
        "auto",
        "21:9",
        "16:9",
        "3:2",
        "4:3",
        "5:4",
        "1:1",
        "4:5",
        "3:4",
        "2:3",
        "9:16",
      ]),
      z.unknown(),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "The URLs of the images to use for image-to-image generation or image editing.",
  }),
  limit_generations: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.",
      }),
    )
    .default(false),
});

/**
 * MaskMetadata
 */
export const zMaskMetadata = z.object({
  box: z.optional(
    z.array(z.number()).register(z.globalRegistry, {
      description:
        "Bounding box for the mask in normalized cxcywh coordinates.",
    }),
  ),
  score: z.optional(
    z.number().register(z.globalRegistry, {
      description: "Score for this mask.",
    }),
  ),
  index: z.int().register(z.globalRegistry, {
    description: "Index of the mask inside the model output.",
  }),
});

/**
 * SAM3ImageOutput
 */
export const zSam3ImageOutput = z.object({
  image: z.optional(zImage),
  metadata: z.optional(
    z.array(zMaskMetadata).register(z.globalRegistry, {
      description: "Per-mask metadata including scores and boxes.",
    }),
  ),
  masks: z.array(zImage).register(z.globalRegistry, {
    description: "Segmented mask images.",
  }),
  scores: z.optional(
    z.array(z.number()).register(z.globalRegistry, {
      description: "Per-mask confidence scores when requested.",
    }),
  ),
  boxes: z.optional(
    z.array(z.array(z.number())).register(z.globalRegistry, {
      description:
        "Per-mask normalized bounding boxes [cx, cy, w, h] when requested.",
    }),
  ),
});

/**
 * PointPrompt
 */
export const zPointPrompt = z.object({
  y: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Y Coordinate of the prompt",
    }),
  ),
  x: z.optional(
    z.int().register(z.globalRegistry, {
      description: "X Coordinate of the prompt",
    }),
  ),
  object_id: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Optional object identifier. Prompts sharing an object id refine the same object.",
    }),
  ),
  frame_index: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The frame index to interact with.",
    }),
  ),
  label: z.optional(
    z.union([z.literal(0), z.literal(1)]).register(z.globalRegistry, {
      description: "1 for foreground, 0 for background",
    }),
  ),
});

/**
 * BoxPrompt
 */
export const zBoxPrompt = z.object({
  y_min: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Y Min Coordinate of the box",
    }),
  ),
  object_id: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Optional object identifier. Boxes sharing an object id refine the same object.",
    }),
  ),
  frame_index: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The frame index to interact with.",
    }),
  ),
  x_max: z.optional(
    z.int().register(z.globalRegistry, {
      description: "X Max Coordinate of the box",
    }),
  ),
  x_min: z.optional(
    z.int().register(z.globalRegistry, {
      description: "X Min Coordinate of the box",
    }),
  ),
  y_max: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Y Max Coordinate of the box",
    }),
  ),
});

/**
 * SAM3ImageInput
 */
export const zSam3ImageInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Text prompt for segmentation",
      }),
    )
    .default("wheel"),
  include_boxes: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to include bounding boxes for each mask (when available).",
      }),
    )
    .default(false),
  box_prompts: z
    .optional(
      z.array(zBoxPrompt).register(z.globalRegistry, {
        description:
          "Box prompt coordinates (x_min, y_min, x_max, y_max). Multiple boxes supported - use object_id to group boxes for the same object or leave empty for separate objects.",
      }),
    )
    .default([]),
  return_multiple_masks: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If True, upload and return multiple generated masks as defined by `max_masks`.",
      }),
    )
    .default(false),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If True, the media will be returned as a data URI.",
      }),
    )
    .default(false),
  point_prompts: z
    .optional(
      z.array(zPointPrompt).register(z.globalRegistry, {
        description: "List of point prompts",
      }),
    )
    .default([]),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  max_masks: z
    .optional(
      z.int().gte(1).lte(32).register(z.globalRegistry, {
        description:
          "Maximum number of masks to return when `return_multiple_masks` is enabled.",
      }),
    )
    .default(3),
  include_scores: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to include mask confidence scores.",
      }),
    )
    .default(false),
  apply_mask: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Apply the mask on the image.",
      }),
    )
    .default(true),
  text_prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "[DEPRECATED] Use 'prompt' instead. Kept for backward compatibility.",
    }),
  ),
});

/**
 * SAM3RLEOutput
 */
export const zSam3ImageRleOutput = z.object({
  rle: z.union([z.string(), z.array(z.string())]),
  metadata: z.optional(
    z.array(zMaskMetadata).register(z.globalRegistry, {
      description: "Per-mask metadata when multiple RLEs are returned.",
    }),
  ),
  scores: z.optional(
    z.array(z.number()).register(z.globalRegistry, {
      description: "Per-mask confidence scores when requested.",
    }),
  ),
  boundingbox_frames_zip: z.optional(zFile),
  boxes: z.optional(
    z.array(z.array(z.number())).register(z.globalRegistry, {
      description:
        "Per-mask normalized bounding boxes [cx, cy, w, h] when requested.",
    }),
  ),
});

/**
 * SAM3ImageInput
 */
export const zSam3ImageRleInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Text prompt for segmentation",
      }),
    )
    .default("wheel"),
  include_boxes: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to include bounding boxes for each mask (when available).",
      }),
    )
    .default(false),
  box_prompts: z
    .optional(
      z.array(zBoxPrompt).register(z.globalRegistry, {
        description:
          "Box prompt coordinates (x_min, y_min, x_max, y_max). Multiple boxes supported - use object_id to group boxes for the same object or leave empty for separate objects.",
      }),
    )
    .default([]),
  return_multiple_masks: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If True, upload and return multiple generated masks as defined by `max_masks`.",
      }),
    )
    .default(false),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If True, the media will be returned as a data URI.",
      }),
    )
    .default(false),
  point_prompts: z
    .optional(
      z.array(zPointPrompt).register(z.globalRegistry, {
        description: "List of point prompts",
      }),
    )
    .default([]),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  max_masks: z
    .optional(
      z.int().gte(1).lte(32).register(z.globalRegistry, {
        description:
          "Maximum number of masks to return when `return_multiple_masks` is enabled.",
      }),
    )
    .default(3),
  include_scores: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to include mask confidence scores.",
      }),
    )
    .default(false),
  apply_mask: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Apply the mask on the image.",
      }),
    )
    .default(true),
  text_prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "[DEPRECATED] Use 'prompt' instead. Kept for backward compatibility.",
    }),
  ),
});

/**
 * ChronoEditOutput
 *
 * Unified output model for all ChronoEdit operations
 */
export const zChronoEditLoraGalleryUpscalerOutput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: "The prompt used for the inference.",
    }),
    images: z.array(zImageFile).register(z.globalRegistry, {
      description: "The edited image.",
    }),
    seed: z.int().register(z.globalRegistry, {
      description: "The seed for the inference.",
    }),
  })
  .register(z.globalRegistry, {
    description: "Unified output model for all ChronoEdit operations",
  });

/**
 * ChronoLoraWeight
 */
export const zChronoLoraWeight = z.object({
  path: z.string().register(z.globalRegistry, {
    description: "URL or path to the LoRA weights (Safetensors).",
  }),
  scale: z
    .optional(
      z.number().gte(0).lte(4).register(z.globalRegistry, {
        description: "Scale factor controlling LoRA strength.",
      }),
    )
    .default(1),
});

/**
 * ChronoEditUpscalerInput
 *
 * Input for upscaler mode
 */
export const zChronoEditLoraGalleryUpscalerInput = z
  .object({
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: "The scale factor for the LoRA adapter.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image.",
      }),
    ),
    image_url: z.union([z.string(), z.string()]),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether to return the image in sync mode.",
        }),
      )
      .default(false),
    loras: z
      .optional(
        z.array(zChronoLoraWeight).register(z.globalRegistry, {
          description: "Optional additional LoRAs to merge (max 3).",
        }),
      )
      .default([]),
    upscale_factor: z
      .optional(
        z.number().gte(1).lte(4).register(z.globalRegistry, {
          description: "Target scale factor for the output resolution.",
        }),
      )
      .default(2),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(10).register(z.globalRegistry, {
          description: "The guidance scale for the inference.",
        }),
      )
      .default(1),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "Number of inference steps for the upscaling pass.",
        }),
      )
      .default(30),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: "The seed for the inference.",
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether to enable the safety checker.",
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: "Input for upscaler mode",
  });

/**
 * ChronoEditOutput
 *
 * Unified output model for all ChronoEdit operations
 */
export const zChronoEditLoraGalleryPaintbrushOutput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: "The prompt used for the inference.",
    }),
    images: z.array(zImageFile).register(z.globalRegistry, {
      description: "The edited image.",
    }),
    seed: z.int().register(z.globalRegistry, {
      description: "The seed for the inference.",
    }),
  })
  .register(z.globalRegistry, {
    description: "Unified output model for all ChronoEdit operations",
  });

/**
 * ChronoEditPaintBrushInput
 *
 * Input for paintbrush mode
 */
export const zChronoEditLoraGalleryPaintbrushInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: "Describe how to transform the sketched regions.",
    }),
    resolution: z.optional(
      z.enum(["480p", "720p"]).register(z.globalRegistry, {
        description: "The resolution of the output image.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: "The scale factor for the LoRA adapter.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image.",
      }),
    ),
    image_url: z.union([z.string(), z.string()]),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether to return the image in sync mode.",
        }),
      )
      .default(false),
    turbo_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Enable turbo mode to use faster inference.",
        }),
      )
      .default(true),
    loras: z
      .optional(
        z.array(zChronoLoraWeight).register(z.globalRegistry, {
          description: "Optional additional LoRAs to merge (max 3).",
        }),
      )
      .default([]),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(10).register(z.globalRegistry, {
          description: "Classifier-free guidance scale.",
        }),
      )
      .default(1),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "Number of denoising steps to run.",
        }),
      )
      .default(8),
    mask_url: z.optional(z.union([z.string(), z.string()])),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: "The seed for the inference.",
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether to enable the safety checker.",
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: "Input for paintbrush mode",
  });

/**
 * ChronoEditOutput
 *
 * Unified output model for all ChronoEdit operations
 */
export const zChronoEditLoraOutput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: "The prompt used for the inference.",
    }),
    images: z.array(zImageFile).register(z.globalRegistry, {
      description: "The edited image.",
    }),
    seed: z.int().register(z.globalRegistry, {
      description: "The seed for the inference.",
    }),
  })
  .register(z.globalRegistry, {
    description: "Unified output model for all ChronoEdit operations",
  });

/**
 * ChronoEditLoRAInput
 *
 * ChronoEdit input with optional custom LoRAs.
 */
export const zChronoEditLoraInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: "The prompt to edit the image.",
    }),
    loras: z
      .optional(
        z.array(zChronoLoraWeight).register(z.globalRegistry, {
          description:
            "Optional additional LoRAs to merge for this request (max 3).",
        }),
      )
      .default([]),
    turbo_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Enable turbo mode to use for faster inference.",
        }),
      )
      .default(true),
    enable_temporal_reasoning: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether to enable temporal reasoning.",
        }),
      )
      .default(false),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether to enable the safety checker.",
        }),
      )
      .default(true),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(10).register(z.globalRegistry, {
          description: "The guidance scale for the inference.",
        }),
      )
      .default(1),
    resolution: z.optional(
      z.enum(["480p", "720p"]).register(z.globalRegistry, {
        description: "The resolution of the output image.",
      }),
    ),
    output_format: z.optional(
      z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image.",
      }),
    ),
    num_temporal_reasoning_steps: z
      .optional(
        z.int().gte(2).lte(12).register(z.globalRegistry, {
          description: "The number of temporal reasoning steps to perform.",
        }),
      )
      .default(8),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether to return the image in sync mode.",
        }),
      )
      .default(false),
    image_url: z.union([z.string(), z.string()]),
    enable_prompt_expansion: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether to enable prompt expansion.",
        }),
      )
      .default(true),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(8),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: "The seed for the inference.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "ChronoEdit input with optional custom LoRAs.",
  });

/**
 * Flux2FlexEditOutput
 */
export const zFlux2FlexEditOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for the generation.",
  }),
});

/**
 * Flux2FlexImageEditInput
 */
export const zFlux2FlexEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  guidance_scale: z
    .optional(
      z.number().gte(1.5).lte(10).register(z.globalRegistry, {
        description: "The guidance scale to use for the generation.",
      }),
    )
    .default(3.5),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "auto",
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.",
    }),
  ),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to expand the prompt using the model's own knowledge.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: "List of URLs of input images for editing",
  }),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enable the safety checker.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The seed to use for the generation.",
    }),
  ),
});

/**
 * CrystalUpscaleOutput
 */
export const zCrystalUpscalerOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "List of upscaled images",
  }),
});

/**
 * CrystalUpscaleInput
 */
export const zCrystalUpscalerInput = z.object({
  creativity: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: "Creativity level for upscaling",
      }),
    )
    .default(0),
  scale_factor: z
    .optional(
      z.number().gte(1).lte(200).register(z.globalRegistry, {
        description: "Scale factor",
      }),
    )
    .default(2),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * AddBackgroundOutput
 */
export const zFlux2LoraGalleryAddBackgroundOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generation",
  }),
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated images with added background",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * AddBackgroundInput
 *
 * Input model for Add Background endpoint - Add background to images
 */
export const zFlux2LoraGalleryAddBackgroundInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "The prompt describing the background to add. Must start with 'Add Background' followed by your description.",
        }),
      )
      .default("Add Background forest"),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: "The strength of the add background effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(2.5),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        "The URLs of the images. Provide an image with a white or clean background.",
    }),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(40),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Add Background endpoint - Add background to images",
  });

/**
 * ApartmentStagingOutput
 */
export const zFlux2LoraGalleryApartmentStagingOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generation",
  }),
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated furnished room images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * ApartmentStagingInput
 *
 * Input model for Apartment Staging endpoint - Furnish rooms
 */
export const zFlux2LoraGalleryApartmentStagingInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description:
        "The prompt to generate a furnished room. Use 'furnish this room' for best results.",
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: "The strength of the apartment staging effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(2.5),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: "The URL of the empty room image to furnish.",
    }),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(40),
  })
  .register(z.globalRegistry, {
    description: "Input model for Apartment Staging endpoint - Furnish rooms",
  });

/**
 * FaceToFullPortraitOutput
 */
export const zFlux2LoraGalleryFaceToFullPortraitOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generation",
  }),
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated full portrait images from face",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * FaceToFullPortraitInput
 *
 * Input model for Face to Full Portrait endpoint - Generate full portrait from face
 */
export const zFlux2LoraGalleryFaceToFullPortraitInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "The prompt describing the full portrait to generate from the face.",
        }),
      )
      .default("Face to full portrait"),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: "The strength of the face to full portrait effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(2.5),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: "The URL of the cropped face image.",
    }),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(40),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Face to Full Portrait endpoint - Generate full portrait from face",
  });

/**
 * MultipleAnglesOutput
 */
export const zFlux2LoraGalleryMultipleAnglesOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generation",
  }),
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated images with multiple camera angles",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * MultipleAnglesInput
 *
 * Input model for Multiple Angles endpoint - Camera control with precise adjustments using <sks> trigger word. Prompt is built automatically from slider values.
 */
export const zFlux2LoraGalleryMultipleAnglesInput = z
  .object({
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description: "Acceleration level for image generation.",
      }),
    ),
    horizontal_angle: z
      .optional(
        z.number().gte(0).lte(360).register(z.globalRegistry, {
          description:
            "Horizontal rotation angle around the object in degrees. 0=front view, 90=right side, 180=back view, 270=left side, 360=front view again.",
        }),
      )
      .default(0),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description: "The CFG (Classifier Free Guidance) scale.",
        }),
      )
      .default(2.5),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether to enable the safety checker.",
        }),
      )
      .default(true),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: "The URL of the image to adjust camera angle for.",
    }),
    zoom: z
      .optional(
        z.number().gte(0).lte(10).register(z.globalRegistry, {
          description:
            "Camera zoom/distance. 0=wide shot (far away), 5=medium shot (normal), 10=close-up (very close).",
        }),
      )
      .default(5),
    vertical_angle: z
      .optional(
        z.number().gte(0).lte(60).register(z.globalRegistry, {
          description:
            "Vertical camera angle in degrees. 0=eye-level shot, 30=elevated shot, 60=high-angle shot (looking down from above).",
        }),
      )
      .default(0),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate.",
        }),
      )
      .default(1),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: "The strength of the multiple angles effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image.",
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "If True, the media will be returned as a data URI.",
        }),
      )
      .default(false),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(40),
    seed: z.optional(z.union([z.int(), z.unknown()])),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Multiple Angles endpoint - Camera control with precise adjustments using <sks> trigger word. Prompt is built automatically from slider values.",
  });

/**
 * VirtualTryonOutput
 */
export const zFlux2LoraGalleryVirtualTryonOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generation",
  }),
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated virtual try-on images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * VirtualTryonInput
 *
 * Input model for Virtual Try-on endpoint - Generate virtual try-on images
 */
export const zFlux2LoraGalleryVirtualTryonInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: "The prompt to generate a virtual try-on image.",
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: "The strength of the virtual try-on effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(2.5),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        "The URLs of the images for virtual try-on. Provide person image and clothing image.",
    }),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(40),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Virtual Try-on endpoint - Generate virtual try-on images",
  });

/**
 * OmniImageElementInput
 */
export const zOmniImageElementInput = z.object({
  reference_image_urls: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        "Additional reference images from different angles. 1-3 images supported. At least one image is required.",
    }),
  ),
  frontal_image_url: z.union([z.string(), z.string()]),
});

/**
 * OmniImageOutput
 */
export const zKlingImageO1Output = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "Generated images",
  }),
});

/**
 * OmniImageRequest
 */
export const zKlingImageO1Input = z.object({
  prompt: z.string().max(2500).register(z.globalRegistry, {
    description:
      "Text prompt for image generation. Reference images using @Image1, @Image2, etc. (or @Image if only one image). Max 2500 characters.",
  }),
  aspect_ratio: z.optional(
    z
      .enum(["auto", "16:9", "9:16", "1:1", "4:3", "3:4", "3:2", "2:3", "21:9"])
      .register(z.globalRegistry, {
        description:
          "Aspect ratio of generated images. 'auto' intelligently determines based on input content.",
      }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(9).register(z.globalRegistry, {
        description: "Number of images to generate (1-9).",
      }),
    )
    .default(1),
  resolution: z.optional(
    z.enum(["1K", "2K"]).register(z.globalRegistry, {
      description: "Image generation resolution. 1K: standard, 2K: high-res.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  elements: z.optional(
    z.array(zOmniImageElementInput).register(z.globalRegistry, {
      description:
        "Elements (characters/objects) to include in the image. Reference in prompt as @Element1, @Element2, etc. Maximum 10 total (elements + reference images).",
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "List of reference images. Reference images in prompt using @Image1, @Image2, etc. (1-indexed). Max 10 images.",
  }),
});

/**
 * ReferenceToImageOutput
 */
export const zViduQ2ReferenceToImageOutput = z.object({
  image: zImage,
});

/**
 * ReferenceToImageRequest
 */
export const zViduQ2ReferenceToImageInput = z.object({
  prompt: z.string().max(1500).register(z.globalRegistry, {
    description: "Text prompt for video generation, max 1500 characters",
  }),
  aspect_ratio: z.optional(
    z.enum(["16:9", "9:16", "1:1"]).register(z.globalRegistry, {
      description: "The aspect ratio of the output video",
    }),
  ),
  reference_image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "URLs of the reference images to use for consistent subject appearance",
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Random seed for generation",
    }),
  ),
});

/**
 * SeedDream45EditOutput
 */
export const zBytedanceSeedreamV45EditOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "Generated images",
  }),
});

/**
 * SeedDream45EditInput
 */
export const zBytedanceSeedreamV45EditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The text prompt used to edit the image",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(6).register(z.globalRegistry, {
        description:
          "Number of separate model generations to be run with the prompt.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
        "auto_2K",
        "auto_4K",
      ]),
    ]),
  ),
  max_images: z
    .optional(
      z.int().gte(1).lte(6).register(z.globalRegistry, {
        description:
          "If set to a number greater than one, enables multi-image generation. The model will potentially return up to `max_images` images every generation, and in total, `num_images` generations will be carried out. In total, the number of images generated will be between `num_images` and `max_images*num_images`. The total number of images (image inputs + image outputs) must not exceed 15",
      }),
    )
    .default(1),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed to control the stochasticity of image generation.",
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "List of URLs of input images for editing. Presently, up to 10 image inputs are allowed. If over 10 images are sent, only the last 10 will be used.",
  }),
});

/**
 * ImageToImageOutput
 */
export const zLongcatImageEditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * EditImageInput
 */
export const zLongcatImageEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to edit the image with.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description: "The guidance scale to use for the image generation.",
      }),
    )
    .default(4.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * ZImageTurboImageToImageOutput
 */
export const zZImageTurboImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: "The timings of the generation process.",
  }),
});

/**
 * ZImageTurboImageToImageInput
 */
export const zZImageTurboImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
        "auto",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description: "The strength of the image-to-image conditioning.",
      }),
    )
    .default(0.6),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.",
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(8),
});

/**
 * ZImageTurboImageToImageOutput
 */
export const zZImageTurboImageToImageLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: "The timings of the generation process.",
  }),
});

/**
 * ZImageTurboImageToImageLoRAInput
 */
export const zZImageTurboImageToImageLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
        "auto",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoRaInput).register(z.globalRegistry, {
        description: "List of LoRA weights to apply (maximum 3).",
      }),
    )
    .default([]),
  strength: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description: "The strength of the image-to-image conditioning.",
      }),
    )
    .default(0.6),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.",
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(8),
});

/**
 * ZImageTurboControlNetOutput
 */
export const zZImageTurboControlnetOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: "The timings of the generation process.",
  }),
});

/**
 * ZImageTurboControlNetInput
 */
export const zZImageTurboControlnetInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
        "auto",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use.",
    }),
  ),
  control_end: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The end of the controlnet conditioning.",
      }),
    )
    .default(0.8),
  control_start: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The start of the controlnet conditioning.",
      }),
    )
    .default(0),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  control_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The scale of the controlnet conditioning.",
      }),
    )
    .default(0.75),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.",
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(8),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  preprocess: z.optional(
    z.enum(["none", "canny", "depth", "pose"]).register(z.globalRegistry, {
      description: "What kind of preprocessing to apply to the image, if any.",
    }),
  ),
});

/**
 * ZImageTurboControlNetOutput
 */
export const zZImageTurboControlnetLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: "The timings of the generation process.",
  }),
});

/**
 * ZImageTurboControlNetLoRAInput
 */
export const zZImageTurboControlnetLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
        "auto",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use.",
    }),
  ),
  loras: z
    .optional(
      z.array(zLoRaInput).register(z.globalRegistry, {
        description: "List of LoRA weights to apply (maximum 3).",
      }),
    )
    .default([]),
  control_end: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The end of the controlnet conditioning.",
      }),
    )
    .default(0.8),
  control_start: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The start of the controlnet conditioning.",
      }),
    )
    .default(0),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  control_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The scale of the controlnet conditioning.",
      }),
    )
    .default(0.75),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.",
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(8),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  preprocess: z.optional(
    z.enum(["none", "canny", "depth", "pose"]).register(z.globalRegistry, {
      description: "What kind of preprocessing to apply to the image, if any.",
    }),
  ),
});

/**
 * ImageOutput
 */
export const zStepxEdit2Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  best_info: z.optional(
    z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
      description:
        "Reflection analysis (only available when reflection mode is enabled).",
    }),
  ),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated images",
  }),
  timings: z.record(z.string(), z.number()),
  reformat_prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "The model's interpretation of your instruction (only available when thinking mode is enabled).",
    }),
  ),
  think_info: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        "Reasoning process details (only available when thinking mode is enabled).",
    }),
  ),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * ImageToImageInput
 */
export const zStepxEdit2Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enable_reflection_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Enable reflection mode. Reviews outputs, corrects unintended changes, and determines when editing is complete.",
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The true CFG scale. Controls how closely the model follows the prompt.\n        ",
      }),
    )
    .default(6),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(100).register(z.globalRegistry, {
        description:
          "The number of inference steps to perform. Recommended: 50.",
      }),
    )
    .default(50),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(""),
  enable_thinking_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Enable thinking mode. Uses multimodal language model knowledge to interpret abstract editing instructions.",
      }),
    )
    .default(true),
});

/**
 * Schema referenced but not defined by fal.ai (missing from source OpenAPI spec)
 */
export const zPoint = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description:
      "Schema referenced but not defined by fal.ai (missing from source OpenAPI spec)",
  });

/**
 * UsageInfo
 */
export const zUsageInfo = z.object({
  output_tokens: z.int().register(z.globalRegistry, {
    description: "Number of output tokens generated",
  }),
  decode_time_ms: z.number().register(z.globalRegistry, {
    description: "Time taken for decoding in milliseconds",
  }),
  input_tokens: z.int().register(z.globalRegistry, {
    description: "Number of input tokens processed",
  }),
  ttft_ms: z.number().register(z.globalRegistry, {
    description: "Time to first token in milliseconds",
  }),
  prefill_time_ms: z.number().register(z.globalRegistry, {
    description: "Time taken for prefill in milliseconds",
  }),
});

/**
 * Object
 */
export const zObject = z.object({
  y_min: z.number().register(z.globalRegistry, {
    description: "Top boundary of detection box in normalized format (0 to 1)",
  }),
  x_max: z.number().register(z.globalRegistry, {
    description:
      "Right boundary of detection box in normalized format (0 to 1)",
  }),
  x_min: z.number().register(z.globalRegistry, {
    description: "Left boundary of detection box in normalized format (0 to 1)",
  }),
  y_max: z.number().register(z.globalRegistry, {
    description:
      "Bottom boundary of detection box in normalized format (0 to 1)",
  }),
});

/**
 * SegmentSamplingSettings
 */
export const zSegmentSamplingSettings = z.object({
  top_p: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "Nucleus sampling probability mass to use, between 0 and 1.",
      }),
    )
    .default(1),
  max_tokens: z.optional(
    z.int().gte(1).register(z.globalRegistry, {
      description: "Maximum number of tokens to generate.",
    }),
  ),
  temperature: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "Sampling temperature to use. Higher values will make the output more random, while lower values will make it more focused and deterministic.",
      }),
    )
    .default(1),
});

/**
 * MoondreamSegementationOutput
 */
export const zMoondream3PreviewSegmentOutput = z.object({
  finish_reason: z.string().register(z.globalRegistry, {
    description: "Reason for finishing the output generation",
  }),
  image: z.optional(zImageFile),
  bbox: z.optional(zObject),
  path: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "SVG path data representing the segmentation mask. If not detected, will be null.",
    }),
  ),
  usage_info: zUsageInfo,
});

/**
 * MoondreamSegementationInput
 */
export const zMoondream3PreviewSegmentInput = z.object({
  spatial_references: z.optional(
    z.array(z.union([zPoint, z.array(z.number())])).register(z.globalRegistry, {
      description:
        "Spatial references to guide the segmentation. By feeding in references you can help the segmentation process. Must be either list of Point object with x and y members, or list of arrays containing either 2 floats (x,y) or 4 floats (x1,y1,x2,y2). \n**NOTE**: You can also use the [**point endpoint**](https://fal.ai/models/fal-ai/moondream3-preview/point) to get points for the objects, and pass them in here.",
    }),
  ),
  settings: z.optional(zSegmentSamplingSettings),
  object: z.string().register(z.globalRegistry, {
    description: "Object to be segmented in the image",
  }),
  preview: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to preview the output and return a binary mask of the image",
      }),
    )
    .default(false),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * LightingRestorationOutput
 */
export const zQwenImageEditPlusLoraGalleryLightingRestorationOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated/edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * LightingRestorationInput
 *
 * Input model for Lighting Restoration endpoint - Restore natural lighting by removing harsh shadows and light spots
 */
export const zQwenImageEditPlusLoraGalleryLightingRestorationInput = z
  .object({
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: "The URL of the image to restore lighting for.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The negative prompt for the generation",
        }),
      )
      .default(" "),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Lighting Restoration endpoint - Restore natural lighting by removing harsh shadows and light spots",
  });

/**
 * QwenImageOutput
 */
export const zQwenImageEdit2509Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * BaseQwenEditImagePlusInput
 */
export const zQwenImageEdit2509Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate the image with",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular"]).register(z.globalRegistry, {
      description:
        "Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(4),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: "The URLs of the images to edit.",
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The negative prompt for the generation",
      }),
    )
    .default(" "),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(100).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(50),
});

/**
 * QwenImageOutput
 */
export const zQwenImageEdit2509LoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * BaseQwenEditImagePlusLoRAInput
 */
export const zQwenImageEdit2509LoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate the image with",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular"]).register(z.globalRegistry, {
      description:
        "Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "\n            The LoRAs to use for the image generation. You can use up to 3 LoRAs\n            and they will be merged together to generate the final image.\n        ",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(4),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: "The URLs of the images to edit.",
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The negative prompt for the generation",
      }),
    )
    .default(" "),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * MultipleAnglesOutput
 */
export const zQwenImageEdit2509LoraGalleryMultipleAnglesOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated/edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * MultipleAnglesInput
 *
 * Input model for Multiple Angles endpoint - Camera control with precise adjustments
 */
export const zQwenImageEdit2509LoraGalleryMultipleAnglesInput = z
  .object({
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    wide_angle_lens: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Enable wide-angle lens effect",
        }),
      )
      .default(false),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(1),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: "The URL of the image to adjust camera angle for.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The negative prompt for the generation",
        }),
      )
      .default(" "),
    vertical_angle: z
      .optional(
        z.number().gte(-1).lte(1).register(z.globalRegistry, {
          description:
            "Adjust vertical camera angle (-1=bird's-eye view/looking down, 0=neutral, 1=worm's-eye view/looking up)",
        }),
      )
      .default(0),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    move_forward: z
      .optional(
        z.number().gte(0).lte(10).register(z.globalRegistry, {
          description: "Move camera forward (0=no movement, 10=close-up)",
        }),
      )
      .default(0),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    rotate_right_left: z
      .optional(
        z.number().gte(-90).lte(90).register(z.globalRegistry, {
          description:
            "Rotate camera left (positive) or right (negative) in degrees. Positive values rotate left, negative values rotate right.",
        }),
      )
      .default(0),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the camera control effect.",
        }),
      )
      .default(1.25),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Multiple Angles endpoint - Camera control with precise adjustments",
  });

/**
 * NextSceneOutput
 */
export const zQwenImageEdit2509LoraGalleryNextSceneOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated/edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * NextSceneInput
 *
 * Input model for Next Scene endpoint - Create cinematic shot progressions and scene transitions
 */
export const zQwenImageEdit2509LoraGalleryNextSceneInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Describe the camera movement, framing change, or scene transition. Start with 'Next Scene:' for best results. Examples: camera movements (dolly, push-in, pull-back), framing changes (wide to close-up), new elements entering frame.",
        }),
      )
      .default(
        "Next Scene: The camera moves forward revealing more of the scene",
      ),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the LoRA effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: "The URL of the image to create the next scene from.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The negative prompt for the generation",
        }),
      )
      .default(" "),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Next Scene endpoint - Create cinematic shot progressions and scene transitions",
  });

/**
 * AddBackgroundOutput
 */
export const zQwenImageEdit2509LoraGalleryAddBackgroundOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated/edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * AddBackgroundInput
 *
 * Input model for Add Background endpoint - Remove white background and add a realistic scene
 */
export const zQwenImageEdit2509LoraGalleryAddBackgroundInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Describe the background/scene you want to add behind the object. The model will remove the white background and add the specified environment.",
        }),
      )
      .default(
        "Remove white background and add a realistic scene behind the object",
      ),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the LoRA effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        "The URLs of the images to edit. Provide an image with a white or clean background.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The negative prompt for the generation",
        }),
      )
      .default(" "),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Add Background endpoint - Remove white background and add a realistic scene",
  });

/**
 * FaceToFullPortraitOutput
 */
export const zQwenImageEdit2509LoraGalleryFaceToFullPortraitOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated/edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * FaceToFullPortraitInput
 *
 * Input model for Face to Full Portrait endpoint - Generate full portrait from a cropped face image
 */
export const zQwenImageEdit2509LoraGalleryFaceToFullPortraitInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Describe the full portrait you want to generate from the face. Include clothing, setting, pose, and style details.",
        }),
      )
      .default(
        "Photography. A portrait of the person in professional attire with natural lighting",
      ),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the LoRA effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        "The URL of the cropped face image. Provide a close-up face photo.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The negative prompt for the generation",
        }),
      )
      .default(" "),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Face to Full Portrait endpoint - Generate full portrait from a cropped face image",
  });

/**
 * GroupPhotoOutput
 */
export const zQwenImageEdit2509LoraGalleryGroupPhotoOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated/edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * GroupPhotoInput
 *
 * Input model for Group Photo endpoint - Create composite group photos with vintage/retro style
 */
export const zQwenImageEdit2509LoraGalleryGroupPhotoInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Describe the group photo scene, setting, and style. The model will maintain character consistency and add vintage effects like grain, blur, and retro filters.",
        }),
      )
      .default(
        "Two people standing next to each other outside with a landscape background",
      ),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the LoRA effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        "The URLs of the images to combine into a group photo. Provide 2 or more individual portrait images.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The negative prompt for the generation",
        }),
      )
      .default(" "),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Group Photo endpoint - Create composite group photos with vintage/retro style",
  });

/**
 * IntegrateProductOutput
 */
export const zQwenImageEdit2509LoraGalleryIntegrateProductOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated/edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * IntegrateProductInput
 *
 * Input model for Integrate Product endpoint - Blend and integrate products/elements into backgrounds
 */
export const zQwenImageEdit2509LoraGalleryIntegrateProductInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Describe how to blend and integrate the product/element into the background. The model will automatically correct perspective, lighting and shadows for natural integration.",
        }),
      )
      .default("Blend and integrate the product into the background"),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the LoRA effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        "The URL of the image with product to integrate into background.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The negative prompt for the generation",
        }),
      )
      .default(" "),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Integrate Product endpoint - Blend and integrate products/elements into backgrounds",
  });

/**
 * LightingRestorationOutput
 */
export const zQwenImageEdit2509LoraGalleryLightingRestorationOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated/edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * LightingRestorationInput
 *
 * Input model for Lighting Restoration endpoint - Restore natural lighting by removing harsh shadows and light spots
 */
export const zQwenImageEdit2509LoraGalleryLightingRestorationInput = z
  .object({
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: "The URL of the image to restore lighting for.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The negative prompt for the generation",
        }),
      )
      .default(" "),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Lighting Restoration endpoint - Restore natural lighting by removing harsh shadows and light spots",
  });

/**
 * RemoveElementOutput
 */
export const zQwenImageEdit2509LoraGalleryRemoveElementOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated/edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * RemoveElementInput
 *
 * Input model for Remove Element endpoint - Remove/delete elements (objects, people, text) from the image
 */
export const zQwenImageEdit2509LoraGalleryRemoveElementInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Specify what element(s) to remove from the image (objects, people, text, etc.). The model will cleanly remove the element while maintaining consistency of the rest of the image.",
        }),
      )
      .default("Remove the specified element from the scene"),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the LoRA effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: "The URL of the image containing elements to remove.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The negative prompt for the generation",
        }),
      )
      .default(" "),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Remove Element endpoint - Remove/delete elements (objects, people, text) from the image",
  });

/**
 * RemoveLightingOutput
 */
export const zQwenImageEdit2509LoraGalleryRemoveLightingOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated/edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * RemoveLightingInput
 *
 * Input model for Remove Lighting endpoint - Remove existing lighting and apply soft even lighting
 */
export const zQwenImageEdit2509LoraGalleryRemoveLightingInput = z
  .object({
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: "The URL of the image with lighting/shadows to remove.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The negative prompt for the generation",
        }),
      )
      .default(" "),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Remove Lighting endpoint - Remove existing lighting and apply soft even lighting",
  });

/**
 * ShirtDesignOutput
 */
export const zQwenImageEdit2509LoraGalleryShirtDesignOutput = z.object({
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated/edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * ShirtDesignInput
 *
 * Input model for Shirt Design endpoint - Put designs/graphics on people's shirts
 */
export const zQwenImageEdit2509LoraGalleryShirtDesignInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Describe what design to put on the shirt. The model will apply the design from your input image onto the person's shirt.",
        }),
      )
      .default("Put this design on their shirt"),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the LoRA effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to enable the safety checker for the generated image.",
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            "The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.",
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        "The URLs of the images: first image is the person wearing a shirt, second image is the design/logo to put on the shirt.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The negative prompt for the generation",
        }),
      )
      .default(" "),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Shirt Design endpoint - Put designs/graphics on people's shirts",
  });

/**
 * FluxSingleIDOutput
 */
export const zAiBabyAndAgingGeneratorSingleOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The final prompt used for generation",
  }),
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated image files info",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * SingleFluxIDInput
 *
 * Input schema for single mode generation
 */
export const zAiBabyAndAgingGeneratorSingleInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "Text prompt to guide the image generation",
        }),
      )
      .default("a newborn baby, well dressed"),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
      ]),
    ),
    id_image_urls: z.array(z.string()).min(1).register(z.globalRegistry, {
      description:
        "List of ID images for single mode (or general reference images)",
    }),
    output_format: z.optional(
      z.enum(["jpeg", "png"]).register(z.globalRegistry, {
        description:
          "The format of the generated image. Choose from: 'jpeg' or 'png'.",
      }),
    ),
    age_group: z
      .enum([
        "baby",
        "toddler",
        "preschool",
        "gradeschooler",
        "teen",
        "adult",
        "mid",
        "senior",
      ])
      .register(z.globalRegistry, {
        description:
          "Age group for the generated image. Choose from: 'baby' (0-12 months), 'toddler' (1-3 years), 'preschool' (3-5 years), 'gradeschooler' (6-12 years), 'teen' (13-19 years), 'adult' (20-40 years), 'mid' (40-60 years), 'senior' (60+ years).",
      }),
    gender: z.enum(["male", "female"]).register(z.globalRegistry, {
      description:
        "Gender for the generated image. Choose from: 'male' or 'female'.",
    }),
    seed: z.optional(z.union([z.int(), z.unknown()])),
  })
  .register(z.globalRegistry, {
    description: "Input schema for single mode generation",
  });

/**
 * FluxMultiIDOutput
 */
export const zAiBabyAndAgingGeneratorMultiOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The final prompt used for generation",
  }),
  images: z.array(zImageType3).register(z.globalRegistry, {
    description: "The generated image files info",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * MultiFluxIDInput
 *
 * Input schema for multi mode generation
 */
export const zAiBabyAndAgingGeneratorMultiInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "Text prompt to guide the image generation",
        }),
      )
      .default("a newborn baby, well dressed"),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
      ]),
    ),
    father_weight: z
      .optional(
        z.number().gte(0).lte(1).register(z.globalRegistry, {
          description:
            "Weight of the father's influence in multi mode generation",
        }),
      )
      .default(0.5),
    mother_image_urls: z.array(z.string()).min(1).register(z.globalRegistry, {
      description: "List of mother images for multi mode",
    }),
    output_format: z.optional(
      z.enum(["jpeg", "png"]).register(z.globalRegistry, {
        description:
          "The format of the generated image. Choose from: 'jpeg' or 'png'.",
      }),
    ),
    age_group: z
      .enum([
        "baby",
        "toddler",
        "preschool",
        "gradeschooler",
        "teen",
        "adult",
        "mid",
        "senior",
      ])
      .register(z.globalRegistry, {
        description:
          "Age group for the generated image. Choose from: 'baby' (0-12 months), 'toddler' (1-3 years), 'preschool' (3-5 years), 'gradeschooler' (6-12 years), 'teen' (13-19 years), 'adult' (20-40 years), 'mid' (40-60 years), 'senior' (60+ years).",
      }),
    gender: z.enum(["male", "female"]).register(z.globalRegistry, {
      description:
        "Gender for the generated image. Choose from: 'male' or 'female'.",
    }),
    father_image_urls: z.array(z.string()).min(1).register(z.globalRegistry, {
      description: "List of father images for multi mode",
    }),
    seed: z.optional(z.union([z.int(), z.unknown()])),
  })
  .register(z.globalRegistry, {
    description: "Input schema for multi mode generation",
  });

/**
 * Flux2MaxEditOutput
 */
export const zFlux2MaxEditOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for the generation.",
  }),
});

/**
 * Flux2MaxImageEditInput
 */
export const zFlux2MaxEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "auto",
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enable the safety checker.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The seed to use for the generation.",
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: "List of URLs of input images for editing",
  }),
});

/**
 * Flux2TurboEditImageOutput
 */
export const zFlux2TurboEditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * Flux2TurboEditImageInput
 */
export const zFlux2TurboEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to edit the image.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(2.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The seed to use for the generation. If not provided, a random seed will be used.",
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "The URLs of the images for editing. A maximum of 4 images are allowed, if more are provided, only the first 4 will be used.",
  }),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded for better results.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * EditImageResponse
 */
export const zGptImage15EditOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images.",
  }),
});

/**
 * EditImageRequest
 */
export const zGptImage15EditInput = z.object({
  background: z.optional(
    z.enum(["auto", "transparent", "opaque"]).register(z.globalRegistry, {
      description: "Background for the generated image",
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "Number of images to generate",
      }),
    )
    .default(1),
  image_size: z.optional(
    z
      .enum(["auto", "1024x1024", "1536x1024", "1024x1536"])
      .register(z.globalRegistry, {
        description: "Aspect ratio for the generated image",
      }),
  ),
  prompt: z.string().min(2).register(z.globalRegistry, {
    description: "The prompt for image generation",
  }),
  quality: z.optional(
    z.enum(["low", "medium", "high"]).register(z.globalRegistry, {
      description: "Quality for the generated image",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "Output format for the images",
    }),
  ),
  input_fidelity: z.optional(
    z.enum(["low", "high"]).register(z.globalRegistry, {
      description: "Input fidelity for the generated image",
    }),
  ),
  mask_image_url: z.optional(z.union([z.string(), z.string()])),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "The URLs of the images to use as a reference for the generation.",
  }),
});

/**
 * Flux2FlashEditImageOutput
 */
export const zFlux2FlashEditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * Flux2FlashEditImageInput
 */
export const zFlux2FlashEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to edit the image.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(2.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The seed to use for the generation. If not provided, a random seed will be used.",
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "The URLs of the images for editing. A maximum of 4 images are allowed, if more are provided, only the first 4 will be used.",
  }),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded for better results.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * ZImageTurboInpaintOutput
 */
export const zZImageTurboInpaintOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: "The timings of the generation process.",
  }),
});

/**
 * ZImageTurboInpaintInput
 */
export const zZImageTurboInpaintInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
        "auto",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use.",
    }),
  ),
  mask_image_url: z.union([z.string(), z.string()]),
  control_end: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The end of the controlnet conditioning.",
      }),
    )
    .default(0.8),
  control_start: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The start of the controlnet conditioning.",
      }),
    )
    .default(0),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description: "The strength of the inpaint conditioning.",
      }),
    )
    .default(1),
  control_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The scale of the controlnet conditioning.",
      }),
    )
    .default(0.75),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.",
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(8),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * ZImageTurboInpaintOutput
 */
export const zZImageTurboInpaintLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: "The timings of the generation process.",
  }),
});

/**
 * ZImageTurboInpaintLoRAInput
 */
export const zZImageTurboInpaintLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
        "auto",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use.",
    }),
  ),
  mask_image_url: z.union([z.string(), z.string()]),
  loras: z
    .optional(
      z.array(zLoRaInput).register(z.globalRegistry, {
        description: "List of LoRA weights to apply (maximum 3).",
      }),
    )
    .default([]),
  control_end: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The end of the controlnet conditioning.",
      }),
    )
    .default(0.8),
  control_start: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The start of the controlnet conditioning.",
      }),
    )
    .default(0),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description: "The strength of the inpaint conditioning.",
      }),
    )
    .default(1),
  control_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "The scale of the controlnet conditioning.",
      }),
    )
    .default(0.75),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.",
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(8),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * QwenImageLayeredOutput
 */
export const zQwenImageLayeredOutput = z.object({
  prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The prompt used to generate the image.",
    }),
  ),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageInput
 */
export const zQwenImageLayeredInput = z.object({
  prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description: "A caption for the input image.",
    }),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use.",
    }),
  ),
  num_layers: z
    .optional(
      z.int().gte(1).lte(10).register(z.globalRegistry, {
        description: "The number of layers to generate.",
      }),
    )
    .default(4),
  output_format: z.optional(
    z.enum(["png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description: "The guidance scale to use for the image generation.",
      }),
    )
    .default(5),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The negative prompt to generate an image from.",
      }),
    )
    .default(""),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
});

/**
 * ImageToImageOutput
 */
export const zQwenImageEdit2511Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * EditImageInput
 */
export const zQwenImageEdit2511Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to edit the image with.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If `True`, the media will be returned as a data URI.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description: "The guidance scale to use for the image generation.",
      }),
    )
    .default(4.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: "The URLs of the images to edit.",
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The negative prompt to generate an image from.",
      }),
    )
    .default(""),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The same seed and the same prompt given to the same version of the model will output the same image every time.",
    }),
  ),
});

/**
 * ImageEditOutput
 *
 * Output for Wan 2.6 image editing
 */
export const zV26ImageToImageOutput = z
  .object({
    images: z.array(zFile).register(z.globalRegistry, {
      description: "Generated images in PNG format",
    }),
    seed: z.int().register(z.globalRegistry, {
      description: "The seed used for generation",
    }),
  })
  .register(z.globalRegistry, {
    description: "Output for Wan 2.6 image editing",
  });

/**
 * ImageEditInput
 *
 * Input for Wan 2.6 image editing with reference images (enable_interleave=false)
 */
export const zV26ImageToImageInput = z
  .object({
    prompt: z.string().min(1).register(z.globalRegistry, {
      description:
        "Text prompt describing the desired image. Supports Chinese and English. Max 2000 characters. Example: 'Generate an image using the style of image 1 and background of image 2'.",
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description:
            "Number of images to generate (1-4). Directly affects billing cost.",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
      ]),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Enable content moderation for input and output.",
        }),
      )
      .default(true),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          "Random seed for reproducibility (0-2147483647). Same seed produces more consistent results.",
      }),
    ),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        "Reference images for editing (1-3 images required). Order matters: reference as 'image 1', 'image 2', 'image 3' in prompt. Resolution: 384-5000px each dimension. Max size: 10MB each. Formats: JPEG, JPG, PNG (no alpha), BMP, WEBP.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Content to avoid in the generated image. Max 500 characters.",
        }),
      )
      .default(""),
    enable_prompt_expansion: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Enable LLM prompt optimization. Significantly improves results for simple prompts but adds 3-4 seconds processing time.",
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description:
      "Input for Wan 2.6 image editing with reference images (enable_interleave=false)",
  });

/**
 * QwenImageLayeredOutput
 */
export const zQwenImageLayeredLoraOutput = z.object({
  prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The prompt used to generate the image.",
    }),
  ),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * TextToImageLoRAInput
 */
export const zQwenImageLayeredLoraInput = z.object({
  prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description: "A caption for the input image.",
    }),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use.",
    }),
  ),
  num_layers: z
    .optional(
      z.int().gte(1).lte(10).register(z.globalRegistry, {
        description: "The number of layers to generate.",
      }),
    )
    .default(4),
  output_format: z.optional(
    z.enum(["png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  loras: z
    .optional(
      z.array(zLoRaInput).register(z.globalRegistry, {
        description: "List of LoRA weights to apply (maximum 3).",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description: "The guidance scale to use for the image generation.",
      }),
    )
    .default(5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The negative prompt to generate an image from.",
      }),
    )
    .default(""),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
});

/**
 * ArchEditOutput
 */
export const zAiHomeEditOutput = z.object({
  image: zImageType3,
  status: z.string().register(z.globalRegistry, {
    description: "Status message with processing details",
  }),
});

/**
 * ArchEditInput
 */
export const zAiHomeEditInput = z.object({
  input_image_url: z.union([z.string(), z.string()]),
  editing_type: z
    .enum(["structural editing", "virtual staging", "both"])
    .register(z.globalRegistry, {
      description:
        "Type of editing. Structural editing only edits structural elements such as windows, walls etc. Virtual staging edits your furniture. Both do full editing including structural and furniture",
    }),
  style: z
    .enum([
      "minimalistic-interior",
      "farmhouse-interior",
      "luxury-interior",
      "modern-interior",
      "zen-interior",
      "mid century-interior",
      "airbnb-interior",
      "cozy-interior",
      "rustic-interior",
      "christmas-interior",
      "bohemian-interior",
      "tropical-interior",
      "industrial-interior",
      "japanese-interior",
      "vintage-interior",
      "loft-interior",
      "halloween-interior",
      "soho-interior",
      "baroque-interior",
      "kids room-interior",
      "girls room-interior",
      "boys room-interior",
      "scandinavian-interior",
      "french country-interior",
      "mediterranean-interior",
      "cyberpunk-interior",
      "hot pink-interior",
      "biophilic-interior",
      "ancient egypt-interior",
      "pixel-interior",
      "art deco-interior",
      "modern-exterior",
      "minimalistic-exterior",
      "farmhouse-exterior",
      "cozy-exterior",
      "luxury-exterior",
      "colonial-exterior",
      "zen-exterior",
      "asian-exterior",
      "creepy-exterior",
      "airstone-exterior",
      "ancient greek-exterior",
      "art deco-exterior",
      "brutalist-exterior",
      "christmas lights-exterior",
      "contemporary-exterior",
      "cottage-exterior",
      "dutch colonial-exterior",
      "federal colonial-exterior",
      "fire-exterior",
      "french provincial-exterior",
      "full glass-exterior",
      "georgian colonial-exterior",
      "gothic-exterior",
      "greek revival-exterior",
      "ice-exterior",
      "italianate-exterior",
      "mediterranean-exterior",
      "midcentury-exterior",
      "middle eastern-exterior",
      "minecraft-exterior",
      "morocco-exterior",
      "neoclassical-exterior",
      "spanish-exterior",
      "tudor-exterior",
      "underwater-exterior",
      "winter-exterior",
      "yard lighting-exterior",
    ])
    .register(z.globalRegistry, {
      description: "Style for furniture and decor",
    }),
  additional_elements: z.optional(z.union([z.string().max(200), z.unknown()])),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description:
        "The format of the generated image. Choose from: 'jpeg' or 'png'.",
    }),
  ),
  architecture_type: z
    .enum([
      "living room-interior",
      "bedroom-interior",
      "kitchen-interior",
      "dining room-interior",
      "bathroom-interior",
      "laundry room-interior",
      "home office-interior",
      "study room-interior",
      "dorm room-interior",
      "coffee shop-interior",
      "gaming room-interior",
      "restaurant-interior",
      "office-interior",
      "attic-interior",
      "toilet-interior",
      "other-interior",
      "house-exterior",
      "villa-exterior",
      "backyard-exterior",
      "courtyard-exterior",
      "ranch-exterior",
      "office-exterior",
      "retail-exterior",
      "tower-exterior",
      "apartment-exterior",
      "school-exterior",
      "museum-exterior",
      "commercial-exterior",
      "residential-exterior",
      "other-exterior",
    ])
    .register(z.globalRegistry, {
      description: "Type of architecture for appropriate furniture selection",
    }),
  color_palette: z
    .enum([
      "surprise me",
      "golden beige",
      "refined blues",
      "dusky elegance",
      "emerald charm",
      "crimson luxury",
      "golden sapphire",
      "soft pastures",
      "candy sky",
      "peach meadow",
      "muted sands",
      "ocean breeze",
      "frosted pastels",
      "spring bloom",
      "gentle horizon",
      "seaside breeze",
      "azure coast",
      "golden shore",
      "mediterranean gem",
      "ocean serenity",
      "serene blush",
      "muted horizon",
      "pastel shores",
      "dusky calm",
      "woodland retreat",
      "meadow glow",
      "forest canopy",
      "riverbank calm",
      "earthy tones",
      "earthy neutrals",
      "arctic mist",
      "aqua drift",
      "blush bloom",
      "coral haze",
      "retro rust",
      "autumn glow",
      "rustic charm",
      "vintage sage",
      "faded plum",
      "electric lime",
      "violet pulse",
      "neon sorbet",
      "aqua glow",
      "fluorescent sunset",
      "lavender bloom",
      "petal fresh",
      "meadow light",
      "sunny pastures",
      "frosted mauve",
      "snowy hearth",
      "icy blues",
      "winter twilight",
      "earthy hues",
      "stone balance",
      "neutral sands",
      "slate shades",
    ])
    .register(z.globalRegistry, {
      description: "Color palette for furniture and decor",
    }),
  custom_prompt: z
    .optional(
      z.string().max(300).register(z.globalRegistry, {
        description:
          "Custom prompt for architectural editing, it overrides above options when used",
      }),
    )
    .default(""),
});

/**
 * ArchStyleOutput
 */
export const zAiHomeStyleOutput = z.object({
  image: zImageType3,
  status: z.string().register(z.globalRegistry, {
    description: "Status message with processing details",
  }),
});

/**
 * ArchStyleInput
 */
export const zAiHomeStyleInput = z.object({
  input_image_url: z.union([z.string(), z.string()]),
  input_image_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Strength of the input image",
      }),
    )
    .default(0.85),
  additional_elements: z.optional(z.union([z.string().max(200), z.unknown()])),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description:
        "The format of the generated image. Choose from: 'jpeg' or 'png'.",
    }),
  ),
  style: z
    .enum([
      "minimalistic-interior",
      "farmhouse-interior",
      "luxury-interior",
      "modern-interior",
      "zen-interior",
      "mid century-interior",
      "airbnb-interior",
      "cozy-interior",
      "rustic-interior",
      "christmas-interior",
      "bohemian-interior",
      "tropical-interior",
      "industrial-interior",
      "japanese-interior",
      "vintage-interior",
      "loft-interior",
      "halloween-interior",
      "soho-interior",
      "baroque-interior",
      "kids room-interior",
      "girls room-interior",
      "boys room-interior",
      "scandinavian-interior",
      "french country-interior",
      "mediterranean-interior",
      "cyberpunk-interior",
      "hot pink-interior",
      "biophilic-interior",
      "ancient egypt-interior",
      "pixel-interior",
      "art deco-interior",
      "modern-exterior",
      "minimalistic-exterior",
      "farmhouse-exterior",
      "cozy-exterior",
      "luxury-exterior",
      "colonial-exterior",
      "zen-exterior",
      "asian-exterior",
      "creepy-exterior",
      "airstone-exterior",
      "ancient greek-exterior",
      "art deco-exterior",
      "brutalist-exterior",
      "christmas lights-exterior",
      "contemporary-exterior",
      "cottage-exterior",
      "dutch colonial-exterior",
      "federal colonial-exterior",
      "fire-exterior",
      "french provincial-exterior",
      "full glass-exterior",
      "georgian colonial-exterior",
      "gothic-exterior",
      "greek revival-exterior",
      "ice-exterior",
      "italianate-exterior",
      "mediterranean-exterior",
      "midcentury-exterior",
      "middle eastern-exterior",
      "minecraft-exterior",
      "morocco-exterior",
      "neoclassical-exterior",
      "spanish-exterior",
      "tudor-exterior",
      "underwater-exterior",
      "winter-exterior",
      "yard lighting-exterior",
    ])
    .register(z.globalRegistry, {
      description: "Style for furniture and decor",
    }),
  architecture_type: z
    .enum([
      "living room-interior",
      "bedroom-interior",
      "kitchen-interior",
      "dining room-interior",
      "bathroom-interior",
      "laundry room-interior",
      "home office-interior",
      "study room-interior",
      "dorm room-interior",
      "coffee shop-interior",
      "gaming room-interior",
      "restaurant-interior",
      "office-interior",
      "attic-interior",
      "toilet-interior",
      "other-interior",
      "house-exterior",
      "villa-exterior",
      "backyard-exterior",
      "courtyard-exterior",
      "ranch-exterior",
      "office-exterior",
      "retail-exterior",
      "tower-exterior",
      "apartment-exterior",
      "school-exterior",
      "museum-exterior",
      "commercial-exterior",
      "residential-exterior",
      "other-exterior",
    ])
    .register(z.globalRegistry, {
      description: "Type of architecture for appropriate furniture selection",
    }),
  color_palette: z
    .enum([
      "surprise me",
      "golden beige",
      "refined blues",
      "dusky elegance",
      "emerald charm",
      "crimson luxury",
      "golden sapphire",
      "soft pastures",
      "candy sky",
      "peach meadow",
      "muted sands",
      "ocean breeze",
      "frosted pastels",
      "spring bloom",
      "gentle horizon",
      "seaside breeze",
      "azure coast",
      "golden shore",
      "mediterranean gem",
      "ocean serenity",
      "serene blush",
      "muted horizon",
      "pastel shores",
      "dusky calm",
      "woodland retreat",
      "meadow glow",
      "forest canopy",
      "riverbank calm",
      "earthy tones",
      "earthy neutrals",
      "arctic mist",
      "aqua drift",
      "blush bloom",
      "coral haze",
      "retro rust",
      "autumn glow",
      "rustic charm",
      "vintage sage",
      "faded plum",
      "electric lime",
      "violet pulse",
      "neon sorbet",
      "aqua glow",
      "fluorescent sunset",
      "lavender bloom",
      "petal fresh",
      "meadow light",
      "sunny pastures",
      "frosted mauve",
      "snowy hearth",
      "icy blues",
      "winter twilight",
      "earthy hues",
      "stone balance",
      "neutral sands",
      "slate shades",
    ])
    .register(z.globalRegistry, {
      description: "Color palette for furniture and decor",
    }),
  style_image_url: z.optional(z.union([z.string().max(512), z.unknown()])),
  custom_prompt: z
    .optional(
      z.string().max(300).register(z.globalRegistry, {
        description:
          "Custom prompt for architectural editing, it overrides above options when used",
      }),
    )
    .default(""),
  enhanced_rendering: z.optional(z.union([z.boolean(), z.unknown()])),
});

/**
 * ImageToImageOutput
 */
export const zQwenImageEdit2511LoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * EditImageLoraInput
 */
export const zQwenImageEdit2511LoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to edit the image with.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If `True`, the media will be returned as a data URI.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description:
          "The LoRAs to use for the image generation. You can use up to 3 LoRAs and they will be merged together to generate the final image.",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description: "The guidance scale to use for the image generation.",
      }),
    )
    .default(4.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: "The URLs of the images to edit.",
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The negative prompt to generate an image from.",
      }),
    )
    .default(""),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The same seed and the same prompt given to the same version of the model will output the same image every time.",
    }),
  ),
});

/**
 * MultipleAnglesOutput
 *
 * Output model for Multiple Angles endpoint
 */
export const zQwenImageEdit2511MultipleAnglesOutput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: "The constructed prompt used for generation",
    }),
    images: z.array(zImage).register(z.globalRegistry, {
      description: "The generated/edited images",
    }),
    seed: z.int().register(z.globalRegistry, {
      description: "The seed used for generation",
    }),
  })
  .register(z.globalRegistry, {
    description: "Output model for Multiple Angles endpoint",
  });

/**
 * MultipleAnglesInput
 *
 * Input model for Multiple Angles endpoint - Camera control with precise adjustments using <sks> trigger word.
 * Prompt is built automatically from slider values.
 */
export const zQwenImageEdit2511MultipleAnglesInput = z
  .object({
    acceleration: z.optional(
      z.enum(["none", "regular"]).register(z.globalRegistry, {
        description: "Acceleration level for image generation.",
      }),
    ),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
      ]),
    ),
    horizontal_angle: z
      .optional(
        z.number().gte(0).lte(360).register(z.globalRegistry, {
          description:
            "Horizontal rotation angle around the object in degrees. 0=front view, 90=right side, 180=back view, 270=left side, 360=front view again.",
        }),
      )
      .default(0),
    guidance_scale: z
      .optional(
        z.number().gte(1).lte(20).register(z.globalRegistry, {
          description: "The CFG (Classifier Free Guidance) scale.",
        }),
      )
      .default(4.5),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether to enable the safety checker.",
        }),
      )
      .default(true),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: "The URL of the image to adjust camera angle for.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The negative prompt for the generation",
        }),
      )
      .default(""),
    zoom: z
      .optional(
        z.number().gte(0).lte(10).register(z.globalRegistry, {
          description:
            "Camera zoom/distance. 0=wide shot (far away), 5=medium shot (normal), 10=close-up (very close).",
        }),
      )
      .default(5),
    vertical_angle: z
      .optional(
        z.number().gte(-30).lte(90).register(z.globalRegistry, {
          description:
            "Vertical camera angle in degrees. -30=low-angle shot (looking up), 0=eye-level, 30=elevated, 60=high-angle, 90=bird's-eye view (looking down).",
        }),
      )
      .default(0),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: "Number of images to generate",
        }),
      )
      .default(1),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            "The scale factor for the LoRA model. Controls the strength of the camera control effect.",
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(["png", "jpeg", "webp"]).register(z.globalRegistry, {
        description: "The format of the output image",
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "If `True`, the media will be returned as a data URI.",
        }),
      )
      .default(false),
    additional_prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          "Additional text to append to the automatically generated prompt.",
      }),
    ),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: "Random seed for reproducibility.",
      }),
    ),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: "The number of inference steps to perform.",
        }),
      )
      .default(28),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Multiple Angles endpoint - Camera control with precise adjustments using <sks> trigger word.\nPrompt is built automatically from slider values.",
  });

/**
 * GlmImageToImageOutput
 */
export const zGlmImageImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "List of URLs to the generated images.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * GlmImageToImageInput
 */
export const zGlmImageImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "Text prompt for image generation.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "Number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
        "portrait_3_2",
        "landscape_3_2",
        "portrait_hd",
        "landscape_hd",
      ]),
    ]),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Enable NSFW safety checking on the generated images.",
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "Output image format.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If True, the image will be returned as a base64 data URI instead of a URL.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "Classifier-free guidance scale. Higher values make the model follow the prompt more closely.",
      }),
    )
    .default(1.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed for reproducibility. The same seed with the same prompt will produce the same image.",
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "URL(s) of the condition image(s) for image-to-image generation. Supports up to 4 URLs for multi-image references.",
  }),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If True, the prompt will be enhanced using an LLM for more detailed and higher quality results.",
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(100).register(z.globalRegistry, {
        description:
          "Number of diffusion denoising steps. More steps generally produce higher quality images.",
      }),
    )
    .default(30),
});

/**
 * Klein9BDistilledEditOutput
 */
export const zFlux2Klein9bEditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The edited images",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * Klein9BDistilledEditInput
 */
export const zFlux2Klein9bEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to edit the image.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI. Output is not stored when this is True.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(8).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(4),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "The URLs of the images for editing. A maximum of 4 images are allowed.",
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The seed to use for the generation. If not provided, a random seed will be used.",
    }),
  ),
});

/**
 * Klein4BDistilledEditOutput
 */
export const zFlux2Klein4bEditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The edited images",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * KleinDistilledEditInput
 */
export const zFlux2Klein4bEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to edit the image.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI. Output is not stored when this is True.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(8).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(4),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "The URLs of the images for editing. A maximum of 4 images are allowed.",
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The seed to use for the generation. If not provided, a random seed will be used.",
    }),
  ),
});

/**
 * Klein9BBaseEditOutput
 */
export const zFlux2Klein9bBaseEditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The edited images",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * Klein9BEditImageInput
 */
export const zFlux2Klein9bBaseEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to edit the image.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use for image generation.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "Guidance scale for classifier-free guidance.",
      }),
    )
    .default(5),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI. Output is not stored when this is True.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "The URLs of the images for editing. A maximum of 4 images are allowed.",
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Negative prompt for classifier-free guidance. Describes what to avoid in the image.",
      }),
    )
    .default(""),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The seed to use for the generation. If not provided, a random seed will be used.",
    }),
  ),
});

/**
 * Klein4BBaseEditOutput
 */
export const zFlux2Klein4bBaseEditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The edited images",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * Klein4BBaseEditInput
 */
export const zFlux2Klein4bBaseEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to edit the image.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use for image generation.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "Guidance scale for classifier-free guidance.",
      }),
    )
    .default(5),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI. Output is not stored when this is True.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "The URLs of the images for editing. A maximum of 4 images are allowed.",
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Negative prompt for classifier-free guidance. Describes what to avoid in the image.",
      }),
    )
    .default(""),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The seed to use for the generation. If not provided, a random seed will be used.",
    }),
  ),
});

/**
 * KleinT2IOutput
 */
export const zFlux2Klein4bBaseEditLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * KleinBaseEditLoRAInput
 */
export const zFlux2Klein4bBaseEditLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to edit the image.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use for image generation.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "Guidance scale for classifier-free guidance.",
      }),
    )
    .default(5),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  loras: z
    .optional(
      z.array(zFalAiFlux2KleinLoRaInput).register(z.globalRegistry, {
        description: "List of LoRA weights to apply (maximum 3).",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI. Output is not stored when this is True.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "The URLs of the images for editing. A maximum of 4 images are allowed.",
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Negative prompt for classifier-free guidance. Describes what to avoid in the image.",
      }),
    )
    .default(""),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The seed to use for the generation. If not provided, a random seed will be used.",
    }),
  ),
});

/**
 * KleinT2IOutput
 */
export const zFlux2Klein9bBaseEditLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * KleinBaseEditLoRAInput
 */
export const zFlux2Klein9bBaseEditLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to edit the image.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use for image generation.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "Guidance scale for classifier-free guidance.",
      }),
    )
    .default(5),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  loras: z
    .optional(
      z.array(zFalAiFlux2KleinLoRaInput).register(z.globalRegistry, {
        description: "List of LoRA weights to apply (maximum 3).",
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI. Output is not stored when this is True.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "The URLs of the images for editing. A maximum of 4 images are allowed.",
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Negative prompt for classifier-free guidance. Describes what to avoid in the image.",
      }),
    )
    .default(""),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The seed to use for the generation. If not provided, a random seed will be used.",
    }),
  ),
});

/**
 * FiboEditExtraEPOutputModel
 */
export const zFiboEditColorizeOutput = z.object({
  images: z
    .optional(
      z.array(zImageType3).register(z.globalRegistry, {
        description: "Generated images.",
      }),
    )
    .default([]),
  image: zImageType3,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: "Current instruction.",
    }),
});

/**
 * ColorizeInput
 */
export const zFiboEditColorizeInput = z.object({
  color: z
    .enum([
      "contemporary color",
      "vivid color",
      "black and white colors",
      "sepia vintage",
    ])
    .register(z.globalRegistry, {
      description: "Select the color palette or aesthetic for the output image",
    }),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * FiboEditExtraEPOutputModel
 */
export const zFiboEditBlendOutput = z.object({
  images: z
    .optional(
      z.array(zImageType3).register(z.globalRegistry, {
        description: "Generated images.",
      }),
    )
    .default([]),
  image: zImageType3,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: "Current instruction.",
    }),
});

/**
 * BlendingInput
 */
export const zFiboEditBlendInput = z.object({
  instruction: z.string().register(z.globalRegistry, {
    description:
      "Instruct what elements you would like to blend in your image.",
  }),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * FiboEditExtraEPOutputModel
 */
export const zFiboEditAddObjectByTextOutput = z.object({
  images: z
    .optional(
      z.array(zImageType3).register(z.globalRegistry, {
        description: "Generated images.",
      }),
    )
    .default([]),
  image: zImageType3,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: "Current instruction.",
    }),
});

/**
 * AddObjectByTextInput
 */
export const zFiboEditAddObjectByTextInput = z.object({
  instruction: z.string().register(z.globalRegistry, {
    description:
      "The full natural language command describing what to add and where.",
  }),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * StructuredInstruction
 */
export const zStructuredInstruction = z.object({
  background_setting: z.optional(z.union([z.string(), z.unknown()])),
  artistic_style: z.optional(z.union([z.string(), z.unknown()])),
  context: z.optional(z.union([z.string(), z.unknown()])),
  text_render: z.optional(z.union([z.array(z.unknown()), z.unknown()])),
  objects: z.optional(z.union([z.array(zPromptObject), z.unknown()])),
  style_medium: z.optional(z.union([z.string(), z.unknown()])),
  photographic_characteristics: z.optional(
    z.union([zPhotographicCharacteristics, z.unknown()]),
  ),
  aesthetics: z.optional(z.union([zAesthetics, z.unknown()])),
  lighting: z.optional(z.union([zLighting, z.unknown()])),
  short_description: z.optional(z.union([z.string(), z.unknown()])),
  edit_instruction: z.optional(z.union([z.string(), z.unknown()])),
});

/**
 * FiboEditOutputModel
 */
export const zFiboEditEditOutput = z.object({
  images: z
    .optional(
      z.array(zImageType3).register(z.globalRegistry, {
        description: "Generated images.",
      }),
    )
    .default([]),
  image: zImageType3,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: "Current instruction.",
    }),
});

/**
 * FiboEditInputModel
 */
export const zFiboEditEditInput = z.object({
  steps_num: z
    .optional(
      z.int().gte(20).lte(50).register(z.globalRegistry, {
        description: "Number of inference steps.",
      }),
    )
    .default(50),
  instruction: z.optional(z.union([z.string(), z.unknown()])),
  image_url: z.optional(z.union([z.string(), z.unknown()])),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If true, returns the image directly in the response (increases latency).",
      }),
    )
    .default(false),
  guidance_scale: z.optional(z.union([z.number(), z.int()])),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Random seed for reproducibility.",
      }),
    )
    .default(5555),
  mask_url: z.optional(z.union([z.string(), z.unknown()])),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Negative prompt for image generation.",
      }),
    )
    .default(""),
  structured_instruction: z.optional(
    z.union([zStructuredInstruction, z.unknown()]),
  ),
});

/**
 * FiboEditExtraEPOutputModel
 */
export const zFiboEditEraseByTextOutput = z.object({
  images: z
    .optional(
      z.array(zImageType3).register(z.globalRegistry, {
        description: "Generated images.",
      }),
    )
    .default([]),
  image: zImageType3,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: "Current instruction.",
    }),
});

/**
 * EraseByTextInput
 */
export const zFiboEditEraseByTextInput = z.object({
  object_name: z.string().register(z.globalRegistry, {
    description: "The name of the object to remove.",
  }),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * FiboEditExtraEPOutputModel
 */
export const zFiboEditRewriteTextOutput = z.object({
  images: z
    .optional(
      z.array(zImageType3).register(z.globalRegistry, {
        description: "Generated images.",
      }),
    )
    .default([]),
  image: zImageType3,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: "Current instruction.",
    }),
});

/**
 * RewriteTextInput
 */
export const zFiboEditRewriteTextInput = z.object({
  new_text: z.string().register(z.globalRegistry, {
    description: "The new text string to appear in the image.",
  }),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * FiboEditExtraEPOutputModel
 */
export const zFiboEditRestyleOutput = z.object({
  images: z
    .optional(
      z.array(zImageType3).register(z.globalRegistry, {
        description: "Generated images.",
      }),
    )
    .default([]),
  image: zImageType3,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: "Current instruction.",
    }),
});

/**
 * RestyletInput
 */
export const zFiboEditRestyleInput = z.object({
  style: z
    .enum([
      "3D Render",
      "Cubism",
      "Oil Painting",
      "Anime",
      "Cartoon",
      "Coloring Book",
      "Retro Ad",
      "Pop Art Halftone",
      "Vector Art",
      "Story Board",
      "Art Nouveau",
      "Cross Etching",
      "Wood Cut",
    ])
    .register(z.globalRegistry, {
      description: "Select the desired artistic style for the output image.",
    }),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * FiboEditExtraEPOutputModel
 */
export const zFiboEditRelightOutput = z.object({
  images: z
    .optional(
      z.array(zImageType3).register(z.globalRegistry, {
        description: "Generated images.",
      }),
    )
    .default([]),
  image: zImageType3,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: "Current instruction.",
    }),
});

/**
 * RelightInput
 */
export const zFiboEditRelightInput = z.object({
  light_type: z
    .enum([
      "midday",
      "blue hour light",
      "low-angle sunlight",
      "sunrise light",
      "spotlight on subject",
      "overcast light",
      "soft overcast daylight lighting",
      "cloud-filtered lighting",
      "fog-diffused lighting",
      "moonlight lighting",
      "starlight nighttime",
      "soft bokeh lighting",
      "harsh studio lighting",
    ])
    .register(z.globalRegistry, {
      description: "The quality/style/time of day.",
    }),
  light_direction: z.union([
    z.enum(["front", "side", "bottom", "top-down"]),
    z.unknown(),
  ]),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * FiboEditExtraEPOutputModel
 */
export const zFiboEditReseasonOutput = z.object({
  images: z
    .optional(
      z.array(zImageType3).register(z.globalRegistry, {
        description: "Generated images.",
      }),
    )
    .default([]),
  image: zImageType3,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: "Current instruction.",
    }),
});

/**
 * ReseasonInput
 */
export const zFiboEditReseasonInput = z.object({
  season: z
    .enum(["spring", "summer", "autumn", "winter"])
    .register(z.globalRegistry, {
      description: "The desired season.",
    }),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * FiboEditExtraEPOutputModel
 */
export const zFiboEditRestoreOutput = z.object({
  images: z
    .optional(
      z.array(zImageType3).register(z.globalRegistry, {
        description: "Generated images.",
      }),
    )
    .default([]),
  image: zImageType3,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: "Current instruction.",
    }),
});

/**
 * RestoreInput
 */
export const zFiboEditRestoreInput = z.object({
  image_url: z.union([z.string(), z.string()]),
});

/**
 * FiboEditExtraEPOutputModel
 */
export const zFiboEditSketchToColoredImageOutput = z.object({
  images: z
    .optional(
      z.array(zImageType3).register(z.globalRegistry, {
        description: "Generated images.",
      }),
    )
    .default([]),
  image: zImageType3,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: "Current instruction.",
    }),
});

/**
 * SketchColoredImageInput
 */
export const zFiboEditSketchToColoredImageInput = z.object({
  image_url: z.union([z.string(), z.string()]),
});

/**
 * FiboEditExtraEPOutputModel
 */
export const zFiboEditReplaceObjectByTextOutput = z.object({
  images: z
    .optional(
      z.array(zImageType3).register(z.globalRegistry, {
        description: "Generated images.",
      }),
    )
    .default([]),
  image: zImageType3,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: "Current instruction.",
    }),
});

/**
 * ReplaceObjectInput
 */
export const zFiboEditReplaceObjectByTextInput = z.object({
  instruction: z.string().register(z.globalRegistry, {
    description:
      "The full natural language command describing what to replace.",
  }),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * FaceFusionImageOutput
 *
 * FaceFusion output payload when image content is generated
 */
export const zAiFaceSwapFaceswapimageOutput = z
  .object({
    image: zImageType3,
    processing_time_ms: z.optional(z.union([z.int(), z.unknown()])),
  })
  .register(z.globalRegistry, {
    description: "FaceFusion output payload when image content is generated",
  });

/**
 * FaceSwapInputImage
 *
 * Input schema for image  image face swap
 */
export const zAiFaceSwapFaceswapimageInput = z
  .object({
    enable_occlusion_prevention: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Enable occlusion prevention for handling faces covered by hands/objects. Warning: Enabling this runs an occlusion-aware model which costs 2x more.",
        }),
      )
      .default(false),
    source_face_url: z.union([z.string(), z.string()]),
    target_image_url: z.union([z.string(), z.string()]),
  })
  .register(z.globalRegistry, {
    description: "Input schema for image  image face swap",
  });

/**
 * ReplaceBackgroundOutputModel
 */
export const zReplaceBackgroundOutput = z.object({
  images: z.optional(
    z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
      description: "Generated images.",
    }),
  ),
  image: zImageType3,
});

/**
 * ReplaceBackgroundInputModel
 */
export const zReplaceBackgroundInput = z.object({
  prompt: z.optional(z.union([z.string(), z.unknown()])),
  steps_num: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Number of inference steps.",
      }),
    )
    .default(30),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If true, returns the image directly in the response (increases latency).",
      }),
    )
    .default(false),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: "Random seed for reproducibility.",
      }),
    )
    .default(4925634),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Negative prompt for background replacement.",
      }),
    )
    .default(""),
  image_url: z.optional(z.union([z.string(), z.unknown()])),
});

/**
 * QwenImageMaxEditOutput
 */
export const zQwenImageMaxEditOutput = z.object({
  images: z.array(zFile).register(z.globalRegistry, {
    description: "Generated images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for generation",
  }),
});

/**
 * QwenImageMaxEditInput
 *
 * Input for Qwen Image Max image editing with reference images
 */
export const zQwenImageMaxEditInput = z
  .object({
    prompt: z.string().min(1).max(800).register(z.globalRegistry, {
      description:
        "Text prompt describing the desired image. Supports Chinese and English. Max 800 characters.",
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(6).register(z.globalRegistry, {
          description: "The number of images to generate.",
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zImageSize,
        z.enum([
          "square_hd",
          "square",
          "portrait_4_3",
          "portrait_16_9",
          "landscape_4_3",
          "landscape_16_9",
        ]),
      ]),
    ),
    output_format: z.optional(
      z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
        description: "The format of the generated image.",
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
        }),
      )
      .default(false),
    enable_prompt_expansion: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Enable LLM prompt optimization for better results.",
        }),
      )
      .default(true),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: "Random seed for reproducibility (0-2147483647).",
      }),
    ),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        "Reference images for editing (1-3 images required). Order matters: reference as 'image 1', 'image 2', 'image 3' in prompt. Resolution: 384-5000px each dimension. Max size: 10MB each. Formats: JPEG, JPG, PNG (no alpha), WEBP.",
    }),
    negative_prompt: z
      .optional(
        z.string().max(500).register(z.globalRegistry, {
          description:
            "Content to avoid in the generated image. Max 500 characters.",
        }),
      )
      .default(""),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: "Enable content moderation for input and output.",
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: "Input for Qwen Image Max image editing with reference images",
  });

/**
 * HunyuanImageEditResponse
 */
export const zHunyuanImageV3InstructEditOutput = z.object({
  images: z.array(zImage).register(z.globalRegistry, {
    description: "A list of the generated images.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The base seed used for the generation process.",
  }),
});

/**
 * HunyuanImageEditRequest
 */
export const zHunyuanImageV3InstructEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The text prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "auto",
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed for reproducible results. If None, a random seed is used.",
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "The URLs of the images to use as a reference for the generation. A maximum of 2 images are supported.",
  }),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "Controls how much the model adheres to the prompt. Higher values mean stricter adherence.",
      }),
    )
    .default(3.5),
});

/**
 * XAIImageEditOutput
 */
export const zGrokImagineImageEditOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The URL of the edited image.",
  }),
  revised_prompt: z.string().register(z.globalRegistry, {
    description: "The enhanced prompt that was used to generate the image.",
  }),
});

/**
 * XAIImageEditInput
 */
export const zGrokImagineImageEditInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "Number of images to generate.",
      }),
    )
    .default(1),
  prompt: z.string().max(8000).register(z.globalRegistry, {
    description: "Text description of the desired image.",
  }),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * Output
 */
export const zClarityUpscalerOutput = z.object({
  image: zImageType3,
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used to generate the image.",
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: "The timings of the different steps in the workflow.",
  }),
});

/**
 * Input
 */
export const zClarityUpscalerInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The prompt to use for generating the image. Be as descriptive as possible for best results.",
      }),
    )
    .default("masterpiece, best quality, highres"),
  resemblance: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            The resemblance of the upscaled image to the original image. The higher the resemblance, the more the model will try to keep the original image.\n            Refers to the strength of the ControlNet.\n        ",
      }),
    )
    .default(0.6),
  creativity: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "\n            The creativity of the model. The higher the creativity, the more the model will deviate from the prompt.\n            Refers to the denoise strength of the sampling.\n        ",
      }),
    )
    .default(0.35),
  image_url: z.union([z.string(), z.string()]),
  upscale_factor: z
    .optional(
      z.number().gte(1).lte(4).register(z.globalRegistry, {
        description: "The upscale factor",
      }),
    )
    .default(2),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(4),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(18),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The negative prompt to use. Use it to address details that you don't want in the image.",
      }),
    )
    .default("(worst quality, low quality, normal quality:2)"),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to false, the safety checker will be disabled.",
      }),
    )
    .default(true),
});

/**
 * Output
 */
export const zAuraSrOutput = z.object({
  image: zImage,
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: "Timings for each step in the pipeline.",
  }),
});

/**
 * Input
 */
export const zAuraSrInput = z.object({
  overlapping_tiles: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to use overlapping tiles for upscaling. Setting this to true helps remove seams but doubles the inference time.",
      }),
    )
    .default(false),
  checkpoint: z.optional(
    z.enum(["v1", "v2"]).register(z.globalRegistry, {
      description: "Checkpoint to use for upscaling. More coming soon.",
    }),
  ),
  upscaling_factor: z.optional(
    z.literal(4).register(z.globalRegistry, {
      description: "Upscaling factor. More coming soon.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
});

/**
 * Output
 */
export const zFluxDevImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageType2).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * BaseImageToInput
 */
export const zFluxDevImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description:
        "The speed of the generation. The higher the speed, the faster the generation.",
    }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "The strength of the initial image. Higher strength values are better for this model.",
      }),
    )
    .default(0.95),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ",
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(40),
});

/**
 * Flux2ProEditOutput
 */
export const zFlux2ProEditOutput = z.object({
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The generated images.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The seed used for the generation.",
  }),
});

/**
 * Flux2ProImageEditInput
 */
export const zFlux2ProEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "auto",
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enable the safety checker.",
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The seed to use for the generation.",
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: "List of URLs of input images for editing",
  }),
});

/**
 * Flux2EditImageOutput
 */
export const zFlux2EditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * Flux2EditImageInput
 */
export const zFlux2EditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to edit the image.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use for the image generation.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(2.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The seed to use for the generation. If not provided, a random seed will be used.",
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "The URLs of the images for editing. A maximum of 4 images are allowed, if more are provided, only the first 4 will be used.",
  }),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded for better results.",
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
});

/**
 * Flux2EditImageLoRAOutput
 */
export const zFlux2LoraEditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zImageFile).register(z.globalRegistry, {
    description: "The edited images",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  timings: z.record(z.string(), z.number()),
});

/**
 * Flux2EditImageLoRAInput
 */
export const zFlux2LoraEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        "square_hd",
        "square",
        "portrait_4_3",
        "portrait_16_9",
        "landscape_4_3",
        "landscape_16_9",
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(["none", "regular", "high"]).register(z.globalRegistry, {
      description: "The acceleration level to use for the image generation.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "If set to true, the safety checker will be enabled.",
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(["jpeg", "png", "webp"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoRaInput).register(z.globalRegistry, {
        description:
          "List of LoRA weights to apply (maximum 3). Each LoRA can be a URL, HuggingFace repo ID, or local path.",
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          "Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.",
      }),
    )
    .default(2.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "The seed to use for the generation. If not provided, a random seed will be used.",
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "The URsL of the images for editing. A maximum of 3 images are allowed, if more are provided, only the first 3 will be used.",
  }),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set to true, the prompt will be expanded for better results.",
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: "The number of inference steps to perform.",
      }),
    )
    .default(28),
});

/**
 * FluxKontextOutput
 */
export const zFluxProKontextOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt used for generating the image.",
  }),
  images: z.array(zFalToolkitImageImageImage).register(z.globalRegistry, {
    description: "The generated image files info.",
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: "Whether the generated images contain NSFW concepts.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      "\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ",
  }),
});

/**
 * FluxKontextInput
 */
export const zFluxProKontextInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate an image from.",
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: "The number of images to generate.",
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z
      .enum(["21:9", "16:9", "4:3", "3:2", "1:1", "2:3", "3:4", "9:16", "9:21"])
      .register(z.globalRegistry, {
        description: "The aspect ratio of the generated image.",
      }),
  ),
  output_format: z.optional(
    z.enum(["jpeg", "png"]).register(z.globalRegistry, {
      description: "The format of the generated image.",
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(["1", "2", "3", "4", "5", "6"]).register(z.globalRegistry, {
      description:
        "The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          "\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ",
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ",
    }),
  ),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to enhance the prompt for better results.",
      }),
    )
    .default(false),
});

export const zQueueStatus = z.object({
  status: z.enum(["IN_QUEUE", "IN_PROGRESS", "COMPLETED"]),
  request_id: z.string().register(z.globalRegistry, {
    description: "The request id.",
  }),
  response_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The response url.",
    }),
  ),
  status_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The status url.",
    }),
  ),
  cancel_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The cancel url.",
    }),
  ),
  logs: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: "The logs.",
    }),
  ),
  metrics: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: "The metrics.",
    }),
  ),
  queue_position: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The queue position.",
    }),
  ),
});

export const zGetFalAiFluxProKontextRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxProKontextRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxProKontextRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProKontextRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxProKontextData = z.object({
  body: zFluxProKontextInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxProKontextResponse = zQueueStatus;

export const zGetFalAiFluxProKontextRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxProKontextRequestsByRequestIdResponse =
  zFluxProKontextOutput;

export const zGetFalAiFlux2LoraEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2LoraEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2LoraEditData = z.object({
  body: zFlux2LoraEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraEditResponse = zQueueStatus;

export const zGetFalAiFlux2LoraEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraEditRequestsByRequestIdResponse =
  zFlux2LoraEditOutput;

export const zGetFalAiFlux2EditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux2EditRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiFlux2EditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2EditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2EditData = z.object({
  body: zFlux2EditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2EditResponse = zQueueStatus;

export const zGetFalAiFlux2EditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2EditRequestsByRequestIdResponse = zFlux2EditOutput;

export const zGetFalAiFlux2ProEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux2ProEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2ProEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2ProEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2ProEditData = z.object({
  body: zFlux2ProEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2ProEditResponse = zQueueStatus;

export const zGetFalAiFlux2ProEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2ProEditRequestsByRequestIdResponse =
  zFlux2ProEditOutput;

export const zGetFalAiFluxDevImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxDevImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxDevImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxDevImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxDevImageToImageData = z.object({
  body: zFluxDevImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxDevImageToImageResponse = zQueueStatus;

export const zGetFalAiFluxDevImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxDevImageToImageRequestsByRequestIdResponse =
  zFluxDevImageToImageOutput;

export const zGetFalAiAuraSrRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiAuraSrRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiAuraSrRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiAuraSrRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiAuraSrData = z.object({
  body: zAuraSrInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiAuraSrResponse = zQueueStatus;

export const zGetFalAiAuraSrRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiAuraSrRequestsByRequestIdResponse = zAuraSrOutput;

export const zGetFalAiClarityUpscalerRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiClarityUpscalerRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiClarityUpscalerRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiClarityUpscalerRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiClarityUpscalerData = z.object({
  body: zClarityUpscalerInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiClarityUpscalerResponse = zQueueStatus;

export const zGetFalAiClarityUpscalerRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiClarityUpscalerRequestsByRequestIdResponse =
  zClarityUpscalerOutput;

export const zGetXaiGrokImagineImageEditRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetXaiGrokImagineImageEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutXaiGrokImagineImageEditRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutXaiGrokImagineImageEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostXaiGrokImagineImageEditData = z.object({
  body: zGrokImagineImageEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostXaiGrokImagineImageEditResponse = zQueueStatus;

export const zGetXaiGrokImagineImageEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetXaiGrokImagineImageEditRequestsByRequestIdResponse =
  zGrokImagineImageEditOutput;

export const zGetFalAiHunyuanImageV3InstructEditRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiHunyuanImageV3InstructEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuanImageV3InstructEditRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuanImageV3InstructEditRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiHunyuanImageV3InstructEditData = z.object({
  body: zHunyuanImageV3InstructEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuanImageV3InstructEditResponse = zQueueStatus;

export const zGetFalAiHunyuanImageV3InstructEditRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiHunyuanImageV3InstructEditRequestsByRequestIdResponse =
  zHunyuanImageV3InstructEditOutput;

export const zGetFalAiQwenImageMaxEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiQwenImageMaxEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageMaxEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageMaxEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiQwenImageMaxEditData = z.object({
  body: zQwenImageMaxEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageMaxEditResponse = zQueueStatus;

export const zGetFalAiQwenImageMaxEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageMaxEditRequestsByRequestIdResponse =
  zQwenImageMaxEditOutput;

export const zGetBriaReplaceBackgroundRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetBriaReplaceBackgroundRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutBriaReplaceBackgroundRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutBriaReplaceBackgroundRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostBriaReplaceBackgroundData = z.object({
  body: zReplaceBackgroundInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostBriaReplaceBackgroundResponse = zQueueStatus;

export const zGetBriaReplaceBackgroundRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetBriaReplaceBackgroundRequestsByRequestIdResponse =
  zReplaceBackgroundOutput;

export const zGetHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostHalfMoonAiAiFaceSwapFaceswapimageData = z.object({
  body: zAiFaceSwapFaceswapimageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostHalfMoonAiAiFaceSwapFaceswapimageResponse = zQueueStatus;

export const zGetHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdResponse =
  zAiFaceSwapFaceswapimageOutput;

export const zGetBriaFiboEditReplaceObjectByTextRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetBriaFiboEditReplaceObjectByTextRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutBriaFiboEditReplaceObjectByTextRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditReplaceObjectByTextRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostBriaFiboEditReplaceObjectByTextData = z.object({
  body: zFiboEditReplaceObjectByTextInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostBriaFiboEditReplaceObjectByTextResponse = zQueueStatus;

export const zGetBriaFiboEditReplaceObjectByTextRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetBriaFiboEditReplaceObjectByTextRequestsByRequestIdResponse =
  zFiboEditReplaceObjectByTextOutput;

export const zGetBriaFiboEditSketchToColoredImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetBriaFiboEditSketchToColoredImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutBriaFiboEditSketchToColoredImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditSketchToColoredImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostBriaFiboEditSketchToColoredImageData = z.object({
  body: zFiboEditSketchToColoredImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostBriaFiboEditSketchToColoredImageResponse = zQueueStatus;

export const zGetBriaFiboEditSketchToColoredImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetBriaFiboEditSketchToColoredImageRequestsByRequestIdResponse =
  zFiboEditSketchToColoredImageOutput;

export const zGetBriaFiboEditRestoreRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetBriaFiboEditRestoreRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutBriaFiboEditRestoreRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditRestoreRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostBriaFiboEditRestoreData = z.object({
  body: zFiboEditRestoreInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostBriaFiboEditRestoreResponse = zQueueStatus;

export const zGetBriaFiboEditRestoreRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetBriaFiboEditRestoreRequestsByRequestIdResponse =
  zFiboEditRestoreOutput;

export const zGetBriaFiboEditReseasonRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetBriaFiboEditReseasonRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutBriaFiboEditReseasonRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditReseasonRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostBriaFiboEditReseasonData = z.object({
  body: zFiboEditReseasonInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostBriaFiboEditReseasonResponse = zQueueStatus;

export const zGetBriaFiboEditReseasonRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetBriaFiboEditReseasonRequestsByRequestIdResponse =
  zFiboEditReseasonOutput;

export const zGetBriaFiboEditRelightRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetBriaFiboEditRelightRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutBriaFiboEditRelightRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditRelightRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostBriaFiboEditRelightData = z.object({
  body: zFiboEditRelightInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostBriaFiboEditRelightResponse = zQueueStatus;

export const zGetBriaFiboEditRelightRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetBriaFiboEditRelightRequestsByRequestIdResponse =
  zFiboEditRelightOutput;

export const zGetBriaFiboEditRestyleRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetBriaFiboEditRestyleRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutBriaFiboEditRestyleRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditRestyleRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostBriaFiboEditRestyleData = z.object({
  body: zFiboEditRestyleInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostBriaFiboEditRestyleResponse = zQueueStatus;

export const zGetBriaFiboEditRestyleRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetBriaFiboEditRestyleRequestsByRequestIdResponse =
  zFiboEditRestyleOutput;

export const zGetBriaFiboEditRewriteTextRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetBriaFiboEditRewriteTextRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutBriaFiboEditRewriteTextRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditRewriteTextRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostBriaFiboEditRewriteTextData = z.object({
  body: zFiboEditRewriteTextInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostBriaFiboEditRewriteTextResponse = zQueueStatus;

export const zGetBriaFiboEditRewriteTextRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetBriaFiboEditRewriteTextRequestsByRequestIdResponse =
  zFiboEditRewriteTextOutput;

export const zGetBriaFiboEditEraseByTextRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetBriaFiboEditEraseByTextRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutBriaFiboEditEraseByTextRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditEraseByTextRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostBriaFiboEditEraseByTextData = z.object({
  body: zFiboEditEraseByTextInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostBriaFiboEditEraseByTextResponse = zQueueStatus;

export const zGetBriaFiboEditEraseByTextRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetBriaFiboEditEraseByTextRequestsByRequestIdResponse =
  zFiboEditEraseByTextOutput;

export const zGetBriaFiboEditEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetBriaFiboEditEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutBriaFiboEditEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostBriaFiboEditEditData = z.object({
  body: zFiboEditEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostBriaFiboEditEditResponse = zQueueStatus;

export const zGetBriaFiboEditEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetBriaFiboEditEditRequestsByRequestIdResponse =
  zFiboEditEditOutput;

export const zGetBriaFiboEditAddObjectByTextRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetBriaFiboEditAddObjectByTextRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutBriaFiboEditAddObjectByTextRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditAddObjectByTextRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostBriaFiboEditAddObjectByTextData = z.object({
  body: zFiboEditAddObjectByTextInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostBriaFiboEditAddObjectByTextResponse = zQueueStatus;

export const zGetBriaFiboEditAddObjectByTextRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetBriaFiboEditAddObjectByTextRequestsByRequestIdResponse =
  zFiboEditAddObjectByTextOutput;

export const zGetBriaFiboEditBlendRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetBriaFiboEditBlendRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutBriaFiboEditBlendRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditBlendRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostBriaFiboEditBlendData = z.object({
  body: zFiboEditBlendInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostBriaFiboEditBlendResponse = zQueueStatus;

export const zGetBriaFiboEditBlendRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetBriaFiboEditBlendRequestsByRequestIdResponse =
  zFiboEditBlendOutput;

export const zGetBriaFiboEditColorizeRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetBriaFiboEditColorizeRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutBriaFiboEditColorizeRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditColorizeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostBriaFiboEditColorizeData = z.object({
  body: zFiboEditColorizeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostBriaFiboEditColorizeResponse = zQueueStatus;

export const zGetBriaFiboEditColorizeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetBriaFiboEditColorizeRequestsByRequestIdResponse =
  zFiboEditColorizeOutput;

export const zGetFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFlux2Klein9bBaseEditLoraData = z.object({
  body: zFlux2Klein9bBaseEditLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein9bBaseEditLoraResponse = zQueueStatus;

export const zGetFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdResponse =
  zFlux2Klein9bBaseEditLoraOutput;

export const zGetFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFlux2Klein4bBaseEditLoraData = z.object({
  body: zFlux2Klein4bBaseEditLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein4bBaseEditLoraResponse = zQueueStatus;

export const zGetFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdResponse =
  zFlux2Klein4bBaseEditLoraOutput;

export const zGetFalAiFlux2Klein4bBaseEditRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein4bBaseEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2Klein4bBaseEditRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein4bBaseEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2Klein4bBaseEditData = z.object({
  body: zFlux2Klein4bBaseEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein4bBaseEditResponse = zQueueStatus;

export const zGetFalAiFlux2Klein4bBaseEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein4bBaseEditRequestsByRequestIdResponse =
  zFlux2Klein4bBaseEditOutput;

export const zGetFalAiFlux2Klein9bBaseEditRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein9bBaseEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2Klein9bBaseEditRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein9bBaseEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2Klein9bBaseEditData = z.object({
  body: zFlux2Klein9bBaseEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein9bBaseEditResponse = zQueueStatus;

export const zGetFalAiFlux2Klein9bBaseEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein9bBaseEditRequestsByRequestIdResponse =
  zFlux2Klein9bBaseEditOutput;

export const zGetFalAiFlux2Klein4bEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein4bEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2Klein4bEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein4bEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2Klein4bEditData = z.object({
  body: zFlux2Klein4bEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein4bEditResponse = zQueueStatus;

export const zGetFalAiFlux2Klein4bEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein4bEditRequestsByRequestIdResponse =
  zFlux2Klein4bEditOutput;

export const zGetFalAiFlux2Klein9bEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein9bEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2Klein9bEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein9bEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2Klein9bEditData = z.object({
  body: zFlux2Klein9bEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein9bEditResponse = zQueueStatus;

export const zGetFalAiFlux2Klein9bEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein9bEditRequestsByRequestIdResponse =
  zFlux2Klein9bEditOutput;

export const zGetFalAiGlmImageImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiGlmImageImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiGlmImageImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiGlmImageImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiGlmImageImageToImageData = z.object({
  body: zGlmImageImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiGlmImageImageToImageResponse = zQueueStatus;

export const zGetFalAiGlmImageImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiGlmImageImageToImageRequestsByRequestIdResponse =
  zGlmImageImageToImageOutput;

export const zGetFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageEdit2511MultipleAnglesData = z.object({
  body: zQwenImageEdit2511MultipleAnglesInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2511MultipleAnglesResponse = zQueueStatus;

export const zGetFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdResponse =
  zQwenImageEdit2511MultipleAnglesOutput;

export const zGetFalAiQwenImageEdit2511LoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2511LoraRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEdit2511LoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2511LoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiQwenImageEdit2511LoraData = z.object({
  body: zQwenImageEdit2511LoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2511LoraResponse = zQueueStatus;

export const zGetFalAiQwenImageEdit2511LoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2511LoraRequestsByRequestIdResponse =
  zQwenImageEdit2511LoraOutput;

export const zGetHalfMoonAiAiHomeStyleRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetHalfMoonAiAiHomeStyleRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutHalfMoonAiAiHomeStyleRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutHalfMoonAiAiHomeStyleRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostHalfMoonAiAiHomeStyleData = z.object({
  body: zAiHomeStyleInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostHalfMoonAiAiHomeStyleResponse = zQueueStatus;

export const zGetHalfMoonAiAiHomeStyleRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetHalfMoonAiAiHomeStyleRequestsByRequestIdResponse =
  zAiHomeStyleOutput;

export const zGetHalfMoonAiAiHomeEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetHalfMoonAiAiHomeEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutHalfMoonAiAiHomeEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutHalfMoonAiAiHomeEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostHalfMoonAiAiHomeEditData = z.object({
  body: zAiHomeEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostHalfMoonAiAiHomeEditResponse = zQueueStatus;

export const zGetHalfMoonAiAiHomeEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetHalfMoonAiAiHomeEditRequestsByRequestIdResponse =
  zAiHomeEditOutput;

export const zGetFalAiQwenImageLayeredLoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageLayeredLoraRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageLayeredLoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageLayeredLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiQwenImageLayeredLoraData = z.object({
  body: zQwenImageLayeredLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageLayeredLoraResponse = zQueueStatus;

export const zGetFalAiQwenImageLayeredLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageLayeredLoraRequestsByRequestIdResponse =
  zQwenImageLayeredLoraOutput;

export const zGetWanV26ImageToImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetWanV26ImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutWanV26ImageToImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutWanV26ImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostWanV26ImageToImageData = z.object({
  body: zV26ImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostWanV26ImageToImageResponse = zQueueStatus;

export const zGetWanV26ImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetWanV26ImageToImageRequestsByRequestIdResponse =
  zV26ImageToImageOutput;

export const zGetFalAiQwenImageEdit2511RequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2511RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEdit2511RequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2511RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiQwenImageEdit2511Data = z.object({
  body: zQwenImageEdit2511Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2511Response = zQueueStatus;

export const zGetFalAiQwenImageEdit2511RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2511RequestsByRequestIdResponse =
  zQwenImageEdit2511Output;

export const zGetFalAiQwenImageLayeredRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiQwenImageLayeredRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageLayeredRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageLayeredRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiQwenImageLayeredData = z.object({
  body: zQwenImageLayeredInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageLayeredResponse = zQueueStatus;

export const zGetFalAiQwenImageLayeredRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageLayeredRequestsByRequestIdResponse =
  zQwenImageLayeredOutput;

export const zGetFalAiZImageTurboInpaintLoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiZImageTurboInpaintLoraRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiZImageTurboInpaintLoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiZImageTurboInpaintLoraRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiZImageTurboInpaintLoraData = z.object({
  body: zZImageTurboInpaintLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiZImageTurboInpaintLoraResponse = zQueueStatus;

export const zGetFalAiZImageTurboInpaintLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiZImageTurboInpaintLoraRequestsByRequestIdResponse =
  zZImageTurboInpaintLoraOutput;

export const zGetFalAiZImageTurboInpaintRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiZImageTurboInpaintRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiZImageTurboInpaintRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiZImageTurboInpaintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiZImageTurboInpaintData = z.object({
  body: zZImageTurboInpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiZImageTurboInpaintResponse = zQueueStatus;

export const zGetFalAiZImageTurboInpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiZImageTurboInpaintRequestsByRequestIdResponse =
  zZImageTurboInpaintOutput;

export const zGetFalAiFlux2FlashEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux2FlashEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2FlashEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2FlashEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2FlashEditData = z.object({
  body: zFlux2FlashEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2FlashEditResponse = zQueueStatus;

export const zGetFalAiFlux2FlashEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2FlashEditRequestsByRequestIdResponse =
  zFlux2FlashEditOutput;

export const zGetFalAiGptImage15EditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiGptImage15EditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiGptImage15EditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiGptImage15EditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiGptImage15EditData = z.object({
  body: zGptImage15EditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiGptImage15EditResponse = zQueueStatus;

export const zGetFalAiGptImage15EditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiGptImage15EditRequestsByRequestIdResponse =
  zGptImage15EditOutput;

export const zGetFalAiFlux2TurboEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux2TurboEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2TurboEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2TurboEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2TurboEditData = z.object({
  body: zFlux2TurboEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2TurboEditResponse = zQueueStatus;

export const zGetFalAiFlux2TurboEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2TurboEditRequestsByRequestIdResponse =
  zFlux2TurboEditOutput;

export const zGetFalAiFlux2MaxEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux2MaxEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2MaxEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2MaxEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2MaxEditData = z.object({
  body: zFlux2MaxEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2MaxEditResponse = zQueueStatus;

export const zGetFalAiFlux2MaxEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2MaxEditRequestsByRequestIdResponse =
  zFlux2MaxEditOutput;

export const zGetHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostHalfMoonAiAiBabyAndAgingGeneratorMultiData = z.object({
  body: zAiBabyAndAgingGeneratorMultiInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostHalfMoonAiAiBabyAndAgingGeneratorMultiResponse = zQueueStatus;

export const zGetHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdResponse =
  zAiBabyAndAgingGeneratorMultiOutput;

export const zGetHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostHalfMoonAiAiBabyAndAgingGeneratorSingleData = z.object({
  body: zAiBabyAndAgingGeneratorSingleInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostHalfMoonAiAiBabyAndAgingGeneratorSingleResponse =
  zQueueStatus;

export const zGetHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdResponse =
  zAiBabyAndAgingGeneratorSingleOutput;

export const zGetFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageEdit2509LoraGalleryShirtDesignData = z.object({
  body: zQwenImageEdit2509LoraGalleryShirtDesignInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509LoraGalleryShirtDesignResponse =
  zQueueStatus;

export const zGetFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdResponse =
  zQwenImageEdit2509LoraGalleryShirtDesignOutput;

export const zGetFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageEdit2509LoraGalleryRemoveLightingData =
  z.object({
    body: zQwenImageEdit2509LoraGalleryRemoveLightingInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  });

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509LoraGalleryRemoveLightingResponse =
  zQueueStatus;

export const zGetFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdResponse =
  zQwenImageEdit2509LoraGalleryRemoveLightingOutput;

export const zGetFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageEdit2509LoraGalleryRemoveElementData = z.object(
  {
    body: zQwenImageEdit2509LoraGalleryRemoveElementInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  },
);

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509LoraGalleryRemoveElementResponse =
  zQueueStatus;

export const zGetFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdResponse =
  zQwenImageEdit2509LoraGalleryRemoveElementOutput;

export const zGetFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageEdit2509LoraGalleryLightingRestorationData =
  z.object({
    body: zQwenImageEdit2509LoraGalleryLightingRestorationInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  });

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509LoraGalleryLightingRestorationResponse =
  zQueueStatus;

export const zGetFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdResponse =
  zQwenImageEdit2509LoraGalleryLightingRestorationOutput;

export const zGetFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageEdit2509LoraGalleryIntegrateProductData =
  z.object({
    body: zQwenImageEdit2509LoraGalleryIntegrateProductInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  });

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509LoraGalleryIntegrateProductResponse =
  zQueueStatus;

export const zGetFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdResponse =
  zQwenImageEdit2509LoraGalleryIntegrateProductOutput;

export const zGetFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageEdit2509LoraGalleryGroupPhotoData = z.object({
  body: zQwenImageEdit2509LoraGalleryGroupPhotoInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509LoraGalleryGroupPhotoResponse =
  zQueueStatus;

export const zGetFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdResponse =
  zQwenImageEdit2509LoraGalleryGroupPhotoOutput;

export const zGetFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitData =
  z.object({
    body: zQwenImageEdit2509LoraGalleryFaceToFullPortraitInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  });

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitResponse =
  zQueueStatus;

export const zGetFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdResponse =
  zQwenImageEdit2509LoraGalleryFaceToFullPortraitOutput;

export const zGetFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageEdit2509LoraGalleryAddBackgroundData = z.object(
  {
    body: zQwenImageEdit2509LoraGalleryAddBackgroundInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  },
);

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509LoraGalleryAddBackgroundResponse =
  zQueueStatus;

export const zGetFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdResponse =
  zQwenImageEdit2509LoraGalleryAddBackgroundOutput;

export const zGetFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageEdit2509LoraGalleryNextSceneData = z.object({
  body: zQwenImageEdit2509LoraGalleryNextSceneInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509LoraGalleryNextSceneResponse =
  zQueueStatus;

export const zGetFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdResponse =
  zQwenImageEdit2509LoraGalleryNextSceneOutput;

export const zGetFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageEdit2509LoraGalleryMultipleAnglesData =
  z.object({
    body: zQwenImageEdit2509LoraGalleryMultipleAnglesInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  });

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509LoraGalleryMultipleAnglesResponse =
  zQueueStatus;

export const zGetFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdResponse =
  zQwenImageEdit2509LoraGalleryMultipleAnglesOutput;

export const zGetFalAiQwenImageEdit2509LoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509LoraRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEdit2509LoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509LoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiQwenImageEdit2509LoraData = z.object({
  body: zQwenImageEdit2509LoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509LoraResponse = zQueueStatus;

export const zGetFalAiQwenImageEdit2509LoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509LoraRequestsByRequestIdResponse =
  zQwenImageEdit2509LoraOutput;

export const zGetFalAiQwenImageEdit2509RequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEdit2509RequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiQwenImageEdit2509Data = z.object({
  body: zQwenImageEdit2509Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509Response = zQueueStatus;

export const zGetFalAiQwenImageEdit2509RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509RequestsByRequestIdResponse =
  zQwenImageEdit2509Output;

export const zGetFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageEditPlusLoraGalleryLightingRestorationData =
  z.object({
    body: zQwenImageEditPlusLoraGalleryLightingRestorationInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  });

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusLoraGalleryLightingRestorationResponse =
  zQueueStatus;

export const zGetFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdResponse =
  zQwenImageEditPlusLoraGalleryLightingRestorationOutput;

export const zGetFalAiMoondream3PreviewSegmentRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiMoondream3PreviewSegmentRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiMoondream3PreviewSegmentRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiMoondream3PreviewSegmentRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiMoondream3PreviewSegmentData = z.object({
  body: zMoondream3PreviewSegmentInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiMoondream3PreviewSegmentResponse = zQueueStatus;

export const zGetFalAiMoondream3PreviewSegmentRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiMoondream3PreviewSegmentRequestsByRequestIdResponse =
  zMoondream3PreviewSegmentOutput;

export const zGetFalAiStepxEdit2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiStepxEdit2RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiStepxEdit2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiStepxEdit2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiStepxEdit2Data = z.object({
  body: zStepxEdit2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiStepxEdit2Response = zQueueStatus;

export const zGetFalAiStepxEdit2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiStepxEdit2RequestsByRequestIdResponse = zStepxEdit2Output;

export const zGetFalAiZImageTurboControlnetLoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiZImageTurboControlnetLoraRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiZImageTurboControlnetLoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiZImageTurboControlnetLoraRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiZImageTurboControlnetLoraData = z.object({
  body: zZImageTurboControlnetLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiZImageTurboControlnetLoraResponse = zQueueStatus;

export const zGetFalAiZImageTurboControlnetLoraRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiZImageTurboControlnetLoraRequestsByRequestIdResponse =
  zZImageTurboControlnetLoraOutput;

export const zGetFalAiZImageTurboControlnetRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiZImageTurboControlnetRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiZImageTurboControlnetRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiZImageTurboControlnetRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiZImageTurboControlnetData = z.object({
  body: zZImageTurboControlnetInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiZImageTurboControlnetResponse = zQueueStatus;

export const zGetFalAiZImageTurboControlnetRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiZImageTurboControlnetRequestsByRequestIdResponse =
  zZImageTurboControlnetOutput;

export const zGetFalAiZImageTurboImageToImageLoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiZImageTurboImageToImageLoraRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiZImageTurboImageToImageLoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiZImageTurboImageToImageLoraRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiZImageTurboImageToImageLoraData = z.object({
  body: zZImageTurboImageToImageLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiZImageTurboImageToImageLoraResponse = zQueueStatus;

export const zGetFalAiZImageTurboImageToImageLoraRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiZImageTurboImageToImageLoraRequestsByRequestIdResponse =
  zZImageTurboImageToImageLoraOutput;

export const zGetFalAiZImageTurboImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiZImageTurboImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiZImageTurboImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiZImageTurboImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiZImageTurboImageToImageData = z.object({
  body: zZImageTurboImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiZImageTurboImageToImageResponse = zQueueStatus;

export const zGetFalAiZImageTurboImageToImageRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * Result of the request.
 */
export const zGetFalAiZImageTurboImageToImageRequestsByRequestIdResponse =
  zZImageTurboImageToImageOutput;

export const zGetFalAiLongcatImageEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiLongcatImageEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiLongcatImageEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiLongcatImageEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiLongcatImageEditData = z.object({
  body: zLongcatImageEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiLongcatImageEditResponse = zQueueStatus;

export const zGetFalAiLongcatImageEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiLongcatImageEditRequestsByRequestIdResponse =
  zLongcatImageEditOutput;

export const zGetFalAiBytedanceSeedreamV45EditRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiBytedanceSeedreamV45EditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiBytedanceSeedreamV45EditRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiBytedanceSeedreamV45EditRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiBytedanceSeedreamV45EditData = z.object({
  body: zBytedanceSeedreamV45EditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiBytedanceSeedreamV45EditResponse = zQueueStatus;

export const zGetFalAiBytedanceSeedreamV45EditRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiBytedanceSeedreamV45EditRequestsByRequestIdResponse =
  zBytedanceSeedreamV45EditOutput;

export const zGetFalAiViduQ2ReferenceToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiViduQ2ReferenceToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiViduQ2ReferenceToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiViduQ2ReferenceToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiViduQ2ReferenceToImageData = z.object({
  body: zViduQ2ReferenceToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiViduQ2ReferenceToImageResponse = zQueueStatus;

export const zGetFalAiViduQ2ReferenceToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiViduQ2ReferenceToImageRequestsByRequestIdResponse =
  zViduQ2ReferenceToImageOutput;

export const zGetFalAiKlingImageO1RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiKlingImageO1RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiKlingImageO1RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiKlingImageO1RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiKlingImageO1Data = z.object({
  body: zKlingImageO1Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiKlingImageO1Response = zQueueStatus;

export const zGetFalAiKlingImageO1RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiKlingImageO1RequestsByRequestIdResponse =
  zKlingImageO1Output;

export const zGetFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFlux2LoraGalleryVirtualTryonData = z.object({
  body: zFlux2LoraGalleryVirtualTryonInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraGalleryVirtualTryonResponse = zQueueStatus;

export const zGetFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdResponse =
  zFlux2LoraGalleryVirtualTryonOutput;

export const zGetFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFlux2LoraGalleryMultipleAnglesData = z.object({
  body: zFlux2LoraGalleryMultipleAnglesInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraGalleryMultipleAnglesResponse = zQueueStatus;

export const zGetFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdResponse =
  zFlux2LoraGalleryMultipleAnglesOutput;

export const zGetFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFlux2LoraGalleryFaceToFullPortraitData = z.object({
  body: zFlux2LoraGalleryFaceToFullPortraitInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraGalleryFaceToFullPortraitResponse =
  zQueueStatus;

export const zGetFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdResponse =
  zFlux2LoraGalleryFaceToFullPortraitOutput;

export const zGetFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFlux2LoraGalleryApartmentStagingData = z.object({
  body: zFlux2LoraGalleryApartmentStagingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraGalleryApartmentStagingResponse = zQueueStatus;

export const zGetFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdResponse =
  zFlux2LoraGalleryApartmentStagingOutput;

export const zGetFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFlux2LoraGalleryAddBackgroundData = z.object({
  body: zFlux2LoraGalleryAddBackgroundInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraGalleryAddBackgroundResponse = zQueueStatus;

export const zGetFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdResponse =
  zFlux2LoraGalleryAddBackgroundOutput;

export const zGetClarityaiCrystalUpscalerRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetClarityaiCrystalUpscalerRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutClarityaiCrystalUpscalerRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutClarityaiCrystalUpscalerRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostClarityaiCrystalUpscalerData = z.object({
  body: zCrystalUpscalerInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostClarityaiCrystalUpscalerResponse = zQueueStatus;

export const zGetClarityaiCrystalUpscalerRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetClarityaiCrystalUpscalerRequestsByRequestIdResponse =
  zCrystalUpscalerOutput;

export const zGetFalAiFlux2FlexEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux2FlexEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2FlexEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2FlexEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2FlexEditData = z.object({
  body: zFlux2FlexEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2FlexEditResponse = zQueueStatus;

export const zGetFalAiFlux2FlexEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2FlexEditRequestsByRequestIdResponse =
  zFlux2FlexEditOutput;

export const zGetFalAiChronoEditLoraRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiChronoEditLoraRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiChronoEditLoraRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiChronoEditLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiChronoEditLoraData = z.object({
  body: zChronoEditLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiChronoEditLoraResponse = zQueueStatus;

export const zGetFalAiChronoEditLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiChronoEditLoraRequestsByRequestIdResponse =
  zChronoEditLoraOutput;

export const zGetFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiChronoEditLoraGalleryPaintbrushData = z.object({
  body: zChronoEditLoraGalleryPaintbrushInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiChronoEditLoraGalleryPaintbrushResponse = zQueueStatus;

export const zGetFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdResponse =
  zChronoEditLoraGalleryPaintbrushOutput;

export const zGetFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiChronoEditLoraGalleryUpscalerData = z.object({
  body: zChronoEditLoraGalleryUpscalerInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiChronoEditLoraGalleryUpscalerResponse = zQueueStatus;

export const zGetFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdResponse =
  zChronoEditLoraGalleryUpscalerOutput;

export const zGetFalAiSam3ImageRleRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiSam3ImageRleRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiSam3ImageRleRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiSam3ImageRleRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiSam3ImageRleData = z.object({
  body: zSam3ImageRleInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiSam3ImageRleResponse = zQueueStatus;

export const zGetFalAiSam3ImageRleRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiSam3ImageRleRequestsByRequestIdResponse =
  zSam3ImageRleOutput;

export const zGetFalAiSam3ImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiSam3ImageRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiSam3ImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiSam3ImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiSam3ImageData = z.object({
  body: zSam3ImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiSam3ImageResponse = zQueueStatus;

export const zGetFalAiSam3ImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiSam3ImageRequestsByRequestIdResponse = zSam3ImageOutput;

export const zGetFalAiGemini3ProImagePreviewEditRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiGemini3ProImagePreviewEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiGemini3ProImagePreviewEditRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiGemini3ProImagePreviewEditRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiGemini3ProImagePreviewEditData = z.object({
  body: zGemini3ProImagePreviewEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiGemini3ProImagePreviewEditResponse = zQueueStatus;

export const zGetFalAiGemini3ProImagePreviewEditRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiGemini3ProImagePreviewEditRequestsByRequestIdResponse =
  zGemini3ProImagePreviewEditOutput;

export const zGetFalAiNanoBananaProEditRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiNanoBananaProEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiNanoBananaProEditRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiNanoBananaProEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiNanoBananaProEditData = z.object({
  body: zNanoBananaProEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiNanoBananaProEditResponse = zQueueStatus;

export const zGetFalAiNanoBananaProEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiNanoBananaProEditRequestsByRequestIdResponse =
  zNanoBananaProEditOutput;

export const zGetFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageEditPlusLoraGalleryMultipleAnglesData =
  z.object({
    body: zQwenImageEditPlusLoraGalleryMultipleAnglesInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  });

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusLoraGalleryMultipleAnglesResponse =
  zQueueStatus;

export const zGetFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdResponse =
  zQwenImageEditPlusLoraGalleryMultipleAnglesOutput;

export const zGetFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageEditPlusLoraGalleryShirtDesignData = z.object({
  body: zQwenImageEditPlusLoraGalleryShirtDesignInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusLoraGalleryShirtDesignResponse =
  zQueueStatus;

export const zGetFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdResponse =
  zQwenImageEditPlusLoraGalleryShirtDesignOutput;

export const zGetFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageEditPlusLoraGalleryRemoveLightingData =
  z.object({
    body: zQwenImageEditPlusLoraGalleryRemoveLightingInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  });

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusLoraGalleryRemoveLightingResponse =
  zQueueStatus;

export const zGetFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdResponse =
  zQwenImageEditPlusLoraGalleryRemoveLightingOutput;

export const zGetFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageEditPlusLoraGalleryRemoveElementData = z.object(
  {
    body: zQwenImageEditPlusLoraGalleryRemoveElementInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  },
);

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusLoraGalleryRemoveElementResponse =
  zQueueStatus;

export const zGetFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdResponse =
  zQwenImageEditPlusLoraGalleryRemoveElementOutput;

export const zGetFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageEditPlusLoraGalleryNextSceneData = z.object({
  body: zQwenImageEditPlusLoraGalleryNextSceneInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusLoraGalleryNextSceneResponse =
  zQueueStatus;

export const zGetFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdResponse =
  zQwenImageEditPlusLoraGalleryNextSceneOutput;

export const zGetFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageEditPlusLoraGalleryIntegrateProductData =
  z.object({
    body: zQwenImageEditPlusLoraGalleryIntegrateProductInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  });

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusLoraGalleryIntegrateProductResponse =
  zQueueStatus;

export const zGetFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdResponse =
  zQwenImageEditPlusLoraGalleryIntegrateProductOutput;

export const zGetFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageEditPlusLoraGalleryGroupPhotoData = z.object({
  body: zQwenImageEditPlusLoraGalleryGroupPhotoInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusLoraGalleryGroupPhotoResponse =
  zQueueStatus;

export const zGetFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdResponse =
  zQwenImageEditPlusLoraGalleryGroupPhotoOutput;

export const zGetFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitData =
  z.object({
    body: zQwenImageEditPlusLoraGalleryFaceToFullPortraitInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  });

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitResponse =
  zQueueStatus;

export const zGetFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdResponse =
  zQwenImageEditPlusLoraGalleryFaceToFullPortraitOutput;

export const zGetFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageEditPlusLoraGalleryAddBackgroundData = z.object(
  {
    body: zQwenImageEditPlusLoraGalleryAddBackgroundInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  },
);

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusLoraGalleryAddBackgroundResponse =
  zQueueStatus;

export const zGetFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdResponse =
  zQwenImageEditPlusLoraGalleryAddBackgroundOutput;

export const zGetFalAiReveFastRemixRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiReveFastRemixRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiReveFastRemixRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiReveFastRemixRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiReveFastRemixData = z.object({
  body: zReveFastRemixInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiReveFastRemixResponse = zQueueStatus;

export const zGetFalAiReveFastRemixRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiReveFastRemixRequestsByRequestIdResponse =
  zReveFastRemixOutput;

export const zGetFalAiReveFastEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiReveFastEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiReveFastEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiReveFastEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiReveFastEditData = z.object({
  body: zReveFastEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiReveFastEditResponse = zQueueStatus;

export const zGetFalAiReveFastEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiReveFastEditRequestsByRequestIdResponse =
  zReveFastEditOutput;

export const zGetFalAiImageAppsV2OutpaintRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2OutpaintRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageAppsV2OutpaintRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2OutpaintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiImageAppsV2OutpaintData = z.object({
  body: zImageAppsV2OutpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2OutpaintResponse = zQueueStatus;

export const zGetFalAiImageAppsV2OutpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2OutpaintRequestsByRequestIdResponse =
  zImageAppsV2OutpaintOutput;

export const zGetFalAiFluxVisionUpscalerRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxVisionUpscalerRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxVisionUpscalerRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxVisionUpscalerRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxVisionUpscalerData = z.object({
  body: zFluxVisionUpscalerInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxVisionUpscalerResponse = zQueueStatus;

export const zGetFalAiFluxVisionUpscalerRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxVisionUpscalerRequestsByRequestIdResponse =
  zFluxVisionUpscalerOutput;

export const zGetFalAiEmu35ImageEditImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiEmu35ImageEditImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiEmu35ImageEditImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiEmu35ImageEditImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiEmu35ImageEditImageData = z.object({
  body: zEmu35ImageEditImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiEmu35ImageEditImageResponse = zQueueStatus;

export const zGetFalAiEmu35ImageEditImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiEmu35ImageEditImageRequestsByRequestIdResponse =
  zEmu35ImageEditImageOutput;

export const zGetFalAiChronoEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiChronoEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiChronoEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiChronoEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiChronoEditData = z.object({
  body: zChronoEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiChronoEditResponse = zQueueStatus;

export const zGetFalAiChronoEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiChronoEditRequestsByRequestIdResponse = zChronoEditOutput;

export const zGetFalAiGptImage1MiniEditRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiGptImage1MiniEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiGptImage1MiniEditRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiGptImage1MiniEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiGptImage1MiniEditData = z.object({
  body: zGptImage1MiniEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiGptImage1MiniEditResponse = zQueueStatus;

export const zGetFalAiGptImage1MiniEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiGptImage1MiniEditRequestsByRequestIdResponse =
  zGptImage1MiniEditOutput;

export const zGetFalAiReveRemixRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiReveRemixRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiReveRemixRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiReveRemixRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiReveRemixData = z.object({
  body: zReveRemixInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiReveRemixResponse = zQueueStatus;

export const zGetFalAiReveRemixRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiReveRemixRequestsByRequestIdResponse = zReveRemixOutput;

export const zGetFalAiReveEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiReveEditRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiReveEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiReveEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiReveEditData = z.object({
  body: zReveEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiReveEditResponse = zQueueStatus;

export const zGetFalAiReveEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiReveEditRequestsByRequestIdResponse = zReveEditOutput;

export const zGetFalAiImage2PixelRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiImage2PixelRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImage2PixelRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiImage2PixelRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiImage2PixelData = z.object({
  body: zImage2PixelInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImage2PixelResponse = zQueueStatus;

export const zGetFalAiImage2PixelRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImage2PixelRequestsByRequestIdResponse =
  zImage2PixelOutput;

export const zGetFalAiDreamomni2EditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiDreamomni2EditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiDreamomni2EditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiDreamomni2EditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiDreamomni2EditData = z.object({
  body: zDreamomni2EditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiDreamomni2EditResponse = zQueueStatus;

export const zGetFalAiDreamomni2EditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiDreamomni2EditRequestsByRequestIdResponse =
  zDreamomni2EditOutput;

export const zGetFalAiQwenImageEditPlusLoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusLoraRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEditPlusLoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiQwenImageEditPlusLoraData = z.object({
  body: zQwenImageEditPlusLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusLoraResponse = zQueueStatus;

export const zGetFalAiQwenImageEditPlusLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusLoraRequestsByRequestIdResponse =
  zQwenImageEditPlusLoraOutput;

export const zGetFalAiLucidfluxRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiLucidfluxRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiLucidfluxRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiLucidfluxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiLucidfluxData = z.object({
  body: zLucidfluxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiLucidfluxResponse = zQueueStatus;

export const zGetFalAiLucidfluxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiLucidfluxRequestsByRequestIdResponse = zLucidfluxOutput;

export const zGetFalAiQwenImageEditImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEditImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageEditImageToImageData = z.object({
  body: zQwenImageEditImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditImageToImageResponse = zQueueStatus;

export const zGetFalAiQwenImageEditImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditImageToImageRequestsByRequestIdResponse =
  zQwenImageEditImageToImageOutput;

export const zGetFalAiWan25PreviewImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiWan25PreviewImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiWan25PreviewImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiWan25PreviewImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiWan25PreviewImageToImageData = z.object({
  body: zWan25PreviewImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiWan25PreviewImageToImageResponse = zQueueStatus;

export const zGetFalAiWan25PreviewImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiWan25PreviewImageToImageRequestsByRequestIdResponse =
  zWan25PreviewImageToImageOutput;

export const zGetFalAiQwenImageEditPlusRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEditPlusRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiQwenImageEditPlusData = z.object({
  body: zQwenImageEditPlusInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusResponse = zQueueStatus;

export const zGetFalAiQwenImageEditPlusRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusRequestsByRequestIdResponse =
  zQwenImageEditPlusOutput;

export const zGetFalAiSeedvrUpscaleImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiSeedvrUpscaleImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiSeedvrUpscaleImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiSeedvrUpscaleImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiSeedvrUpscaleImageData = z.object({
  body: zSeedvrUpscaleImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiSeedvrUpscaleImageResponse = zQueueStatus;

export const zGetFalAiSeedvrUpscaleImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiSeedvrUpscaleImageRequestsByRequestIdResponse =
  zSeedvrUpscaleImageOutput;

export const zGetFalAiImageAppsV2ProductHoldingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2ProductHoldingRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageAppsV2ProductHoldingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2ProductHoldingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageAppsV2ProductHoldingData = z.object({
  body: zImageAppsV2ProductHoldingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2ProductHoldingResponse = zQueueStatus;

export const zGetFalAiImageAppsV2ProductHoldingRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2ProductHoldingRequestsByRequestIdResponse =
  zImageAppsV2ProductHoldingOutput;

export const zGetFalAiImageAppsV2ProductPhotographyRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2ProductPhotographyRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageAppsV2ProductPhotographyRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2ProductPhotographyRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageAppsV2ProductPhotographyData = z.object({
  body: zImageAppsV2ProductPhotographyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2ProductPhotographyResponse = zQueueStatus;

export const zGetFalAiImageAppsV2ProductPhotographyRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2ProductPhotographyRequestsByRequestIdResponse =
  zImageAppsV2ProductPhotographyOutput;

export const zGetFalAiImageAppsV2VirtualTryOnRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2VirtualTryOnRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageAppsV2VirtualTryOnRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2VirtualTryOnRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageAppsV2VirtualTryOnData = z.object({
  body: zImageAppsV2VirtualTryOnInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2VirtualTryOnResponse = zQueueStatus;

export const zGetFalAiImageAppsV2VirtualTryOnRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2VirtualTryOnRequestsByRequestIdResponse =
  zImageAppsV2VirtualTryOnOutput;

export const zGetFalAiImageAppsV2TextureTransformRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2TextureTransformRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageAppsV2TextureTransformRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2TextureTransformRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageAppsV2TextureTransformData = z.object({
  body: zImageAppsV2TextureTransformInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2TextureTransformResponse = zQueueStatus;

export const zGetFalAiImageAppsV2TextureTransformRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2TextureTransformRequestsByRequestIdResponse =
  zImageAppsV2TextureTransformOutput;

export const zGetFalAiImageAppsV2RelightingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2RelightingRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageAppsV2RelightingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2RelightingRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiImageAppsV2RelightingData = z.object({
  body: zImageAppsV2RelightingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2RelightingResponse = zQueueStatus;

export const zGetFalAiImageAppsV2RelightingRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2RelightingRequestsByRequestIdResponse =
  zImageAppsV2RelightingOutput;

export const zGetFalAiImageAppsV2StyleTransferRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2StyleTransferRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageAppsV2StyleTransferRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2StyleTransferRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageAppsV2StyleTransferData = z.object({
  body: zImageAppsV2StyleTransferInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2StyleTransferResponse = zQueueStatus;

export const zGetFalAiImageAppsV2StyleTransferRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2StyleTransferRequestsByRequestIdResponse =
  zImageAppsV2StyleTransferOutput;

export const zGetFalAiImageAppsV2PhotoRestorationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2PhotoRestorationRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageAppsV2PhotoRestorationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2PhotoRestorationRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageAppsV2PhotoRestorationData = z.object({
  body: zImageAppsV2PhotoRestorationInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2PhotoRestorationResponse = zQueueStatus;

export const zGetFalAiImageAppsV2PhotoRestorationRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2PhotoRestorationRequestsByRequestIdResponse =
  zImageAppsV2PhotoRestorationOutput;

export const zGetFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageAppsV2PortraitEnhanceData = z.object({
  body: zImageAppsV2PortraitEnhanceInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2PortraitEnhanceResponse = zQueueStatus;

export const zGetFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdResponse =
  zImageAppsV2PortraitEnhanceOutput;

export const zGetFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageAppsV2PhotographyEffectsData = z.object({
  body: zImageAppsV2PhotographyEffectsInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2PhotographyEffectsResponse = zQueueStatus;

export const zGetFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdResponse =
  zImageAppsV2PhotographyEffectsOutput;

export const zGetFalAiImageAppsV2PerspectiveRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2PerspectiveRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageAppsV2PerspectiveRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2PerspectiveRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageAppsV2PerspectiveData = z.object({
  body: zImageAppsV2PerspectiveInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2PerspectiveResponse = zQueueStatus;

export const zGetFalAiImageAppsV2PerspectiveRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2PerspectiveRequestsByRequestIdResponse =
  zImageAppsV2PerspectiveOutput;

export const zGetFalAiImageAppsV2ObjectRemovalRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2ObjectRemovalRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageAppsV2ObjectRemovalRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2ObjectRemovalRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageAppsV2ObjectRemovalData = z.object({
  body: zImageAppsV2ObjectRemovalInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2ObjectRemovalResponse = zQueueStatus;

export const zGetFalAiImageAppsV2ObjectRemovalRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2ObjectRemovalRequestsByRequestIdResponse =
  zImageAppsV2ObjectRemovalOutput;

export const zGetFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageAppsV2HeadshotPhotoData = z.object({
  body: zImageAppsV2HeadshotPhotoInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2HeadshotPhotoResponse = zQueueStatus;

export const zGetFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdResponse =
  zImageAppsV2HeadshotPhotoOutput;

export const zGetFalAiImageAppsV2HairChangeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2HairChangeRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageAppsV2HairChangeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2HairChangeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiImageAppsV2HairChangeData = z.object({
  body: zImageAppsV2HairChangeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2HairChangeResponse = zQueueStatus;

export const zGetFalAiImageAppsV2HairChangeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2HairChangeRequestsByRequestIdResponse =
  zImageAppsV2HairChangeOutput;

export const zGetFalAiImageAppsV2ExpressionChangeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2ExpressionChangeRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageAppsV2ExpressionChangeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2ExpressionChangeRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageAppsV2ExpressionChangeData = z.object({
  body: zImageAppsV2ExpressionChangeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2ExpressionChangeResponse = zQueueStatus;

export const zGetFalAiImageAppsV2ExpressionChangeRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2ExpressionChangeRequestsByRequestIdResponse =
  zImageAppsV2ExpressionChangeOutput;

export const zGetFalAiImageAppsV2CityTeleportRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2CityTeleportRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageAppsV2CityTeleportRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2CityTeleportRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageAppsV2CityTeleportData = z.object({
  body: zImageAppsV2CityTeleportInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2CityTeleportResponse = zQueueStatus;

export const zGetFalAiImageAppsV2CityTeleportRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2CityTeleportRequestsByRequestIdResponse =
  zImageAppsV2CityTeleportOutput;

export const zGetFalAiImageAppsV2AgeModifyRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2AgeModifyRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageAppsV2AgeModifyRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2AgeModifyRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiImageAppsV2AgeModifyData = z.object({
  body: zImageAppsV2AgeModifyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2AgeModifyResponse = zQueueStatus;

export const zGetFalAiImageAppsV2AgeModifyRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2AgeModifyRequestsByRequestIdResponse =
  zImageAppsV2AgeModifyOutput;

export const zGetFalAiImageAppsV2MakeupApplicationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2MakeupApplicationRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageAppsV2MakeupApplicationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2MakeupApplicationRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageAppsV2MakeupApplicationData = z.object({
  body: zImageAppsV2MakeupApplicationInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2MakeupApplicationResponse = zQueueStatus;

export const zGetFalAiImageAppsV2MakeupApplicationRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2MakeupApplicationRequestsByRequestIdResponse =
  zImageAppsV2MakeupApplicationOutput;

export const zGetFalAiQwenImageEditInpaintRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditInpaintRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEditInpaintRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditInpaintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiQwenImageEditInpaintData = z.object({
  body: zQwenImageEditInpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditInpaintResponse = zQueueStatus;

export const zGetFalAiQwenImageEditInpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditInpaintRequestsByRequestIdResponse =
  zQwenImageEditInpaintOutput;

export const zGetFalAiFluxSrpoImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxSrpoImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxSrpoImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxSrpoImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxSrpoImageToImageData = z.object({
  body: zFluxSrpoImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxSrpoImageToImageResponse = zQueueStatus;

export const zGetFalAiFluxSrpoImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxSrpoImageToImageRequestsByRequestIdResponse =
  zFluxSrpoImageToImageOutput;

export const zGetFalAiFlux1SrpoImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlux1SrpoImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux1SrpoImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux1SrpoImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux1SrpoImageToImageData = z.object({
  body: zFlux1SrpoImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux1SrpoImageToImageResponse = zQueueStatus;

export const zGetFalAiFlux1SrpoImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux1SrpoImageToImageRequestsByRequestIdResponse =
  zFlux1SrpoImageToImageOutput;

export const zGetFalAiQwenImageEditLoraRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditLoraRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEditLoraRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiQwenImageEditLoraData = z.object({
  body: zQwenImageEditLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditLoraResponse = zQueueStatus;

export const zGetFalAiQwenImageEditLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditLoraRequestsByRequestIdResponse =
  zQwenImageEditLoraOutput;

export const zGetFalAiViduReferenceToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiViduReferenceToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiViduReferenceToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiViduReferenceToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiViduReferenceToImageData = z.object({
  body: zViduReferenceToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiViduReferenceToImageResponse = zQueueStatus;

export const zGetFalAiViduReferenceToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiViduReferenceToImageRequestsByRequestIdResponse =
  zViduReferenceToImageOutput;

export const zGetFalAiBytedanceSeedreamV4EditRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiBytedanceSeedreamV4EditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiBytedanceSeedreamV4EditRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiBytedanceSeedreamV4EditRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiBytedanceSeedreamV4EditData = z.object({
  body: zBytedanceSeedreamV4EditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiBytedanceSeedreamV4EditResponse = zQueueStatus;

export const zGetFalAiBytedanceSeedreamV4EditRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * Result of the request.
 */
export const zGetFalAiBytedanceSeedreamV4EditRequestsByRequestIdResponse =
  zBytedanceSeedreamV4EditOutput;

export const zGetFalAiWanV22A14bImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiWanV22A14bImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiWanV22A14bImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiWanV22A14bImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiWanV22A14bImageToImageData = z.object({
  body: zWanV22A14bImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiWanV22A14bImageToImageResponse = zQueueStatus;

export const zGetFalAiWanV22A14bImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiWanV22A14bImageToImageRequestsByRequestIdResponse =
  zWanV22A14bImageToImageOutput;

export const zGetFalAiUsoRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiUsoRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiUsoRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiUsoRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiUsoData = z.object({
  body: zUsoInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiUsoResponse = zQueueStatus;

export const zGetFalAiUsoRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiUsoRequestsByRequestIdResponse = zUsoOutput;

export const zGetFalAiGemini25FlashImageEditRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiGemini25FlashImageEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiGemini25FlashImageEditRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiGemini25FlashImageEditRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiGemini25FlashImageEditData = z.object({
  body: zGemini25FlashImageEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiGemini25FlashImageEditResponse = zQueueStatus;

export const zGetFalAiGemini25FlashImageEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiGemini25FlashImageEditRequestsByRequestIdResponse =
  zGemini25FlashImageEditOutput;

export const zGetFalAiQwenImageImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiQwenImageImageToImageData = z.object({
  body: zQwenImageImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageImageToImageResponse = zQueueStatus;

export const zGetFalAiQwenImageImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageImageToImageRequestsByRequestIdResponse =
  zQwenImageImageToImageOutput;

export const zGetBriaReimagine32RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetBriaReimagine32RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutBriaReimagine32RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutBriaReimagine32RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostBriaReimagine32Data = z.object({
  body: zReimagine32Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostBriaReimagine32Response = zQueueStatus;

export const zGetBriaReimagine32RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetBriaReimagine32RequestsByRequestIdResponse =
  zReimagine32Output;

export const zGetFalAiNanoBananaEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiNanoBananaEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiNanoBananaEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiNanoBananaEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiNanoBananaEditData = z.object({
  body: zNanoBananaEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiNanoBananaEditResponse = zQueueStatus;

export const zGetFalAiNanoBananaEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiNanoBananaEditRequestsByRequestIdResponse =
  zNanoBananaEditOutput;

export const zGetFalAiNextstep1RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiNextstep1RequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiNextstep1RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiNextstep1RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiNextstep1Data = z.object({
  body: zNextstep1Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiNextstep1Response = zQueueStatus;

export const zGetFalAiNextstep1RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiNextstep1RequestsByRequestIdResponse = zNextstep1Output;

export const zGetFalAiQwenImageEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiQwenImageEditData = z.object({
  body: zQwenImageEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditResponse = zQueueStatus;

export const zGetFalAiQwenImageEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditRequestsByRequestIdResponse =
  zQwenImageEditOutput;

export const zGetFalAiIdeogramCharacterEditRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiIdeogramCharacterEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiIdeogramCharacterEditRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramCharacterEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiIdeogramCharacterEditData = z.object({
  body: zIdeogramCharacterEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiIdeogramCharacterEditResponse = zQueueStatus;

export const zGetFalAiIdeogramCharacterEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramCharacterEditRequestsByRequestIdResponse =
  zIdeogramCharacterEditOutput;

export const zGetFalAiIdeogramCharacterRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiIdeogramCharacterRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiIdeogramCharacterRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramCharacterRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiIdeogramCharacterData = z.object({
  body: zIdeogramCharacterInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiIdeogramCharacterResponse = zQueueStatus;

export const zGetFalAiIdeogramCharacterRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramCharacterRequestsByRequestIdResponse =
  zIdeogramCharacterOutput;

export const zGetFalAiIdeogramCharacterRemixRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiIdeogramCharacterRemixRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiIdeogramCharacterRemixRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramCharacterRemixRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiIdeogramCharacterRemixData = z.object({
  body: zIdeogramCharacterRemixInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiIdeogramCharacterRemixResponse = zQueueStatus;

export const zGetFalAiIdeogramCharacterRemixRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramCharacterRemixRequestsByRequestIdResponse =
  zIdeogramCharacterRemixOutput;

export const zGetFalAiFluxKreaLoraInpaintingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxKreaLoraInpaintingRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxKreaLoraInpaintingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxKreaLoraInpaintingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFluxKreaLoraInpaintingData = z.object({
  body: zFluxKreaLoraInpaintingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxKreaLoraInpaintingResponse = zQueueStatus;

export const zGetFalAiFluxKreaLoraInpaintingRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxKreaLoraInpaintingRequestsByRequestIdResponse =
  zFluxKreaLoraInpaintingOutput;

export const zGetFalAiFluxKreaLoraImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxKreaLoraImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxKreaLoraImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxKreaLoraImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFluxKreaLoraImageToImageData = z.object({
  body: zFluxKreaLoraImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxKreaLoraImageToImageResponse = zQueueStatus;

export const zGetFalAiFluxKreaLoraImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFluxKreaLoraImageToImageRequestsByRequestIdResponse =
  zFluxKreaLoraImageToImageOutput;

export const zGetFalAiFluxKreaImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxKreaImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxKreaImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxKreaImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxKreaImageToImageData = z.object({
  body: zFluxKreaImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxKreaImageToImageResponse = zQueueStatus;

export const zGetFalAiFluxKreaImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxKreaImageToImageRequestsByRequestIdResponse =
  zFluxKreaImageToImageOutput;

export const zGetFalAiFluxKreaReduxRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxKreaReduxRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxKreaReduxRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxKreaReduxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxKreaReduxData = z.object({
  body: zFluxKreaReduxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxKreaReduxResponse = zQueueStatus;

export const zGetFalAiFluxKreaReduxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxKreaReduxRequestsByRequestIdResponse =
  zFluxKreaReduxOutput;

export const zGetFalAiFlux1KreaImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlux1KreaImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux1KreaImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux1KreaImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux1KreaImageToImageData = z.object({
  body: zFlux1KreaImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux1KreaImageToImageResponse = zQueueStatus;

export const zGetFalAiFlux1KreaImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux1KreaImageToImageRequestsByRequestIdResponse =
  zFlux1KreaImageToImageOutput;

export const zGetFalAiFlux1KreaReduxRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux1KreaReduxRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux1KreaReduxRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux1KreaReduxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux1KreaReduxData = z.object({
  body: zFlux1KreaReduxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux1KreaReduxResponse = zQueueStatus;

export const zGetFalAiFlux1KreaReduxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux1KreaReduxRequestsByRequestIdResponse =
  zFlux1KreaReduxOutput;

export const zGetFalAiFluxKontextLoraInpaintRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxKontextLoraInpaintRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxKontextLoraInpaintRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxKontextLoraInpaintRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFluxKontextLoraInpaintData = z.object({
  body: zFluxKontextLoraInpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxKontextLoraInpaintResponse = zQueueStatus;

export const zGetFalAiFluxKontextLoraInpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxKontextLoraInpaintRequestsByRequestIdResponse =
  zFluxKontextLoraInpaintOutput;

export const zGetFalAiHunyuanWorldRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiHunyuanWorldRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuanWorldRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuanWorldRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiHunyuanWorldData = z.object({
  body: zHunyuanWorldInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuanWorldResponse = zQueueStatus;

export const zGetFalAiHunyuanWorldRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiHunyuanWorldRequestsByRequestIdResponse =
  zHunyuanWorldOutput;

export const zGetFalAiImageEditingRetouchRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingRetouchRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingRetouchRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingRetouchRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiImageEditingRetouchData = z.object({
  body: zImageEditingRetouchInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingRetouchResponse = zQueueStatus;

export const zGetFalAiImageEditingRetouchRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingRetouchRequestsByRequestIdResponse =
  zImageEditingRetouchOutput;

export const zGetFalAiHidreamE11RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiHidreamE11RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHidreamE11RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiHidreamE11RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiHidreamE11Data = z.object({
  body: zHidreamE11Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHidreamE11Response = zQueueStatus;

export const zGetFalAiHidreamE11RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiHidreamE11RequestsByRequestIdResponse = zHidreamE11Output;

export const zGetFalAiRifeRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiRifeRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiRifeRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiRifeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiRifeData = z.object({
  body: zRifeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiRifeResponse = zQueueStatus;

export const zGetFalAiRifeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiRifeRequestsByRequestIdResponse = zRifeOutput;

export const zGetFalAiFilmRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFilmRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiFilmRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFilmRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFilmData = z.object({
  body: zFilmInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFilmResponse = zQueueStatus;

export const zGetFalAiFilmRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFilmRequestsByRequestIdResponse = zFilmOutput;

export const zGetFalAiCalligrapherRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiCalligrapherRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiCalligrapherRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiCalligrapherRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiCalligrapherData = z.object({
  body: zCalligrapherInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiCalligrapherResponse = zQueueStatus;

export const zGetFalAiCalligrapherRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiCalligrapherRequestsByRequestIdResponse =
  zCalligrapherOutput;

export const zGetFalAiBriaReimagineRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiBriaReimagineRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiBriaReimagineRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiBriaReimagineRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiBriaReimagineData = z.object({
  body: zBriaReimagineInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiBriaReimagineResponse = zQueueStatus;

export const zGetFalAiBriaReimagineRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiBriaReimagineRequestsByRequestIdResponse =
  zBriaReimagineOutput;

export const zGetFalAiImageEditingRealismRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingRealismRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingRealismRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingRealismRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiImageEditingRealismData = z.object({
  body: zImageEditingRealismInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingRealismResponse = zQueueStatus;

export const zGetFalAiImageEditingRealismRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingRealismRequestsByRequestIdResponse =
  zImageEditingRealismOutput;

export const zGetFalAiPostProcessingVignetteRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiPostProcessingVignetteRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiPostProcessingVignetteRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingVignetteRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiPostProcessingVignetteData = z.object({
  body: zPostProcessingVignetteInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPostProcessingVignetteResponse = zQueueStatus;

export const zGetFalAiPostProcessingVignetteRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingVignetteRequestsByRequestIdResponse =
  zPostProcessingVignetteOutput;

export const zGetFalAiPostProcessingSolarizeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiPostProcessingSolarizeRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiPostProcessingSolarizeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingSolarizeRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiPostProcessingSolarizeData = z.object({
  body: zPostProcessingSolarizeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPostProcessingSolarizeResponse = zQueueStatus;

export const zGetFalAiPostProcessingSolarizeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingSolarizeRequestsByRequestIdResponse =
  zPostProcessingSolarizeOutput;

export const zGetFalAiPostProcessingSharpenRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiPostProcessingSharpenRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiPostProcessingSharpenRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingSharpenRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiPostProcessingSharpenData = z.object({
  body: zPostProcessingSharpenInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPostProcessingSharpenResponse = zQueueStatus;

export const zGetFalAiPostProcessingSharpenRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingSharpenRequestsByRequestIdResponse =
  zPostProcessingSharpenOutput;

export const zGetFalAiPostProcessingParabolizeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiPostProcessingParabolizeRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiPostProcessingParabolizeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingParabolizeRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiPostProcessingParabolizeData = z.object({
  body: zPostProcessingParabolizeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPostProcessingParabolizeResponse = zQueueStatus;

export const zGetFalAiPostProcessingParabolizeRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingParabolizeRequestsByRequestIdResponse =
  zPostProcessingParabolizeOutput;

export const zGetFalAiPostProcessingGrainRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiPostProcessingGrainRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiPostProcessingGrainRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingGrainRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiPostProcessingGrainData = z.object({
  body: zPostProcessingGrainInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPostProcessingGrainResponse = zQueueStatus;

export const zGetFalAiPostProcessingGrainRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingGrainRequestsByRequestIdResponse =
  zPostProcessingGrainOutput;

export const zGetFalAiPostProcessingDodgeBurnRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiPostProcessingDodgeBurnRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiPostProcessingDodgeBurnRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingDodgeBurnRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiPostProcessingDodgeBurnData = z.object({
  body: zPostProcessingDodgeBurnInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPostProcessingDodgeBurnResponse = zQueueStatus;

export const zGetFalAiPostProcessingDodgeBurnRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingDodgeBurnRequestsByRequestIdResponse =
  zPostProcessingDodgeBurnOutput;

export const zGetFalAiPostProcessingDissolveRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiPostProcessingDissolveRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiPostProcessingDissolveRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingDissolveRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiPostProcessingDissolveData = z.object({
  body: zPostProcessingDissolveInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPostProcessingDissolveResponse = zQueueStatus;

export const zGetFalAiPostProcessingDissolveRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingDissolveRequestsByRequestIdResponse =
  zPostProcessingDissolveOutput;

export const zGetFalAiPostProcessingDesaturateRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiPostProcessingDesaturateRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiPostProcessingDesaturateRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingDesaturateRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiPostProcessingDesaturateData = z.object({
  body: zPostProcessingDesaturateInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPostProcessingDesaturateResponse = zQueueStatus;

export const zGetFalAiPostProcessingDesaturateRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingDesaturateRequestsByRequestIdResponse =
  zPostProcessingDesaturateOutput;

export const zGetFalAiPostProcessingColorTintRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiPostProcessingColorTintRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiPostProcessingColorTintRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingColorTintRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiPostProcessingColorTintData = z.object({
  body: zPostProcessingColorTintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPostProcessingColorTintResponse = zQueueStatus;

export const zGetFalAiPostProcessingColorTintRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingColorTintRequestsByRequestIdResponse =
  zPostProcessingColorTintOutput;

export const zGetFalAiPostProcessingColorCorrectionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiPostProcessingColorCorrectionRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiPostProcessingColorCorrectionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingColorCorrectionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiPostProcessingColorCorrectionData = z.object({
  body: zPostProcessingColorCorrectionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPostProcessingColorCorrectionResponse = zQueueStatus;

export const zGetFalAiPostProcessingColorCorrectionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingColorCorrectionRequestsByRequestIdResponse =
  zPostProcessingColorCorrectionOutput;

export const zGetFalAiPostProcessingChromaticAberrationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiPostProcessingChromaticAberrationRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiPostProcessingChromaticAberrationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingChromaticAberrationRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiPostProcessingChromaticAberrationData = z.object({
  body: zPostProcessingChromaticAberrationInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPostProcessingChromaticAberrationResponse = zQueueStatus;

export const zGetFalAiPostProcessingChromaticAberrationRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingChromaticAberrationRequestsByRequestIdResponse =
  zPostProcessingChromaticAberrationOutput;

export const zGetFalAiPostProcessingBlurRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiPostProcessingBlurRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiPostProcessingBlurRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingBlurRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiPostProcessingBlurData = z.object({
  body: zPostProcessingBlurInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPostProcessingBlurResponse = zQueueStatus;

export const zGetFalAiPostProcessingBlurRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingBlurRequestsByRequestIdResponse =
  zPostProcessingBlurOutput;

export const zGetFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageEditingYoutubeThumbnailsData = z.object({
  body: zImageEditingYoutubeThumbnailsInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingYoutubeThumbnailsResponse = zQueueStatus;

export const zGetFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdResponse =
  zImageEditingYoutubeThumbnailsOutput;

export const zGetFalAiTopazUpscaleImageRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiTopazUpscaleImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiTopazUpscaleImageRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiTopazUpscaleImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiTopazUpscaleImageData = z.object({
  body: zTopazUpscaleImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiTopazUpscaleImageResponse = zQueueStatus;

export const zGetFalAiTopazUpscaleImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiTopazUpscaleImageRequestsByRequestIdResponse =
  zTopazUpscaleImageOutput;

export const zGetFalAiImageEditingBroccoliHaircutRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingBroccoliHaircutRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingBroccoliHaircutRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingBroccoliHaircutRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageEditingBroccoliHaircutData = z.object({
  body: zImageEditingBroccoliHaircutInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingBroccoliHaircutResponse = zQueueStatus;

export const zGetFalAiImageEditingBroccoliHaircutRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingBroccoliHaircutRequestsByRequestIdResponse =
  zImageEditingBroccoliHaircutOutput;

export const zGetFalAiImageEditingWojakStyleRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingWojakStyleRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingWojakStyleRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingWojakStyleRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageEditingWojakStyleData = z.object({
  body: zImageEditingWojakStyleInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingWojakStyleResponse = zQueueStatus;

export const zGetFalAiImageEditingWojakStyleRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingWojakStyleRequestsByRequestIdResponse =
  zImageEditingWojakStyleOutput;

export const zGetFalAiImageEditingPlushieStyleRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingPlushieStyleRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingPlushieStyleRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingPlushieStyleRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageEditingPlushieStyleData = z.object({
  body: zImageEditingPlushieStyleInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingPlushieStyleResponse = zQueueStatus;

export const zGetFalAiImageEditingPlushieStyleRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingPlushieStyleRequestsByRequestIdResponse =
  zImageEditingPlushieStyleOutput;

export const zGetFalAiFluxKontextLoraRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxKontextLoraRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxKontextLoraRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxKontextLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxKontextLoraData = z.object({
  body: zFluxKontextLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxKontextLoraResponse = zQueueStatus;

export const zGetFalAiFluxKontextLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxKontextLoraRequestsByRequestIdResponse =
  zFluxKontextLoraOutput;

export const zGetFalAiFashnTryonV16RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFashnTryonV16RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFashnTryonV16RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFashnTryonV16RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFashnTryonV16Data = z.object({
  body: zFashnTryonV16Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFashnTryonV16Response = zQueueStatus;

export const zGetFalAiFashnTryonV16RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFashnTryonV16RequestsByRequestIdResponse =
  zFashnTryonV16Output;

export const zGetFalAiChainOfZoomRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiChainOfZoomRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiChainOfZoomRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiChainOfZoomRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiChainOfZoomData = z.object({
  body: zChainOfZoomInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiChainOfZoomResponse = zQueueStatus;

export const zGetFalAiChainOfZoomRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiChainOfZoomRequestsByRequestIdResponse =
  zChainOfZoomOutput;

export const zGetFalAiPasdRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiPasdRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiPasdRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiPasdRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiPasdData = z.object({
  body: zPasdInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPasdResponse = zQueueStatus;

export const zGetFalAiPasdRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiPasdRequestsByRequestIdResponse = zPasdOutput;

export const zGetFalAiObjectRemovalBboxRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiObjectRemovalBboxRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiObjectRemovalBboxRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiObjectRemovalBboxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiObjectRemovalBboxData = z.object({
  body: zObjectRemovalBboxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiObjectRemovalBboxResponse = zQueueStatus;

export const zGetFalAiObjectRemovalBboxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiObjectRemovalBboxRequestsByRequestIdResponse =
  zObjectRemovalBboxOutput;

export const zGetFalAiObjectRemovalMaskRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiObjectRemovalMaskRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiObjectRemovalMaskRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiObjectRemovalMaskRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiObjectRemovalMaskData = z.object({
  body: zObjectRemovalMaskInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiObjectRemovalMaskResponse = zQueueStatus;

export const zGetFalAiObjectRemovalMaskRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiObjectRemovalMaskRequestsByRequestIdResponse =
  zObjectRemovalMaskOutput;

export const zGetFalAiObjectRemovalRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiObjectRemovalRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiObjectRemovalRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiObjectRemovalRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiObjectRemovalData = z.object({
  body: zObjectRemovalInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiObjectRemovalResponse = zQueueStatus;

export const zGetFalAiObjectRemovalRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiObjectRemovalRequestsByRequestIdResponse =
  zObjectRemovalOutput;

export const zGetFalAiRecraftVectorizeRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiRecraftVectorizeRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiRecraftVectorizeRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiRecraftVectorizeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiRecraftVectorizeData = z.object({
  body: zRecraftVectorizeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiRecraftVectorizeResponse = zQueueStatus;

export const zGetFalAiRecraftVectorizeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiRecraftVectorizeRequestsByRequestIdResponse =
  zRecraftVectorizeOutput;

export const zGetFalAiFfmpegApiExtractFrameRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFfmpegApiExtractFrameRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFfmpegApiExtractFrameRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFfmpegApiExtractFrameRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFfmpegApiExtractFrameData = z.object({
  body: zFfmpegApiExtractFrameInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFfmpegApiExtractFrameResponse = zQueueStatus;

export const zGetFalAiFfmpegApiExtractFrameRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFfmpegApiExtractFrameRequestsByRequestIdResponse =
  zFfmpegApiExtractFrameOutput;

export const zGetFalAiLumaPhotonFlashModifyRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiLumaPhotonFlashModifyRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiLumaPhotonFlashModifyRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiLumaPhotonFlashModifyRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiLumaPhotonFlashModifyData = z.object({
  body: zLumaPhotonFlashModifyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiLumaPhotonFlashModifyResponse = zQueueStatus;

export const zGetFalAiLumaPhotonFlashModifyRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiLumaPhotonFlashModifyRequestsByRequestIdResponse =
  zLumaPhotonFlashModifyOutput;

export const zGetFalAiLumaPhotonModifyRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiLumaPhotonModifyRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiLumaPhotonModifyRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiLumaPhotonModifyRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiLumaPhotonModifyData = z.object({
  body: zLumaPhotonModifyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiLumaPhotonModifyResponse = zQueueStatus;

export const zGetFalAiLumaPhotonModifyRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiLumaPhotonModifyRequestsByRequestIdResponse =
  zLumaPhotonModifyOutput;

export const zGetFalAiImageEditingReframeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingReframeRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingReframeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingReframeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiImageEditingReframeData = z.object({
  body: zImageEditingReframeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingReframeResponse = zQueueStatus;

export const zGetFalAiImageEditingReframeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingReframeRequestsByRequestIdResponse =
  zImageEditingReframeOutput;

export const zGetFalAiImageEditingBabyVersionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingBabyVersionRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingBabyVersionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingBabyVersionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageEditingBabyVersionData = z.object({
  body: zImageEditingBabyVersionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingBabyVersionResponse = zQueueStatus;

export const zGetFalAiImageEditingBabyVersionRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingBabyVersionRequestsByRequestIdResponse =
  zImageEditingBabyVersionOutput;

export const zGetFalAiLumaPhotonFlashReframeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiLumaPhotonFlashReframeRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiLumaPhotonFlashReframeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiLumaPhotonFlashReframeRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiLumaPhotonFlashReframeData = z.object({
  body: zLumaPhotonFlashReframeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiLumaPhotonFlashReframeResponse = zQueueStatus;

export const zGetFalAiLumaPhotonFlashReframeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiLumaPhotonFlashReframeRequestsByRequestIdResponse =
  zLumaPhotonFlashReframeOutput;

export const zGetFalAiLumaPhotonReframeRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiLumaPhotonReframeRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiLumaPhotonReframeRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiLumaPhotonReframeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiLumaPhotonReframeData = z.object({
  body: zLumaPhotonReframeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiLumaPhotonReframeResponse = zQueueStatus;

export const zGetFalAiLumaPhotonReframeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiLumaPhotonReframeRequestsByRequestIdResponse =
  zLumaPhotonReframeOutput;

export const zGetFalAiFlux1SchnellReduxRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiFlux1SchnellReduxRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux1SchnellReduxRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux1SchnellReduxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux1SchnellReduxData = z.object({
  body: zFlux1SchnellReduxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux1SchnellReduxResponse = zQueueStatus;

export const zGetFalAiFlux1SchnellReduxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux1SchnellReduxRequestsByRequestIdResponse =
  zFlux1SchnellReduxOutput;

export const zGetFalAiFlux1DevReduxRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux1DevReduxRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux1DevReduxRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux1DevReduxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux1DevReduxData = z.object({
  body: zFlux1DevReduxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux1DevReduxResponse = zQueueStatus;

export const zGetFalAiFlux1DevReduxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux1DevReduxRequestsByRequestIdResponse =
  zFlux1DevReduxOutput;

export const zGetFalAiFlux1DevImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlux1DevImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux1DevImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux1DevImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux1DevImageToImageData = z.object({
  body: zFlux1DevImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux1DevImageToImageResponse = zQueueStatus;

export const zGetFalAiFlux1DevImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux1DevImageToImageRequestsByRequestIdResponse =
  zFlux1DevImageToImageOutput;

export const zGetFalAiImageEditingTextRemovalRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingTextRemovalRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingTextRemovalRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingTextRemovalRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageEditingTextRemovalData = z.object({
  body: zImageEditingTextRemovalInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingTextRemovalResponse = zQueueStatus;

export const zGetFalAiImageEditingTextRemovalRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingTextRemovalRequestsByRequestIdResponse =
  zImageEditingTextRemovalOutput;

export const zGetFalAiImageEditingPhotoRestorationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingPhotoRestorationRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingPhotoRestorationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingPhotoRestorationRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageEditingPhotoRestorationData = z.object({
  body: zImageEditingPhotoRestorationInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingPhotoRestorationResponse = zQueueStatus;

export const zGetFalAiImageEditingPhotoRestorationRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingPhotoRestorationRequestsByRequestIdResponse =
  zImageEditingPhotoRestorationOutput;

export const zGetFalAiImageEditingWeatherEffectRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingWeatherEffectRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingWeatherEffectRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingWeatherEffectRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageEditingWeatherEffectData = z.object({
  body: zImageEditingWeatherEffectInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingWeatherEffectResponse = zQueueStatus;

export const zGetFalAiImageEditingWeatherEffectRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingWeatherEffectRequestsByRequestIdResponse =
  zImageEditingWeatherEffectOutput;

export const zGetFalAiImageEditingTimeOfDayRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingTimeOfDayRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingTimeOfDayRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingTimeOfDayRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiImageEditingTimeOfDayData = z.object({
  body: zImageEditingTimeOfDayInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingTimeOfDayResponse = zQueueStatus;

export const zGetFalAiImageEditingTimeOfDayRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingTimeOfDayRequestsByRequestIdResponse =
  zImageEditingTimeOfDayOutput;

export const zGetFalAiImageEditingStyleTransferRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingStyleTransferRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingStyleTransferRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingStyleTransferRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageEditingStyleTransferData = z.object({
  body: zImageEditingStyleTransferInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingStyleTransferResponse = zQueueStatus;

export const zGetFalAiImageEditingStyleTransferRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingStyleTransferRequestsByRequestIdResponse =
  zImageEditingStyleTransferOutput;

export const zGetFalAiImageEditingSceneCompositionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingSceneCompositionRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingSceneCompositionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingSceneCompositionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageEditingSceneCompositionData = z.object({
  body: zImageEditingSceneCompositionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingSceneCompositionResponse = zQueueStatus;

export const zGetFalAiImageEditingSceneCompositionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingSceneCompositionRequestsByRequestIdResponse =
  zImageEditingSceneCompositionOutput;

export const zGetFalAiImageEditingProfessionalPhotoRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingProfessionalPhotoRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingProfessionalPhotoRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingProfessionalPhotoRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageEditingProfessionalPhotoData = z.object({
  body: zImageEditingProfessionalPhotoInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingProfessionalPhotoResponse = zQueueStatus;

export const zGetFalAiImageEditingProfessionalPhotoRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingProfessionalPhotoRequestsByRequestIdResponse =
  zImageEditingProfessionalPhotoOutput;

export const zGetFalAiImageEditingObjectRemovalRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingObjectRemovalRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingObjectRemovalRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingObjectRemovalRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageEditingObjectRemovalData = z.object({
  body: zImageEditingObjectRemovalInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingObjectRemovalResponse = zQueueStatus;

export const zGetFalAiImageEditingObjectRemovalRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingObjectRemovalRequestsByRequestIdResponse =
  zImageEditingObjectRemovalOutput;

export const zGetFalAiImageEditingHairChangeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingHairChangeRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingHairChangeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingHairChangeRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageEditingHairChangeData = z.object({
  body: zImageEditingHairChangeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingHairChangeResponse = zQueueStatus;

export const zGetFalAiImageEditingHairChangeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingHairChangeRequestsByRequestIdResponse =
  zImageEditingHairChangeOutput;

export const zGetFalAiImageEditingFaceEnhancementRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingFaceEnhancementRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingFaceEnhancementRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingFaceEnhancementRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageEditingFaceEnhancementData = z.object({
  body: zImageEditingFaceEnhancementInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingFaceEnhancementResponse = zQueueStatus;

export const zGetFalAiImageEditingFaceEnhancementRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingFaceEnhancementRequestsByRequestIdResponse =
  zImageEditingFaceEnhancementOutput;

export const zGetFalAiImageEditingExpressionChangeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingExpressionChangeRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingExpressionChangeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingExpressionChangeRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageEditingExpressionChangeData = z.object({
  body: zImageEditingExpressionChangeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingExpressionChangeResponse = zQueueStatus;

export const zGetFalAiImageEditingExpressionChangeRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingExpressionChangeRequestsByRequestIdResponse =
  zImageEditingExpressionChangeOutput;

export const zGetFalAiImageEditingColorCorrectionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingColorCorrectionRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingColorCorrectionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingColorCorrectionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageEditingColorCorrectionData = z.object({
  body: zImageEditingColorCorrectionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingColorCorrectionResponse = zQueueStatus;

export const zGetFalAiImageEditingColorCorrectionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingColorCorrectionRequestsByRequestIdResponse =
  zImageEditingColorCorrectionOutput;

export const zGetFalAiImageEditingCartoonifyRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingCartoonifyRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingCartoonifyRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingCartoonifyRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageEditingCartoonifyData = z.object({
  body: zImageEditingCartoonifyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingCartoonifyResponse = zQueueStatus;

export const zGetFalAiImageEditingCartoonifyRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingCartoonifyRequestsByRequestIdResponse =
  zImageEditingCartoonifyOutput;

export const zGetFalAiImageEditingBackgroundChangeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingBackgroundChangeRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingBackgroundChangeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingBackgroundChangeRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageEditingBackgroundChangeData = z.object({
  body: zImageEditingBackgroundChangeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingBackgroundChangeResponse = zQueueStatus;

export const zGetFalAiImageEditingBackgroundChangeRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingBackgroundChangeRequestsByRequestIdResponse =
  zImageEditingBackgroundChangeOutput;

export const zGetFalAiImageEditingAgeProgressionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageEditingAgeProgressionRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageEditingAgeProgressionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingAgeProgressionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageEditingAgeProgressionData = z.object({
  body: zImageEditingAgeProgressionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageEditingAgeProgressionResponse = zQueueStatus;

export const zGetFalAiImageEditingAgeProgressionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingAgeProgressionRequestsByRequestIdResponse =
  zImageEditingAgeProgressionOutput;

export const zGetFalAiFluxProKontextMaxMultiRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxProKontextMaxMultiRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxProKontextMaxMultiRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProKontextMaxMultiRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFluxProKontextMaxMultiData = z.object({
  body: zFluxProKontextMaxMultiInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxProKontextMaxMultiResponse = zQueueStatus;

export const zGetFalAiFluxProKontextMaxMultiRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxProKontextMaxMultiRequestsByRequestIdResponse =
  zFluxProKontextMaxMultiOutput;

export const zGetFalAiFluxProKontextMultiRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxProKontextMultiRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxProKontextMultiRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProKontextMultiRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxProKontextMultiData = z.object({
  body: zFluxProKontextMultiInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxProKontextMultiResponse = zQueueStatus;

export const zGetFalAiFluxProKontextMultiRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxProKontextMultiRequestsByRequestIdResponse =
  zFluxProKontextMultiOutput;

export const zGetFalAiFluxProKontextMaxRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiFluxProKontextMaxRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxProKontextMaxRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProKontextMaxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxProKontextMaxData = z.object({
  body: zFluxProKontextMaxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxProKontextMaxResponse = zQueueStatus;

export const zGetFalAiFluxProKontextMaxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxProKontextMaxRequestsByRequestIdResponse =
  zFluxProKontextMaxOutput;

export const zGetFalAiFluxKontextDevRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxKontextDevRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxKontextDevRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxKontextDevRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxKontextDevData = z.object({
  body: zFluxKontextDevInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxKontextDevResponse = zQueueStatus;

export const zGetFalAiFluxKontextDevRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxKontextDevRequestsByRequestIdResponse =
  zFluxKontextDevOutput;

export const zGetFalAiBagelEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiBagelEditRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiBagelEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiBagelEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiBagelEditData = z.object({
  body: zBagelEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiBagelEditResponse = zQueueStatus;

export const zGetFalAiBagelEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiBagelEditRequestsByRequestIdResponse = zBagelEditOutput;

export const zGetSmoretalkAiRembgEnhanceRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetSmoretalkAiRembgEnhanceRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutSmoretalkAiRembgEnhanceRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutSmoretalkAiRembgEnhanceRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostSmoretalkAiRembgEnhanceData = z.object({
  body: zRembgEnhanceInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostSmoretalkAiRembgEnhanceResponse = zQueueStatus;

export const zGetSmoretalkAiRembgEnhanceRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetSmoretalkAiRembgEnhanceRequestsByRequestIdResponse =
  zRembgEnhanceOutput;

export const zGetFalAiRecraftUpscaleCreativeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiRecraftUpscaleCreativeRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiRecraftUpscaleCreativeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiRecraftUpscaleCreativeRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiRecraftUpscaleCreativeData = z.object({
  body: zRecraftUpscaleCreativeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiRecraftUpscaleCreativeResponse = zQueueStatus;

export const zGetFalAiRecraftUpscaleCreativeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiRecraftUpscaleCreativeRequestsByRequestIdResponse =
  zRecraftUpscaleCreativeOutput;

export const zGetFalAiRecraftUpscaleCrispRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiRecraftUpscaleCrispRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiRecraftUpscaleCrispRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiRecraftUpscaleCrispRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiRecraftUpscaleCrispData = z.object({
  body: zRecraftUpscaleCrispInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiRecraftUpscaleCrispResponse = zQueueStatus;

export const zGetFalAiRecraftUpscaleCrispRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiRecraftUpscaleCrispRequestsByRequestIdResponse =
  zRecraftUpscaleCrispOutput;

export const zGetFalAiRecraftV3ImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiRecraftV3ImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiRecraftV3ImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiRecraftV3ImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiRecraftV3ImageToImageData = z.object({
  body: zRecraftV3ImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiRecraftV3ImageToImageResponse = zQueueStatus;

export const zGetFalAiRecraftV3ImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiRecraftV3ImageToImageRequestsByRequestIdResponse =
  zRecraftV3ImageToImageOutput;

export const zGetFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiMinimaxImage01SubjectReferenceData = z.object({
  body: zMinimaxImage01SubjectReferenceInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiMinimaxImage01SubjectReferenceResponse = zQueueStatus;

export const zGetFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdResponse =
  zMinimaxImage01SubjectReferenceOutput;

export const zGetFalAiHidreamI1FullImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiHidreamI1FullImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHidreamI1FullImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiHidreamI1FullImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiHidreamI1FullImageToImageData = z.object({
  body: zHidreamI1FullImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHidreamI1FullImageToImageResponse = zQueueStatus;

export const zGetFalAiHidreamI1FullImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiHidreamI1FullImageToImageRequestsByRequestIdResponse =
  zHidreamI1FullImageToImageOutput;

export const zGetFalAiIdeogramV3ReframeRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiIdeogramV3ReframeRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiIdeogramV3ReframeRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV3ReframeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiIdeogramV3ReframeData = z.object({
  body: zIdeogramV3ReframeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiIdeogramV3ReframeResponse = zQueueStatus;

export const zGetFalAiIdeogramV3ReframeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV3ReframeRequestsByRequestIdResponse =
  zIdeogramV3ReframeOutput;

export const zGetFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiIdeogramV3ReplaceBackgroundData = z.object({
  body: zIdeogramV3ReplaceBackgroundInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiIdeogramV3ReplaceBackgroundResponse = zQueueStatus;

export const zGetFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdResponse =
  zIdeogramV3ReplaceBackgroundOutput;

export const zGetFalAiIdeogramV3RemixRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiIdeogramV3RemixRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiIdeogramV3RemixRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV3RemixRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiIdeogramV3RemixData = z.object({
  body: zIdeogramV3RemixInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiIdeogramV3RemixResponse = zQueueStatus;

export const zGetFalAiIdeogramV3RemixRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV3RemixRequestsByRequestIdResponse =
  zIdeogramV3RemixOutput;

export const zGetFalAiIdeogramV3EditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiIdeogramV3EditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiIdeogramV3EditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV3EditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiIdeogramV3EditData = z.object({
  body: zIdeogramV3EditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiIdeogramV3EditResponse = zQueueStatus;

export const zGetFalAiIdeogramV3EditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV3EditRequestsByRequestIdResponse =
  zIdeogramV3EditOutput;

export const zGetFalAiStep1xEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiStep1xEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiStep1xEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiStep1xEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiStep1xEditData = z.object({
  body: zStep1xEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiStep1xEditResponse = zQueueStatus;

export const zGetFalAiStep1xEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiStep1xEditRequestsByRequestIdResponse = zStep1xEditOutput;

export const zGetFalAiImage2SvgRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiImage2SvgRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiImage2SvgRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiImage2SvgRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiImage2SvgData = z.object({
  body: zImage2SvgInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImage2SvgResponse = zQueueStatus;

export const zGetFalAiImage2SvgRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImage2SvgRequestsByRequestIdResponse = zImage2SvgOutput;

export const zGetFalAiUnoRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiUnoRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiUnoRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiUnoRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiUnoData = z.object({
  body: zUnoInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiUnoResponse = zQueueStatus;

export const zGetFalAiUnoRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiUnoRequestsByRequestIdResponse = zUnoOutput;

export const zGetFalAiGptImage1EditImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiGptImage1EditImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiGptImage1EditImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiGptImage1EditImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiGptImage1EditImageData = z.object({
  body: zGptImage1EditImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiGptImage1EditImageResponse = zQueueStatus;

export const zGetFalAiGptImage1EditImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiGptImage1EditImageRequestsByRequestIdResponse =
  zGptImage1EditImageOutput;

export const zGetRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostRundiffusionFalJuggernautFluxLoraInpaintingData = z.object({
  body: zJuggernautFluxLoraInpaintingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostRundiffusionFalJuggernautFluxLoraInpaintingResponse =
  zQueueStatus;

export const zGetRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdResponse =
  zJuggernautFluxLoraInpaintingOutput;

export const zGetFalAiFashnTryonV15RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFashnTryonV15RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFashnTryonV15RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFashnTryonV15RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFashnTryonV15Data = z.object({
  body: zFashnTryonV15Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFashnTryonV15Response = zQueueStatus;

export const zGetFalAiFashnTryonV15RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFashnTryonV15RequestsByRequestIdResponse =
  zFashnTryonV15Output;

export const zGetFalAiPlushifyRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiPlushifyRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiPlushifyRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiPlushifyRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiPlushifyData = z.object({
  body: zPlushifyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPlushifyResponse = zQueueStatus;

export const zGetFalAiPlushifyRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiPlushifyRequestsByRequestIdResponse = zPlushifyOutput;

export const zGetFalAiInstantCharacterRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiInstantCharacterRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiInstantCharacterRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiInstantCharacterRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiInstantCharacterData = z.object({
  body: zInstantCharacterInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiInstantCharacterResponse = zQueueStatus;

export const zGetFalAiInstantCharacterRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiInstantCharacterRequestsByRequestIdResponse =
  zInstantCharacterOutput;

export const zGetFalAiCartoonifyRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiCartoonifyRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiCartoonifyRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiCartoonifyRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiCartoonifyData = z.object({
  body: zCartoonifyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiCartoonifyResponse = zQueueStatus;

export const zGetFalAiCartoonifyRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiCartoonifyRequestsByRequestIdResponse = zCartoonifyOutput;

export const zGetFalAiFinegrainEraserMaskRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFinegrainEraserMaskRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFinegrainEraserMaskRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFinegrainEraserMaskRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFinegrainEraserMaskData = z.object({
  body: zFinegrainEraserMaskInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFinegrainEraserMaskResponse = zQueueStatus;

export const zGetFalAiFinegrainEraserMaskRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFinegrainEraserMaskRequestsByRequestIdResponse =
  zFinegrainEraserMaskOutput;

export const zGetFalAiFinegrainEraserBboxRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFinegrainEraserBboxRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFinegrainEraserBboxRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFinegrainEraserBboxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFinegrainEraserBboxData = z.object({
  body: zFinegrainEraserBboxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFinegrainEraserBboxResponse = zQueueStatus;

export const zGetFalAiFinegrainEraserBboxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFinegrainEraserBboxRequestsByRequestIdResponse =
  zFinegrainEraserBboxOutput;

export const zGetFalAiFinegrainEraserRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFinegrainEraserRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFinegrainEraserRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFinegrainEraserRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFinegrainEraserData = z.object({
  body: zFinegrainEraserInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFinegrainEraserResponse = zQueueStatus;

export const zGetFalAiFinegrainEraserRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFinegrainEraserRequestsByRequestIdResponse =
  zFinegrainEraserOutput;

export const zGetFalAiStarVectorRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiStarVectorRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiStarVectorRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiStarVectorRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiStarVectorData = z.object({
  body: zStarVectorInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiStarVectorResponse = zQueueStatus;

export const zGetFalAiStarVectorRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiStarVectorRequestsByRequestIdResponse = zStarVectorOutput;

export const zGetFalAiGhiblifyRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiGhiblifyRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiGhiblifyRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiGhiblifyRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiGhiblifyData = z.object({
  body: zGhiblifyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiGhiblifyResponse = zQueueStatus;

export const zGetFalAiGhiblifyRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiGhiblifyRequestsByRequestIdResponse = zGhiblifyOutput;

export const zGetFalAiTheraRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiTheraRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiTheraRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiTheraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiTheraData = z.object({
  body: zTheraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiTheraResponse = zQueueStatus;

export const zGetFalAiTheraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiTheraRequestsByRequestIdResponse = zTheraOutput;

export const zGetFalAiMixDehazeNetRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiMixDehazeNetRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiMixDehazeNetRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiMixDehazeNetRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiMixDehazeNetData = z.object({
  body: zMixDehazeNetInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiMixDehazeNetResponse = zQueueStatus;

export const zGetFalAiMixDehazeNetRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiMixDehazeNetRequestsByRequestIdResponse =
  zMixDehazeNetOutput;

export const zGetFalAiGeminiFlashEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiGeminiFlashEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiGeminiFlashEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiGeminiFlashEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiGeminiFlashEditData = z.object({
  body: zGeminiFlashEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiGeminiFlashEditResponse = zQueueStatus;

export const zGetFalAiGeminiFlashEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiGeminiFlashEditRequestsByRequestIdResponse =
  zGeminiFlashEditOutput;

export const zGetFalAiGeminiFlashEditMultiRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiGeminiFlashEditMultiRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiGeminiFlashEditMultiRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiGeminiFlashEditMultiRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiGeminiFlashEditMultiData = z.object({
  body: zGeminiFlashEditMultiInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiGeminiFlashEditMultiResponse = zQueueStatus;

export const zGetFalAiGeminiFlashEditMultiRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiGeminiFlashEditMultiRequestsByRequestIdResponse =
  zGeminiFlashEditMultiOutput;

export const zGetFalAiInvisibleWatermarkRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiInvisibleWatermarkRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiInvisibleWatermarkRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiInvisibleWatermarkRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiInvisibleWatermarkData = z.object({
  body: zInvisibleWatermarkInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiInvisibleWatermarkResponse = zQueueStatus;

export const zGetFalAiInvisibleWatermarkRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiInvisibleWatermarkRequestsByRequestIdResponse =
  zInvisibleWatermarkOutput;

export const zGetRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostRundiffusionFalJuggernautFluxBaseImageToImageData = z.object({
  body: zJuggernautFluxBaseImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostRundiffusionFalJuggernautFluxBaseImageToImageResponse =
  zQueueStatus;

export const zGetRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdResponse =
  zJuggernautFluxBaseImageToImageOutput;

export const zGetRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostRundiffusionFalJuggernautFluxProImageToImageData = z.object({
  body: zJuggernautFluxProImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostRundiffusionFalJuggernautFluxProImageToImageResponse =
  zQueueStatus;

export const zGetRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdResponse =
  zJuggernautFluxProImageToImageOutput;

export const zGetFalAiDocresDewarpRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiDocresDewarpRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiDocresDewarpRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiDocresDewarpRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiDocresDewarpData = z.object({
  body: zDocresDewarpInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiDocresDewarpResponse = zQueueStatus;

export const zGetFalAiDocresDewarpRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiDocresDewarpRequestsByRequestIdResponse =
  zDocresDewarpOutput;

export const zGetFalAiDocresRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiDocresRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiDocresRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiDocresRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiDocresData = z.object({
  body: zDocresInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiDocresResponse = zQueueStatus;

export const zGetFalAiDocresRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiDocresRequestsByRequestIdResponse = zDocresOutput;

export const zGetFalAiSwin2SrRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiSwin2SrRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiSwin2SrRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiSwin2SrRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiSwin2SrData = z.object({
  body: zSwin2SrInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiSwin2SrResponse = zQueueStatus;

export const zGetFalAiSwin2SrRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiSwin2SrRequestsByRequestIdResponse = zSwin2SrOutput;

export const zGetFalAiIdeogramV2aRemixRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiIdeogramV2aRemixRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiIdeogramV2aRemixRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV2aRemixRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiIdeogramV2aRemixData = z.object({
  body: zIdeogramV2aRemixInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiIdeogramV2aRemixResponse = zQueueStatus;

export const zGetFalAiIdeogramV2aRemixRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV2aRemixRequestsByRequestIdResponse =
  zIdeogramV2aRemixOutput;

export const zGetFalAiIdeogramV2aTurboRemixRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiIdeogramV2aTurboRemixRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiIdeogramV2aTurboRemixRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV2aTurboRemixRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiIdeogramV2aTurboRemixData = z.object({
  body: zIdeogramV2aTurboRemixInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiIdeogramV2aTurboRemixResponse = zQueueStatus;

export const zGetFalAiIdeogramV2aTurboRemixRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV2aTurboRemixRequestsByRequestIdResponse =
  zIdeogramV2aTurboRemixOutput;

export const zGetFalAiEvfSamRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiEvfSamRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiEvfSamRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiEvfSamRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiEvfSamData = z.object({
  body: zEvfSamInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiEvfSamResponse = zQueueStatus;

export const zGetFalAiEvfSamRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiEvfSamRequestsByRequestIdResponse = zEvfSamOutput;

export const zGetFalAiDdcolorRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiDdcolorRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiDdcolorRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiDdcolorRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiDdcolorData = z.object({
  body: zDdcolorInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiDdcolorResponse = zQueueStatus;

export const zGetFalAiDdcolorRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiDdcolorRequestsByRequestIdResponse = zDdcolorOutput;

export const zGetFalAiSam2AutoSegmentRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiSam2AutoSegmentRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiSam2AutoSegmentRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiSam2AutoSegmentRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiSam2AutoSegmentData = z.object({
  body: zSam2AutoSegmentInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiSam2AutoSegmentResponse = zQueueStatus;

export const zGetFalAiSam2AutoSegmentRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiSam2AutoSegmentRequestsByRequestIdResponse =
  zSam2AutoSegmentOutput;

export const zGetFalAiDrctSuperResolutionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiDrctSuperResolutionRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiDrctSuperResolutionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiDrctSuperResolutionRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiDrctSuperResolutionData = z.object({
  body: zDrctSuperResolutionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiDrctSuperResolutionResponse = zQueueStatus;

export const zGetFalAiDrctSuperResolutionRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiDrctSuperResolutionRequestsByRequestIdResponse =
  zDrctSuperResolutionOutput;

export const zGetFalAiNafnetDeblurRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiNafnetDeblurRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiNafnetDeblurRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiNafnetDeblurRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiNafnetDeblurData = z.object({
  body: zNafnetDeblurInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiNafnetDeblurResponse = zQueueStatus;

export const zGetFalAiNafnetDeblurRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiNafnetDeblurRequestsByRequestIdResponse =
  zNafnetDeblurOutput;

export const zGetFalAiNafnetDenoiseRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiNafnetDenoiseRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiNafnetDenoiseRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiNafnetDenoiseRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiNafnetDenoiseData = z.object({
  body: zNafnetDenoiseInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiNafnetDenoiseResponse = zQueueStatus;

export const zGetFalAiNafnetDenoiseRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiNafnetDenoiseRequestsByRequestIdResponse =
  zNafnetDenoiseOutput;

export const zGetFalAiPostProcessingRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiPostProcessingRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiPostProcessingRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiPostProcessingData = z.object({
  body: zPostProcessingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPostProcessingResponse = zQueueStatus;

export const zGetFalAiPostProcessingRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingRequestsByRequestIdResponse =
  zPostProcessingOutput;

export const zGetFalAiFloweditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFloweditRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiFloweditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFloweditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFloweditData = z.object({
  body: zFloweditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFloweditResponse = zQueueStatus;

export const zGetFalAiFloweditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFloweditRequestsByRequestIdResponse = zFloweditOutput;

export const zGetFalAiBenV2ImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiBenV2ImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiBenV2ImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiBenV2ImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiBenV2ImageData = z.object({
  body: zBenV2ImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiBenV2ImageResponse = zQueueStatus;

export const zGetFalAiBenV2ImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiBenV2ImageRequestsByRequestIdResponse = zBenV2ImageOutput;

export const zGetFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFluxControlLoraCannyImageToImageData = z.object({
  body: zFluxControlLoraCannyImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxControlLoraCannyImageToImageResponse = zQueueStatus;

export const zGetFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdResponse =
  zFluxControlLoraCannyImageToImageOutput;

export const zGetFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFluxControlLoraDepthImageToImageData = z.object({
  body: zFluxControlLoraDepthImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxControlLoraDepthImageToImageResponse = zQueueStatus;

export const zGetFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdResponse =
  zFluxControlLoraDepthImageToImageOutput;

export const zGetFalAiIdeogramUpscaleRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiIdeogramUpscaleRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiIdeogramUpscaleRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramUpscaleRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiIdeogramUpscaleData = z.object({
  body: zIdeogramUpscaleInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiIdeogramUpscaleResponse = zQueueStatus;

export const zGetFalAiIdeogramUpscaleRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramUpscaleRequestsByRequestIdResponse =
  zIdeogramUpscaleOutput;

export const zGetFalAiCodeformerRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiCodeformerRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiCodeformerRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiCodeformerRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiCodeformerData = z.object({
  body: zCodeformerInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiCodeformerResponse = zQueueStatus;

export const zGetFalAiCodeformerRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiCodeformerRequestsByRequestIdResponse = zCodeformerOutput;

export const zGetFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiKlingV15KolorsVirtualTryOnData = z.object({
  body: zKlingV15KolorsVirtualTryOnInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiKlingV15KolorsVirtualTryOnResponse = zQueueStatus;

export const zGetFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdResponse =
  zKlingV15KolorsVirtualTryOnOutput;

export const zGetFalAiFluxLoraCannyRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxLoraCannyRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxLoraCannyRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxLoraCannyRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxLoraCannyData = z.object({
  body: zFluxLoraCannyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxLoraCannyResponse = zQueueStatus;

export const zGetFalAiFluxLoraCannyRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxLoraCannyRequestsByRequestIdResponse =
  zFluxLoraCannyOutput;

export const zGetFalAiFluxProV1FillFinetunedRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxProV1FillFinetunedRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxProV1FillFinetunedRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProV1FillFinetunedRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFluxProV1FillFinetunedData = z.object({
  body: zFluxProV1FillFinetunedInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxProV1FillFinetunedResponse = zQueueStatus;

export const zGetFalAiFluxProV1FillFinetunedRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxProV1FillFinetunedRequestsByRequestIdResponse =
  zFluxProV1FillFinetunedOutput;

export const zGetFalAiMoondreamNextDetectionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiMoondreamNextDetectionRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiMoondreamNextDetectionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiMoondreamNextDetectionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiMoondreamNextDetectionData = z.object({
  body: zMoondreamNextDetectionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiMoondreamNextDetectionResponse = zQueueStatus;

export const zGetFalAiMoondreamNextDetectionRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiMoondreamNextDetectionRequestsByRequestIdResponse =
  zMoondreamNextDetectionOutput;

export const zGetFalAiBriaEraserRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiBriaEraserRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiBriaEraserRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiBriaEraserRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiBriaEraserData = z.object({
  body: zBriaEraserInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiBriaEraserResponse = zQueueStatus;

export const zGetFalAiBriaEraserRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiBriaEraserRequestsByRequestIdResponse = zBriaEraserOutput;

export const zGetFalAiBriaExpandRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiBriaExpandRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiBriaExpandRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiBriaExpandRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiBriaExpandData = z.object({
  body: zBriaExpandInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiBriaExpandResponse = zQueueStatus;

export const zGetFalAiBriaExpandRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiBriaExpandRequestsByRequestIdResponse = zBriaExpandOutput;

export const zGetFalAiBriaGenfillRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiBriaGenfillRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiBriaGenfillRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiBriaGenfillRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiBriaGenfillData = z.object({
  body: zBriaGenfillInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiBriaGenfillResponse = zQueueStatus;

export const zGetFalAiBriaGenfillRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiBriaGenfillRequestsByRequestIdResponse =
  zBriaGenfillOutput;

export const zGetFalAiBriaProductShotRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiBriaProductShotRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiBriaProductShotRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiBriaProductShotRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiBriaProductShotData = z.object({
  body: zBriaProductShotInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiBriaProductShotResponse = zQueueStatus;

export const zGetFalAiBriaProductShotRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiBriaProductShotRequestsByRequestIdResponse =
  zBriaProductShotOutput;

export const zGetFalAiBriaBackgroundRemoveRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiBriaBackgroundRemoveRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiBriaBackgroundRemoveRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiBriaBackgroundRemoveRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiBriaBackgroundRemoveData = z.object({
  body: zBriaBackgroundRemoveInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiBriaBackgroundRemoveResponse = zQueueStatus;

export const zGetFalAiBriaBackgroundRemoveRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiBriaBackgroundRemoveRequestsByRequestIdResponse =
  zBriaBackgroundRemoveOutput;

export const zGetFalAiBriaBackgroundReplaceRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiBriaBackgroundReplaceRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiBriaBackgroundReplaceRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiBriaBackgroundReplaceRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiBriaBackgroundReplaceData = z.object({
  body: zBriaBackgroundReplaceInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiBriaBackgroundReplaceResponse = zQueueStatus;

export const zGetFalAiBriaBackgroundReplaceRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiBriaBackgroundReplaceRequestsByRequestIdResponse =
  zBriaBackgroundReplaceOutput;

export const zGetFalAiFluxLoraFillRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxLoraFillRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxLoraFillRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxLoraFillRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxLoraFillData = z.object({
  body: zFluxLoraFillInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxLoraFillResponse = zQueueStatus;

export const zGetFalAiFluxLoraFillRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxLoraFillRequestsByRequestIdResponse =
  zFluxLoraFillOutput;

export const zGetFalAiCatVtonRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiCatVtonRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiCatVtonRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiCatVtonRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiCatVtonData = z.object({
  body: zCatVtonInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiCatVtonResponse = zQueueStatus;

export const zGetFalAiCatVtonRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiCatVtonRequestsByRequestIdResponse = zCatVtonOutput;

export const zGetFalAiLeffaPoseTransferRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiLeffaPoseTransferRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiLeffaPoseTransferRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiLeffaPoseTransferRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiLeffaPoseTransferData = z.object({
  body: zLeffaPoseTransferInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiLeffaPoseTransferResponse = zQueueStatus;

export const zGetFalAiLeffaPoseTransferRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiLeffaPoseTransferRequestsByRequestIdResponse =
  zLeffaPoseTransferOutput;

export const zGetFalAiLeffaVirtualTryonRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiLeffaVirtualTryonRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiLeffaVirtualTryonRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiLeffaVirtualTryonRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiLeffaVirtualTryonData = z.object({
  body: zLeffaVirtualTryonInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiLeffaVirtualTryonResponse = zQueueStatus;

export const zGetFalAiLeffaVirtualTryonRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiLeffaVirtualTryonRequestsByRequestIdResponse =
  zLeffaVirtualTryonOutput;

export const zGetFalAiIdeogramV2EditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiIdeogramV2EditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiIdeogramV2EditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV2EditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiIdeogramV2EditData = z.object({
  body: zIdeogramV2EditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiIdeogramV2EditResponse = zQueueStatus;

export const zGetFalAiIdeogramV2EditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV2EditRequestsByRequestIdResponse =
  zIdeogramV2EditOutput;

export const zGetFalAiIdeogramV2RemixRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiIdeogramV2RemixRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiIdeogramV2RemixRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV2RemixRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiIdeogramV2RemixData = z.object({
  body: zIdeogramV2RemixInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiIdeogramV2RemixResponse = zQueueStatus;

export const zGetFalAiIdeogramV2RemixRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV2RemixRequestsByRequestIdResponse =
  zIdeogramV2RemixOutput;

export const zGetFalAiIdeogramV2TurboEditRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiIdeogramV2TurboEditRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiIdeogramV2TurboEditRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV2TurboEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiIdeogramV2TurboEditData = z.object({
  body: zIdeogramV2TurboEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiIdeogramV2TurboEditResponse = zQueueStatus;

export const zGetFalAiIdeogramV2TurboEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV2TurboEditRequestsByRequestIdResponse =
  zIdeogramV2TurboEditOutput;

export const zGetFalAiIdeogramV2TurboRemixRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiIdeogramV2TurboRemixRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiIdeogramV2TurboRemixRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV2TurboRemixRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiIdeogramV2TurboRemixData = z.object({
  body: zIdeogramV2TurboRemixInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiIdeogramV2TurboRemixResponse = zQueueStatus;

export const zGetFalAiIdeogramV2TurboRemixRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV2TurboRemixRequestsByRequestIdResponse =
  zIdeogramV2TurboRemixOutput;

export const zGetFalAiFluxSchnellReduxRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxSchnellReduxRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxSchnellReduxRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxSchnellReduxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxSchnellReduxData = z.object({
  body: zFluxSchnellReduxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxSchnellReduxResponse = zQueueStatus;

export const zGetFalAiFluxSchnellReduxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxSchnellReduxRequestsByRequestIdResponse =
  zFluxSchnellReduxOutput;

export const zGetFalAiFluxProV11ReduxRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxProV11ReduxRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxProV11ReduxRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProV11ReduxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxProV11ReduxData = z.object({
  body: zFluxProV11ReduxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxProV11ReduxResponse = zQueueStatus;

export const zGetFalAiFluxProV11ReduxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxProV11ReduxRequestsByRequestIdResponse =
  zFluxProV11ReduxOutput;

export const zGetFalAiFluxLoraDepthRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxLoraDepthRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxLoraDepthRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxLoraDepthRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxLoraDepthData = z.object({
  body: zFluxLoraDepthInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxLoraDepthResponse = zQueueStatus;

export const zGetFalAiFluxLoraDepthRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxLoraDepthRequestsByRequestIdResponse =
  zFluxLoraDepthOutput;

export const zGetFalAiFluxProV11UltraReduxRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxProV11UltraReduxRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxProV11UltraReduxRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProV11UltraReduxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxProV11UltraReduxData = z.object({
  body: zFluxProV11UltraReduxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxProV11UltraReduxResponse = zQueueStatus;

export const zGetFalAiFluxProV11UltraReduxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxProV11UltraReduxRequestsByRequestIdResponse =
  zFluxProV11UltraReduxOutput;

export const zGetFalAiFluxProV1FillRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxProV1FillRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxProV1FillRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProV1FillRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxProV1FillData = z.object({
  body: zFluxProV1FillInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxProV1FillResponse = zQueueStatus;

export const zGetFalAiFluxProV1FillRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxProV1FillRequestsByRequestIdResponse =
  zFluxProV1FillOutput;

export const zGetFalAiFluxDevReduxRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxDevReduxRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxDevReduxRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxDevReduxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxDevReduxData = z.object({
  body: zFluxDevReduxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxDevReduxResponse = zQueueStatus;

export const zGetFalAiFluxDevReduxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxDevReduxRequestsByRequestIdResponse =
  zFluxDevReduxOutput;

export const zGetFalAiKolorsImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiKolorsImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiKolorsImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiKolorsImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiKolorsImageToImageData = z.object({
  body: zKolorsImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiKolorsImageToImageResponse = zQueueStatus;

export const zGetFalAiKolorsImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiKolorsImageToImageRequestsByRequestIdResponse =
  zKolorsImageToImageOutput;

export const zGetFalAiIclightV2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiIclightV2RequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiIclightV2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiIclightV2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiIclightV2Data = z.object({
  body: zIclightV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiIclightV2Response = zQueueStatus;

export const zGetFalAiIclightV2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiIclightV2RequestsByRequestIdResponse = zIclightV2Output;

export const zGetFalAiFluxDifferentialDiffusionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxDifferentialDiffusionRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxDifferentialDiffusionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxDifferentialDiffusionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFluxDifferentialDiffusionData = z.object({
  body: zFluxDifferentialDiffusionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxDifferentialDiffusionResponse = zQueueStatus;

export const zGetFalAiFluxDifferentialDiffusionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFluxDifferentialDiffusionRequestsByRequestIdResponse =
  zFluxDifferentialDiffusionOutput;

export const zGetFalAiFluxPulidRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxPulidRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiFluxPulidRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxPulidRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxPulidData = z.object({
  body: zFluxPulidInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxPulidResponse = zQueueStatus;

export const zGetFalAiFluxPulidRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxPulidRequestsByRequestIdResponse = zFluxPulidOutput;

export const zGetFalAiBirefnetV2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiBirefnetV2RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiBirefnetV2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiBirefnetV2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiBirefnetV2Data = z.object({
  body: zBirefnetV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiBirefnetV2Response = zQueueStatus;

export const zGetFalAiBirefnetV2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiBirefnetV2RequestsByRequestIdResponse = zBirefnetV2Output;

export const zGetFalAiLivePortraitImageRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiLivePortraitImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiLivePortraitImageRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiLivePortraitImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiLivePortraitImageData = z.object({
  body: zLivePortraitImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiLivePortraitImageResponse = zQueueStatus;

export const zGetFalAiLivePortraitImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiLivePortraitImageRequestsByRequestIdResponse =
  zLivePortraitImageOutput;

export const zGetFalAiFluxGeneralRfInversionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxGeneralRfInversionRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxGeneralRfInversionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxGeneralRfInversionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFluxGeneralRfInversionData = z.object({
  body: zFluxGeneralRfInversionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxGeneralRfInversionResponse = zQueueStatus;

export const zGetFalAiFluxGeneralRfInversionRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxGeneralRfInversionRequestsByRequestIdResponse =
  zFluxGeneralRfInversionOutput;

export const zGetFalAiImagePreprocessorsHedRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImagePreprocessorsHedRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImagePreprocessorsHedRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImagePreprocessorsHedRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiImagePreprocessorsHedData = z.object({
  body: zImagePreprocessorsHedInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImagePreprocessorsHedResponse = zQueueStatus;

export const zGetFalAiImagePreprocessorsHedRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImagePreprocessorsHedRequestsByRequestIdResponse =
  zImagePreprocessorsHedOutput;

export const zGetFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImagePreprocessorsDepthAnythingV2Data = z.object({
  body: zImagePreprocessorsDepthAnythingV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImagePreprocessorsDepthAnythingV2Response = zQueueStatus;

export const zGetFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdResponse =
  zImagePreprocessorsDepthAnythingV2Output;

export const zGetFalAiImagePreprocessorsScribbleRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImagePreprocessorsScribbleRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImagePreprocessorsScribbleRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImagePreprocessorsScribbleRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImagePreprocessorsScribbleData = z.object({
  body: zImagePreprocessorsScribbleInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImagePreprocessorsScribbleResponse = zQueueStatus;

export const zGetFalAiImagePreprocessorsScribbleRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImagePreprocessorsScribbleRequestsByRequestIdResponse =
  zImagePreprocessorsScribbleOutput;

export const zGetFalAiImagePreprocessorsMlsdRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImagePreprocessorsMlsdRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImagePreprocessorsMlsdRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImagePreprocessorsMlsdRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImagePreprocessorsMlsdData = z.object({
  body: zImagePreprocessorsMlsdInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImagePreprocessorsMlsdResponse = zQueueStatus;

export const zGetFalAiImagePreprocessorsMlsdRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImagePreprocessorsMlsdRequestsByRequestIdResponse =
  zImagePreprocessorsMlsdOutput;

export const zGetFalAiImagePreprocessorsSamRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImagePreprocessorsSamRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImagePreprocessorsSamRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImagePreprocessorsSamRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiImagePreprocessorsSamData = z.object({
  body: zImagePreprocessorsSamInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImagePreprocessorsSamResponse = zQueueStatus;

export const zGetFalAiImagePreprocessorsSamRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImagePreprocessorsSamRequestsByRequestIdResponse =
  zImagePreprocessorsSamOutput;

export const zGetFalAiImagePreprocessorsMidasRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImagePreprocessorsMidasRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImagePreprocessorsMidasRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImagePreprocessorsMidasRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImagePreprocessorsMidasData = z.object({
  body: zImagePreprocessorsMidasInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImagePreprocessorsMidasResponse = zQueueStatus;

export const zGetFalAiImagePreprocessorsMidasRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * Result of the request.
 */
export const zGetFalAiImagePreprocessorsMidasRequestsByRequestIdResponse =
  zImagePreprocessorsMidasOutput;

export const zGetFalAiImagePreprocessorsTeedRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImagePreprocessorsTeedRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImagePreprocessorsTeedRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImagePreprocessorsTeedRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImagePreprocessorsTeedData = z.object({
  body: zImagePreprocessorsTeedInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImagePreprocessorsTeedResponse = zQueueStatus;

export const zGetFalAiImagePreprocessorsTeedRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImagePreprocessorsTeedRequestsByRequestIdResponse =
  zImagePreprocessorsTeedOutput;

export const zGetFalAiImagePreprocessorsLineartRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImagePreprocessorsLineartRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImagePreprocessorsLineartRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImagePreprocessorsLineartRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImagePreprocessorsLineartData = z.object({
  body: zImagePreprocessorsLineartInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImagePreprocessorsLineartResponse = zQueueStatus;

export const zGetFalAiImagePreprocessorsLineartRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiImagePreprocessorsLineartRequestsByRequestIdResponse =
  zImagePreprocessorsLineartOutput;

export const zGetFalAiImagePreprocessorsZoeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImagePreprocessorsZoeRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImagePreprocessorsZoeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImagePreprocessorsZoeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiImagePreprocessorsZoeData = z.object({
  body: zImagePreprocessorsZoeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImagePreprocessorsZoeResponse = zQueueStatus;

export const zGetFalAiImagePreprocessorsZoeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImagePreprocessorsZoeRequestsByRequestIdResponse =
  zImagePreprocessorsZoeOutput;

export const zGetFalAiImagePreprocessorsPidiRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImagePreprocessorsPidiRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImagePreprocessorsPidiRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImagePreprocessorsPidiRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImagePreprocessorsPidiData = z.object({
  body: zImagePreprocessorsPidiInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImagePreprocessorsPidiResponse = zQueueStatus;

export const zGetFalAiImagePreprocessorsPidiRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImagePreprocessorsPidiRequestsByRequestIdResponse =
  zImagePreprocessorsPidiOutput;

export const zGetFalAiSam2ImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiSam2ImageRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiSam2ImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiSam2ImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiSam2ImageData = z.object({
  body: zSam2ImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiSam2ImageResponse = zQueueStatus;

export const zGetFalAiSam2ImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiSam2ImageRequestsByRequestIdResponse = zSam2ImageOutput;

export const zGetFalAiFluxGeneralInpaintingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxGeneralInpaintingRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxGeneralInpaintingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxGeneralInpaintingRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxGeneralInpaintingData = z.object({
  body: zFluxGeneralInpaintingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxGeneralInpaintingResponse = zQueueStatus;

export const zGetFalAiFluxGeneralInpaintingRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxGeneralInpaintingRequestsByRequestIdResponse =
  zFluxGeneralInpaintingOutput;

export const zGetFalAiFluxGeneralImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxGeneralImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxGeneralImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxGeneralImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFluxGeneralImageToImageData = z.object({
  body: zFluxGeneralImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxGeneralImageToImageResponse = zQueueStatus;

export const zGetFalAiFluxGeneralImageToImageRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * Result of the request.
 */
export const zGetFalAiFluxGeneralImageToImageRequestsByRequestIdResponse =
  zFluxGeneralImageToImageOutput;

export const zGetFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFluxGeneralDifferentialDiffusionData = z.object({
  body: zFluxGeneralDifferentialDiffusionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxGeneralDifferentialDiffusionResponse = zQueueStatus;

export const zGetFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdResponse =
  zFluxGeneralDifferentialDiffusionOutput;

export const zGetFalAiFluxLoraImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxLoraImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxLoraImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxLoraImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxLoraImageToImageData = z.object({
  body: zFluxLoraImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxLoraImageToImageResponse = zQueueStatus;

export const zGetFalAiFluxLoraImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxLoraImageToImageRequestsByRequestIdResponse =
  zFluxLoraImageToImageOutput;

export const zGetFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiSdxlControlnetUnionInpaintingData = z.object({
  body: zSdxlControlnetUnionInpaintingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiSdxlControlnetUnionInpaintingResponse = zQueueStatus;

export const zGetFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdResponse =
  zSdxlControlnetUnionInpaintingOutput;

export const zGetFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiSdxlControlnetUnionImageToImageData = z.object({
  body: zSdxlControlnetUnionImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiSdxlControlnetUnionImageToImageResponse = zQueueStatus;

export const zGetFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdResponse =
  zSdxlControlnetUnionImageToImageOutput;

export const zGetFalAiEra3dRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiEra3dRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiEra3dRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiEra3dRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiEra3dData = z.object({
  body: zEra3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiEra3dResponse = zQueueStatus;

export const zGetFalAiEra3dRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiEra3dRequestsByRequestIdResponse = zEra3dOutput;

export const zGetFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFlorence2LargeDenseRegionCaptionData = z.object({
  body: zFlorence2LargeDenseRegionCaptionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlorence2LargeDenseRegionCaptionResponse = zQueueStatus;

export const zGetFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdResponse =
  zFlorence2LargeDenseRegionCaptionOutput;

export const zGetFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFlorence2LargeReferringExpressionSegmentationData =
  z.object({
    body: zFlorence2LargeReferringExpressionSegmentationInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  });

/**
 * The request status.
 */
export const zPostFalAiFlorence2LargeReferringExpressionSegmentationResponse =
  zQueueStatus;

export const zGetFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdResponse =
  zFlorence2LargeReferringExpressionSegmentationOutput;

export const zGetFalAiFlorence2LargeObjectDetectionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlorence2LargeObjectDetectionRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlorence2LargeObjectDetectionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlorence2LargeObjectDetectionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFlorence2LargeObjectDetectionData = z.object({
  body: zFlorence2LargeObjectDetectionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlorence2LargeObjectDetectionResponse = zQueueStatus;

export const zGetFalAiFlorence2LargeObjectDetectionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFlorence2LargeObjectDetectionRequestsByRequestIdResponse =
  zFlorence2LargeObjectDetectionOutput;

export const zGetFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFlorence2LargeOpenVocabularyDetectionData = z.object({
  body: zFlorence2LargeOpenVocabularyDetectionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlorence2LargeOpenVocabularyDetectionResponse =
  zQueueStatus;

export const zGetFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdResponse =
  zFlorence2LargeOpenVocabularyDetectionOutput;

export const zGetFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFlorence2LargeCaptionToPhraseGroundingData = z.object({
  body: zFlorence2LargeCaptionToPhraseGroundingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlorence2LargeCaptionToPhraseGroundingResponse =
  zQueueStatus;

export const zGetFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdResponse =
  zFlorence2LargeCaptionToPhraseGroundingOutput;

export const zGetFalAiFlorence2LargeRegionProposalRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlorence2LargeRegionProposalRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlorence2LargeRegionProposalRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlorence2LargeRegionProposalRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFlorence2LargeRegionProposalData = z.object({
  body: zFlorence2LargeRegionProposalInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlorence2LargeRegionProposalResponse = zQueueStatus;

export const zGetFalAiFlorence2LargeRegionProposalRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFlorence2LargeRegionProposalRequestsByRequestIdResponse =
  zFlorence2LargeRegionProposalOutput;

export const zGetFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFlorence2LargeOcrWithRegionData = z.object({
  body: zFlorence2LargeOcrWithRegionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlorence2LargeOcrWithRegionResponse = zQueueStatus;

export const zGetFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdResponse =
  zFlorence2LargeOcrWithRegionOutput;

export const zGetFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFlorence2LargeRegionToSegmentationData = z.object({
  body: zFlorence2LargeRegionToSegmentationInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlorence2LargeRegionToSegmentationResponse =
  zQueueStatus;

export const zGetFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdResponse =
  zFlorence2LargeRegionToSegmentationOutput;

export const zGetFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiStableDiffusionV3MediumImageToImageData = z.object({
  body: zStableDiffusionV3MediumImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiStableDiffusionV3MediumImageToImageResponse =
  zQueueStatus;

export const zGetFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdResponse =
  zStableDiffusionV3MediumImageToImageOutput;

export const zGetFalAiDwposeRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiDwposeRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiDwposeRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiDwposeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiDwposeData = z.object({
  body: zDwposeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiDwposeResponse = zQueueStatus;

export const zGetFalAiDwposeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiDwposeRequestsByRequestIdResponse = zDwposeOutput;

export const zGetFalAiSd15DepthControlnetRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiSd15DepthControlnetRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiSd15DepthControlnetRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiSd15DepthControlnetRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiSd15DepthControlnetData = z.object({
  body: zSd15DepthControlnetInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiSd15DepthControlnetResponse = zQueueStatus;

export const zGetFalAiSd15DepthControlnetRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiSd15DepthControlnetRequestsByRequestIdResponse =
  zSd15DepthControlnetOutput;

export const zGetFalAiCcsrRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiCcsrRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiCcsrRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiCcsrRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiCcsrData = z.object({
  body: zCcsrInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiCcsrResponse = zQueueStatus;

export const zGetFalAiCcsrRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiCcsrRequestsByRequestIdResponse = zCcsrOutput;

export const zGetFalAiOmniZeroRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiOmniZeroRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiOmniZeroRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiOmniZeroRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiOmniZeroData = z.object({
  body: zOmniZeroInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiOmniZeroResponse = zQueueStatus;

export const zGetFalAiOmniZeroRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiOmniZeroRequestsByRequestIdResponse = zOmniZeroOutput;

export const zGetFalAiIpAdapterFaceIdRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiIpAdapterFaceIdRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiIpAdapterFaceIdRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiIpAdapterFaceIdRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiIpAdapterFaceIdData = z.object({
  body: zIpAdapterFaceIdInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiIpAdapterFaceIdResponse = zQueueStatus;

export const zGetFalAiIpAdapterFaceIdRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiIpAdapterFaceIdRequestsByRequestIdResponse =
  zIpAdapterFaceIdOutput;

export const zGetFalAiLoraInpaintRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiLoraInpaintRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiLoraInpaintRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiLoraInpaintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiLoraInpaintData = z.object({
  body: zLoraInpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiLoraInpaintResponse = zQueueStatus;

export const zGetFalAiLoraInpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiLoraInpaintRequestsByRequestIdResponse =
  zLoraInpaintOutput;

export const zGetFalAiLoraImageToImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiLoraImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiLoraImageToImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiLoraImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiLoraImageToImageData = z.object({
  body: zLoraImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiLoraImageToImageResponse = zQueueStatus;

export const zGetFalAiLoraImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiLoraImageToImageRequestsByRequestIdResponse =
  zLoraImageToImageOutput;

export const zGetFalAiFastSdxlImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFastSdxlImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFastSdxlImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFastSdxlImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFastSdxlImageToImageData = z.object({
  body: zFastSdxlImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFastSdxlImageToImageResponse = zQueueStatus;

export const zGetFalAiFastSdxlImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFastSdxlImageToImageRequestsByRequestIdResponse =
  zFastSdxlImageToImageOutput;

export const zGetFalAiFastSdxlInpaintingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFastSdxlInpaintingRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFastSdxlInpaintingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFastSdxlInpaintingRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFastSdxlInpaintingData = z.object({
  body: zFastSdxlInpaintingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFastSdxlInpaintingResponse = zQueueStatus;

export const zGetFalAiFastSdxlInpaintingRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFastSdxlInpaintingRequestsByRequestIdResponse =
  zFastSdxlInpaintingOutput;

export const zGetFalAiFaceToStickerRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFaceToStickerRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFaceToStickerRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFaceToStickerRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFaceToStickerData = z.object({
  body: zFaceToStickerInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFaceToStickerResponse = zQueueStatus;

export const zGetFalAiFaceToStickerRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFaceToStickerRequestsByRequestIdResponse =
  zFaceToStickerOutput;

export const zGetFalAiPhotomakerRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiPhotomakerRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiPhotomakerRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiPhotomakerRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiPhotomakerData = z.object({
  body: zPhotomakerInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPhotomakerResponse = zQueueStatus;

export const zGetFalAiPhotomakerRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiPhotomakerRequestsByRequestIdResponse = zPhotomakerOutput;

export const zGetFalAiCreativeUpscalerRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiCreativeUpscalerRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiCreativeUpscalerRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiCreativeUpscalerRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiCreativeUpscalerData = z.object({
  body: zCreativeUpscalerInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiCreativeUpscalerResponse = zQueueStatus;

export const zGetFalAiCreativeUpscalerRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiCreativeUpscalerRequestsByRequestIdResponse =
  zCreativeUpscalerOutput;

export const zGetFalAiBirefnetRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiBirefnetRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiBirefnetRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiBirefnetRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiBirefnetData = z.object({
  body: zBirefnetInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiBirefnetResponse = zQueueStatus;

export const zGetFalAiBirefnetRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiBirefnetRequestsByRequestIdResponse = zBirefnetOutput;

export const zGetFalAiPlaygroundV25ImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiPlaygroundV25ImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiPlaygroundV25ImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiPlaygroundV25ImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiPlaygroundV25ImageToImageData = z.object({
  body: zPlaygroundV25ImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPlaygroundV25ImageToImageResponse = zQueueStatus;

export const zGetFalAiPlaygroundV25ImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiPlaygroundV25ImageToImageRequestsByRequestIdResponse =
  zPlaygroundV25ImageToImageOutput;

export const zGetFalAiFastLightningSdxlImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFastLightningSdxlImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFastLightningSdxlImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFastLightningSdxlImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFastLightningSdxlImageToImageData = z.object({
  body: zFastLightningSdxlImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFastLightningSdxlImageToImageResponse = zQueueStatus;

export const zGetFalAiFastLightningSdxlImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFastLightningSdxlImageToImageRequestsByRequestIdResponse =
  zFastLightningSdxlImageToImageOutput;

export const zGetFalAiFastLightningSdxlInpaintingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFastLightningSdxlInpaintingRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFastLightningSdxlInpaintingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFastLightningSdxlInpaintingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFastLightningSdxlInpaintingData = z.object({
  body: zFastLightningSdxlInpaintingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFastLightningSdxlInpaintingResponse = zQueueStatus;

export const zGetFalAiFastLightningSdxlInpaintingRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFastLightningSdxlInpaintingRequestsByRequestIdResponse =
  zFastLightningSdxlInpaintingOutput;

export const zGetFalAiPlaygroundV25InpaintingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiPlaygroundV25InpaintingRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiPlaygroundV25InpaintingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiPlaygroundV25InpaintingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiPlaygroundV25InpaintingData = z.object({
  body: zPlaygroundV25InpaintingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPlaygroundV25InpaintingResponse = zQueueStatus;

export const zGetFalAiPlaygroundV25InpaintingRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * Result of the request.
 */
export const zGetFalAiPlaygroundV25InpaintingRequestsByRequestIdResponse =
  zPlaygroundV25InpaintingOutput;

export const zGetFalAiFastLcmDiffusionInpaintingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFastLcmDiffusionInpaintingRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFastLcmDiffusionInpaintingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFastLcmDiffusionInpaintingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFastLcmDiffusionInpaintingData = z.object({
  body: zFastLcmDiffusionInpaintingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFastLcmDiffusionInpaintingResponse = zQueueStatus;

export const zGetFalAiFastLcmDiffusionInpaintingRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFastLcmDiffusionInpaintingRequestsByRequestIdResponse =
  zFastLcmDiffusionInpaintingOutput;

export const zGetFalAiFastLcmDiffusionImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFastLcmDiffusionImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFastLcmDiffusionImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFastLcmDiffusionImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFastLcmDiffusionImageToImageData = z.object({
  body: zFastLcmDiffusionImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFastLcmDiffusionImageToImageResponse = zQueueStatus;

export const zGetFalAiFastLcmDiffusionImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFastLcmDiffusionImageToImageRequestsByRequestIdResponse =
  zFastLcmDiffusionImageToImageOutput;

export const zGetFalAiRetoucherRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiRetoucherRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiRetoucherRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiRetoucherRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiRetoucherData = z.object({
  body: zRetoucherInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiRetoucherResponse = zQueueStatus;

export const zGetFalAiRetoucherRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiRetoucherRequestsByRequestIdResponse = zRetoucherOutput;

export const zGetFalAiImageutilsDepthRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiImageutilsDepthRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageutilsDepthRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiImageutilsDepthRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiImageutilsDepthData = z.object({
  body: zImageutilsDepthInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageutilsDepthResponse = zQueueStatus;

export const zGetFalAiImageutilsDepthRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImageutilsDepthRequestsByRequestIdResponse =
  zImageutilsDepthOutput;

export const zGetFalAiImageutilsMarigoldDepthRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImageutilsMarigoldDepthRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageutilsMarigoldDepthRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImageutilsMarigoldDepthRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiImageutilsMarigoldDepthData = z.object({
  body: zImageutilsMarigoldDepthInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageutilsMarigoldDepthResponse = zQueueStatus;

export const zGetFalAiImageutilsMarigoldDepthRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * Result of the request.
 */
export const zGetFalAiImageutilsMarigoldDepthRequestsByRequestIdResponse =
  zImageutilsMarigoldDepthOutput;

export const zGetFalAiPulidRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiPulidRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiPulidRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiPulidRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiPulidData = z.object({
  body: zPulidInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPulidResponse = zQueueStatus;

export const zGetFalAiPulidRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiPulidRequestsByRequestIdResponse = zPulidOutput;

export const zGetFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFastSdxlControlnetCannyImageToImageData = z.object({
  body: zFastSdxlControlnetCannyImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFastSdxlControlnetCannyImageToImageResponse =
  zQueueStatus;

export const zGetFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdResponse =
  zFastSdxlControlnetCannyImageToImageOutput;

export const zGetFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFastSdxlControlnetCannyInpaintingData = z.object({
  body: zFastSdxlControlnetCannyInpaintingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFastSdxlControlnetCannyInpaintingResponse = zQueueStatus;

export const zGetFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdResponse =
  zFastSdxlControlnetCannyInpaintingOutput;

export const zGetFalAiLcmSd15I2iRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiLcmSd15I2iRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiLcmSd15I2iRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiLcmSd15I2iRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiLcmSd15I2iData = z.object({
  body: zLcmSd15I2iInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiLcmSd15I2iResponse = zQueueStatus;

export const zGetFalAiLcmSd15I2iRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiLcmSd15I2iRequestsByRequestIdResponse = zLcmSd15I2iOutput;

export const zGetFalAiInpaintRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiInpaintRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiInpaintRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiInpaintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiInpaintData = z.object({
  body: zInpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiInpaintResponse = zQueueStatus;

export const zGetFalAiInpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiInpaintRequestsByRequestIdResponse = zInpaintOutput;

export const zGetFalAiEsrganRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiEsrganRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiEsrganRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiEsrganRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiEsrganData = z.object({
  body: zEsrganInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiEsrganResponse = zQueueStatus;

export const zGetFalAiEsrganRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiEsrganRequestsByRequestIdResponse = zEsrganOutput;

export const zGetFalAiImageutilsRembgRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiImageutilsRembgRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImageutilsRembgRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiImageutilsRembgRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiImageutilsRembgData = z.object({
  body: zImageutilsRembgInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImageutilsRembgResponse = zQueueStatus;

export const zGetFalAiImageutilsRembgRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImageutilsRembgRequestsByRequestIdResponse =
  zImageutilsRembgOutput;

export const zGetFalAiImagen4PreviewRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiImagen4PreviewRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImagen4PreviewRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiImagen4PreviewRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiImagen4PreviewData = z.object({
  body: zImagen4PreviewInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImagen4PreviewResponse = zQueueStatus;

export const zGetFalAiImagen4PreviewRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImagen4PreviewRequestsByRequestIdResponse =
  zImagen4PreviewOutput;

export const zGetFalAiFluxProV11UltraRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxProV11UltraRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxProV11UltraRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProV11UltraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxProV11UltraData = z.object({
  body: zFluxProV11UltraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxProV11UltraResponse = zQueueStatus;

export const zGetFalAiFluxProV11UltraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxProV11UltraRequestsByRequestIdResponse =
  zFluxProV11UltraOutput;

export const zGetFalAiRecraftV3TextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiRecraftV3TextToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiRecraftV3TextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiRecraftV3TextToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiRecraftV3TextToImageData = z.object({
  body: zRecraftV3TextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiRecraftV3TextToImageResponse = zQueueStatus;

export const zGetFalAiRecraftV3TextToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiRecraftV3TextToImageRequestsByRequestIdResponse =
  zRecraftV3TextToImageOutput;

export const zGetFalAiFlux2LoraRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiFlux2LoraRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2LoraData = z.object({
  body: zFlux2LoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraResponse = zQueueStatus;

export const zGetFalAiFlux2LoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraRequestsByRequestIdResponse = zFlux2LoraOutput;

export const zGetFalAiFlux2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux2RequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiFlux2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2Data = z.object({
  body: zFlux2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2Response = zQueueStatus;

export const zGetFalAiFlux2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2RequestsByRequestIdResponse = zFlux2Output;

export const zGetFalAiFlux2ProRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux2ProRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiFlux2ProRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2ProRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2ProData = z.object({
  body: zFlux2ProInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2ProResponse = zQueueStatus;

export const zGetFalAiFlux2ProRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2ProRequestsByRequestIdResponse = zFlux2ProOutput;

export const zGetBriaTextToImage32RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetBriaTextToImage32RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutBriaTextToImage32RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutBriaTextToImage32RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostBriaTextToImage32Data = z.object({
  body: zTextToImage32Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostBriaTextToImage32Response = zQueueStatus;

export const zGetBriaTextToImage32RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetBriaTextToImage32RequestsByRequestIdResponse =
  zTextToImage32Output;

export const zGetFalAiImagen4PreviewFastRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImagen4PreviewFastRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImagen4PreviewFastRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImagen4PreviewFastRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiImagen4PreviewFastData = z.object({
  body: zImagen4PreviewFastInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImagen4PreviewFastResponse = zQueueStatus;

export const zGetFalAiImagen4PreviewFastRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImagen4PreviewFastRequestsByRequestIdResponse =
  zImagen4PreviewFastOutput;

export const zGetFalAiHidreamI1FullRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiHidreamI1FullRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHidreamI1FullRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiHidreamI1FullRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiHidreamI1FullData = z.object({
  body: zHidreamI1FullInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHidreamI1FullResponse = zQueueStatus;

export const zGetFalAiHidreamI1FullRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiHidreamI1FullRequestsByRequestIdResponse =
  zHidreamI1FullOutput;

export const zGetFalAiHidreamI1DevRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiHidreamI1DevRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHidreamI1DevRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiHidreamI1DevRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiHidreamI1DevData = z.object({
  body: zHidreamI1DevInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHidreamI1DevResponse = zQueueStatus;

export const zGetFalAiHidreamI1DevRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiHidreamI1DevRequestsByRequestIdResponse =
  zHidreamI1DevOutput;

export const zGetFalAiHidreamI1FastRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiHidreamI1FastRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHidreamI1FastRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiHidreamI1FastRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiHidreamI1FastData = z.object({
  body: zHidreamI1FastInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHidreamI1FastResponse = zQueueStatus;

export const zGetFalAiHidreamI1FastRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiHidreamI1FastRequestsByRequestIdResponse =
  zHidreamI1FastOutput;

export const zGetFalAiFluxDevRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxDevRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiFluxDevRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxDevRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxDevData = z.object({
  body: zFluxDevInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxDevResponse = zQueueStatus;

export const zGetFalAiFluxDevRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxDevRequestsByRequestIdResponse = zFluxDevOutput;

export const zGetFalAiIdeogramV2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiIdeogramV2RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiIdeogramV2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiIdeogramV2Data = z.object({
  body: zIdeogramV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiIdeogramV2Response = zQueueStatus;

export const zGetFalAiIdeogramV2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV2RequestsByRequestIdResponse = zIdeogramV2Output;

export const zGetFalAiStableDiffusionV35LargeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiStableDiffusionV35LargeRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiStableDiffusionV35LargeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiStableDiffusionV35LargeRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiStableDiffusionV35LargeData = z.object({
  body: zStableDiffusionV35LargeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiStableDiffusionV35LargeResponse = zQueueStatus;

export const zGetFalAiStableDiffusionV35LargeRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * Result of the request.
 */
export const zGetFalAiStableDiffusionV35LargeRequestsByRequestIdResponse =
  zStableDiffusionV35LargeOutput;

export const zGetFalAiFluxGeneralRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxGeneralRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxGeneralRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxGeneralRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxGeneralData = z.object({
  body: zFluxGeneralInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxGeneralResponse = zQueueStatus;

export const zGetFalAiFluxGeneralRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxGeneralRequestsByRequestIdResponse =
  zFluxGeneralOutput;

export const zGetFalAiFluxLoraRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxLoraRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiFluxLoraRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxLoraData = z.object({
  body: zFluxLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxLoraResponse = zQueueStatus;

export const zGetFalAiFluxLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxLoraRequestsByRequestIdResponse = zFluxLoraOutput;

export const zGetXaiGrokImagineImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetXaiGrokImagineImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutXaiGrokImagineImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutXaiGrokImagineImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostXaiGrokImagineImageData = z.object({
  body: zGrokImagineImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostXaiGrokImagineImageResponse = zQueueStatus;

export const zGetXaiGrokImagineImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetXaiGrokImagineImageRequestsByRequestIdResponse =
  zGrokImagineImageOutput;

export const zGetFalAiHunyuanImageV3InstructTextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiHunyuanImageV3InstructTextToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuanImageV3InstructTextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuanImageV3InstructTextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiHunyuanImageV3InstructTextToImageData = z.object({
  body: zHunyuanImageV3InstructTextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuanImageV3InstructTextToImageResponse = zQueueStatus;

export const zGetFalAiHunyuanImageV3InstructTextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiHunyuanImageV3InstructTextToImageRequestsByRequestIdResponse =
  zHunyuanImageV3InstructTextToImageOutput;

export const zGetFalAiQwenImageMaxTextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwenImageMaxTextToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImageMaxTextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageMaxTextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiQwenImageMaxTextToImageData = z.object({
  body: zQwenImageMaxTextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageMaxTextToImageResponse = zQueueStatus;

export const zGetFalAiQwenImageMaxTextToImageRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageMaxTextToImageRequestsByRequestIdResponse =
  zQwenImageMaxTextToImageOutput;

export const zGetFalAiZImageBaseLoraRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiZImageBaseLoraRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiZImageBaseLoraRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiZImageBaseLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiZImageBaseLoraData = z.object({
  body: zZImageBaseLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiZImageBaseLoraResponse = zQueueStatus;

export const zGetFalAiZImageBaseLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiZImageBaseLoraRequestsByRequestIdResponse =
  zZImageBaseLoraOutput;

export const zGetFalAiZImageBaseRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiZImageBaseRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiZImageBaseRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiZImageBaseRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiZImageBaseData = z.object({
  body: zZImageBaseInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiZImageBaseResponse = zQueueStatus;

export const zGetFalAiZImageBaseRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiZImageBaseRequestsByRequestIdResponse = zZImageBaseOutput;

export const zGetFalAiFlux2Klein9bBaseLoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein9bBaseLoraRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2Klein9bBaseLoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein9bBaseLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2Klein9bBaseLoraData = z.object({
  body: zFlux2Klein9bBaseLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein9bBaseLoraResponse = zQueueStatus;

export const zGetFalAiFlux2Klein9bBaseLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein9bBaseLoraRequestsByRequestIdResponse =
  zFlux2Klein9bBaseLoraOutput;

export const zGetFalAiFlux2Klein4bBaseLoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein4bBaseLoraRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2Klein4bBaseLoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein4bBaseLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2Klein4bBaseLoraData = z.object({
  body: zFlux2Klein4bBaseLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein4bBaseLoraResponse = zQueueStatus;

export const zGetFalAiFlux2Klein4bBaseLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein4bBaseLoraRequestsByRequestIdResponse =
  zFlux2Klein4bBaseLoraOutput;

export const zGetFalAiFlux2Klein9bBaseRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein9bBaseRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2Klein9bBaseRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein9bBaseRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2Klein9bBaseData = z.object({
  body: zFlux2Klein9bBaseInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein9bBaseResponse = zQueueStatus;

export const zGetFalAiFlux2Klein9bBaseRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein9bBaseRequestsByRequestIdResponse =
  zFlux2Klein9bBaseOutput;

export const zGetFalAiFlux2Klein4bBaseRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein4bBaseRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2Klein4bBaseRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein4bBaseRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2Klein4bBaseData = z.object({
  body: zFlux2Klein4bBaseInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein4bBaseResponse = zQueueStatus;

export const zGetFalAiFlux2Klein4bBaseRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein4bBaseRequestsByRequestIdResponse =
  zFlux2Klein4bBaseOutput;

export const zGetFalAiFlux2Klein9bRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein9bRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2Klein9bRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein9bRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2Klein9bData = z.object({
  body: zFlux2Klein9bInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein9bResponse = zQueueStatus;

export const zGetFalAiFlux2Klein9bRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein9bRequestsByRequestIdResponse =
  zFlux2Klein9bOutput;

export const zGetFalAiFlux2Klein4bRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein4bRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2Klein4bRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein4bRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2Klein4bData = z.object({
  body: zFlux2Klein4bInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein4bResponse = zQueueStatus;

export const zGetFalAiFlux2Klein4bRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein4bRequestsByRequestIdResponse =
  zFlux2Klein4bOutput;

export const zGetImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostImagineartImagineart15ProPreviewTextToImageData = z.object({
  body: zImagineart15ProPreviewTextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostImagineartImagineart15ProPreviewTextToImageResponse =
  zQueueStatus;

export const zGetImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdResponse =
  zImagineart15ProPreviewTextToImageOutput;

export const zGetFalAiGlmImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiGlmImageRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiGlmImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiGlmImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiGlmImageData = z.object({
  body: zGlmImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiGlmImageResponse = zQueueStatus;

export const zGetFalAiGlmImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiGlmImageRequestsByRequestIdResponse = zGlmImageOutput;

export const zGetFalAiQwenImage2512LoraRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiQwenImage2512LoraRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImage2512LoraRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImage2512LoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiQwenImage2512LoraData = z.object({
  body: zQwenImage2512LoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImage2512LoraResponse = zQueueStatus;

export const zGetFalAiQwenImage2512LoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiQwenImage2512LoraRequestsByRequestIdResponse =
  zQwenImage2512LoraOutput;

export const zGetFalAiQwenImage2512RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiQwenImage2512RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwenImage2512RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImage2512RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiQwenImage2512Data = z.object({
  body: zQwenImage2512Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImage2512Response = zQueueStatus;

export const zGetFalAiQwenImage2512RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiQwenImage2512RequestsByRequestIdResponse =
  zQwenImage2512Output;

export const zGetWanV26TextToImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetWanV26TextToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutWanV26TextToImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutWanV26TextToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostWanV26TextToImageData = z.object({
  body: zV26TextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostWanV26TextToImageResponse = zQueueStatus;

export const zGetWanV26TextToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetWanV26TextToImageRequestsByRequestIdResponse =
  zV26TextToImageOutput;

export const zGetFalAiFlux2FlashRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux2FlashRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2FlashRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2FlashRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2FlashData = z.object({
  body: zFlux2FlashInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2FlashResponse = zQueueStatus;

export const zGetFalAiFlux2FlashRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2FlashRequestsByRequestIdResponse = zFlux2FlashOutput;

export const zGetFalAiGptImage15RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiGptImage15RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiGptImage15RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiGptImage15RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiGptImage15Data = z.object({
  body: zGptImage15Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiGptImage15Response = zQueueStatus;

export const zGetFalAiGptImage15RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiGptImage15RequestsByRequestIdResponse = zGptImage15Output;

export const zGetBriaFiboLiteGenerateRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetBriaFiboLiteGenerateRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutBriaFiboLiteGenerateRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutBriaFiboLiteGenerateRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostBriaFiboLiteGenerateData = z.object({
  body: zFiboLiteGenerateInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostBriaFiboLiteGenerateResponse = zQueueStatus;

export const zGetBriaFiboLiteGenerateRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetBriaFiboLiteGenerateRequestsByRequestIdResponse =
  zFiboLiteGenerateOutput;

export const zGetFalAiFlux2TurboRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux2TurboRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2TurboRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2TurboRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2TurboData = z.object({
  body: zFlux2TurboInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2TurboResponse = zQueueStatus;

export const zGetFalAiFlux2TurboRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2TurboRequestsByRequestIdResponse = zFlux2TurboOutput;

export const zGetFalAiFlux2MaxRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux2MaxRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiFlux2MaxRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2MaxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2MaxData = z.object({
  body: zFlux2MaxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2MaxResponse = zQueueStatus;

export const zGetFalAiFlux2MaxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2MaxRequestsByRequestIdResponse = zFlux2MaxOutput;

export const zGetFalAiLongcatImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiLongcatImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiLongcatImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiLongcatImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiLongcatImageData = z.object({
  body: zLongcatImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiLongcatImageResponse = zQueueStatus;

export const zGetFalAiLongcatImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiLongcatImageRequestsByRequestIdResponse =
  zLongcatImageOutput;

export const zGetFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiBytedanceSeedreamV45TextToImageData = z.object({
  body: zBytedanceSeedreamV45TextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiBytedanceSeedreamV45TextToImageResponse = zQueueStatus;

export const zGetFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdResponse =
  zBytedanceSeedreamV45TextToImageOutput;

export const zGetFalAiViduQ2TextToImageRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiViduQ2TextToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiViduQ2TextToImageRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiViduQ2TextToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiViduQ2TextToImageData = z.object({
  body: zViduQ2TextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiViduQ2TextToImageResponse = zQueueStatus;

export const zGetFalAiViduQ2TextToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiViduQ2TextToImageRequestsByRequestIdResponse =
  zViduQ2TextToImageOutput;

export const zGetFalAiZImageTurboLoraRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiZImageTurboLoraRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiZImageTurboLoraRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiZImageTurboLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiZImageTurboLoraData = z.object({
  body: zZImageTurboLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiZImageTurboLoraResponse = zQueueStatus;

export const zGetFalAiZImageTurboLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiZImageTurboLoraRequestsByRequestIdResponse =
  zZImageTurboLoraOutput;

export const zGetFalAiOvisImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiOvisImageRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiOvisImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiOvisImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiOvisImageData = z.object({
  body: zOvisImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiOvisImageResponse = zQueueStatus;

export const zGetFalAiOvisImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiOvisImageRequestsByRequestIdResponse = zOvisImageOutput;

export const zGetFalAiZImageTurboRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiZImageTurboRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiZImageTurboRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiZImageTurboRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiZImageTurboData = z.object({
  body: zZImageTurboInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiZImageTurboResponse = zQueueStatus;

export const zGetFalAiZImageTurboRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiZImageTurboRequestsByRequestIdResponse =
  zZImageTurboOutput;

export const zGetFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFlux2LoraGallerySepiaVintageData = z.object({
  body: zFlux2LoraGallerySepiaVintageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraGallerySepiaVintageResponse = zQueueStatus;

export const zGetFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdResponse =
  zFlux2LoraGallerySepiaVintageOutput;

export const zGetFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFlux2LoraGallerySatelliteViewStyleData = z.object({
  body: zFlux2LoraGallerySatelliteViewStyleInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraGallerySatelliteViewStyleResponse =
  zQueueStatus;

export const zGetFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdResponse =
  zFlux2LoraGallerySatelliteViewStyleOutput;

export const zGetFalAiFlux2LoraGalleryRealismRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraGalleryRealismRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2LoraGalleryRealismRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraGalleryRealismRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFlux2LoraGalleryRealismData = z.object({
  body: zFlux2LoraGalleryRealismInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraGalleryRealismResponse = zQueueStatus;

export const zGetFalAiFlux2LoraGalleryRealismRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraGalleryRealismRequestsByRequestIdResponse =
  zFlux2LoraGalleryRealismOutput;

export const zGetFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFlux2LoraGalleryHdrStyleData = z.object({
  body: zFlux2LoraGalleryHdrStyleInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraGalleryHdrStyleResponse = zQueueStatus;

export const zGetFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdResponse =
  zFlux2LoraGalleryHdrStyleOutput;

export const zGetFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFlux2LoraGalleryDigitalComicArtData = z.object({
  body: zFlux2LoraGalleryDigitalComicArtInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraGalleryDigitalComicArtResponse = zQueueStatus;

export const zGetFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdResponse =
  zFlux2LoraGalleryDigitalComicArtOutput;

export const zGetFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFlux2LoraGalleryBallpointPenSketchData = z.object({
  body: zFlux2LoraGalleryBallpointPenSketchInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraGalleryBallpointPenSketchResponse =
  zQueueStatus;

export const zGetFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdResponse =
  zFlux2LoraGalleryBallpointPenSketchOutput;

export const zGetFalAiFlux2FlexRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux2FlexRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiFlux2FlexRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2FlexRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux2FlexData = z.object({
  body: zFlux2FlexInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux2FlexResponse = zQueueStatus;

export const zGetFalAiFlux2FlexRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux2FlexRequestsByRequestIdResponse = zFlux2FlexOutput;

export const zGetFalAiGemini3ProImagePreviewRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiGemini3ProImagePreviewRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiGemini3ProImagePreviewRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiGemini3ProImagePreviewRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiGemini3ProImagePreviewData = z.object({
  body: zGemini3ProImagePreviewInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiGemini3ProImagePreviewResponse = zQueueStatus;

export const zGetFalAiGemini3ProImagePreviewRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiGemini3ProImagePreviewRequestsByRequestIdResponse =
  zGemini3ProImagePreviewOutput;

export const zGetFalAiNanoBananaProRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiNanoBananaProRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiNanoBananaProRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiNanoBananaProRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiNanoBananaProData = z.object({
  body: zNanoBananaProInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiNanoBananaProResponse = zQueueStatus;

export const zGetFalAiNanoBananaProRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiNanoBananaProRequestsByRequestIdResponse =
  zNanoBananaProOutput;

export const zGetImagineartImagineart15PreviewTextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetImagineartImagineart15PreviewTextToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutImagineartImagineart15PreviewTextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutImagineartImagineart15PreviewTextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostImagineartImagineart15PreviewTextToImageData = z.object({
  body: zImagineart15PreviewTextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostImagineartImagineart15PreviewTextToImageResponse =
  zQueueStatus;

export const zGetImagineartImagineart15PreviewTextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetImagineartImagineart15PreviewTextToImageRequestsByRequestIdResponse =
  zImagineart15PreviewTextToImageOutput;

export const zGetFalAiEmu35ImageTextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiEmu35ImageTextToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiEmu35ImageTextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiEmu35ImageTextToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiEmu35ImageTextToImageData = z.object({
  body: zEmu35ImageTextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiEmu35ImageTextToImageResponse = zQueueStatus;

export const zGetFalAiEmu35ImageTextToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiEmu35ImageTextToImageRequestsByRequestIdResponse =
  zEmu35ImageTextToImageOutput;

export const zGetBriaFiboGenerateRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetBriaFiboGenerateRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutBriaFiboGenerateRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutBriaFiboGenerateRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostBriaFiboGenerateData = z.object({
  body: zFiboGenerateInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostBriaFiboGenerateResponse = zQueueStatus;

export const zGetBriaFiboGenerateRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetBriaFiboGenerateRequestsByRequestIdResponse =
  zFiboGenerateOutput;

export const zGetFalAiPiflowRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiPiflowRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiPiflowRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiPiflowRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiPiflowData = z.object({
  body: zPiflowInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPiflowResponse = zQueueStatus;

export const zGetFalAiPiflowRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiPiflowRequestsByRequestIdResponse = zPiflowOutput;

export const zGetFalAiGptImage1MiniRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiGptImage1MiniRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiGptImage1MiniRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiGptImage1MiniRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiGptImage1MiniData = z.object({
  body: zGptImage1MiniInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiGptImage1MiniResponse = zQueueStatus;

export const zGetFalAiGptImage1MiniRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiGptImage1MiniRequestsByRequestIdResponse =
  zGptImage1MiniOutput;

export const zGetFalAiReveTextToImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiReveTextToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiReveTextToImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiReveTextToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiReveTextToImageData = z.object({
  body: zReveTextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiReveTextToImageResponse = zQueueStatus;

export const zGetFalAiReveTextToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiReveTextToImageRequestsByRequestIdResponse =
  zReveTextToImageOutput;

export const zGetFalAiHunyuanImageV3TextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiHunyuanImageV3TextToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuanImageV3TextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuanImageV3TextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiHunyuanImageV3TextToImageData = z.object({
  body: zHunyuanImageV3TextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuanImageV3TextToImageResponse = zQueueStatus;

export const zGetFalAiHunyuanImageV3TextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiHunyuanImageV3TextToImageRequestsByRequestIdResponse =
  zHunyuanImageV3TextToImageOutput;

export const zGetFalAiWan25PreviewTextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiWan25PreviewTextToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiWan25PreviewTextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiWan25PreviewTextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiWan25PreviewTextToImageData = z.object({
  body: zWan25PreviewTextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiWan25PreviewTextToImageResponse = zQueueStatus;

export const zGetFalAiWan25PreviewTextToImageRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * Result of the request.
 */
export const zGetFalAiWan25PreviewTextToImageRequestsByRequestIdResponse =
  zWan25PreviewTextToImageOutput;

export const zGetFalAiFluxSrpoRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxSrpoRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiFluxSrpoRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxSrpoRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxSrpoData = z.object({
  body: zFluxSrpoInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxSrpoResponse = zQueueStatus;

export const zGetFalAiFluxSrpoRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxSrpoRequestsByRequestIdResponse = zFluxSrpoOutput;

export const zGetFalAiFlux1SrpoRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux1SrpoRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiFlux1SrpoRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux1SrpoRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux1SrpoData = z.object({
  body: zFlux1SrpoInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux1SrpoResponse = zQueueStatus;

export const zGetFalAiFlux1SrpoRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux1SrpoRequestsByRequestIdResponse = zFlux1SrpoOutput;

export const zGetFalAiHunyuanImageV21TextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiHunyuanImageV21TextToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiHunyuanImageV21TextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuanImageV21TextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiHunyuanImageV21TextToImageData = z.object({
  body: zHunyuanImageV21TextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiHunyuanImageV21TextToImageResponse = zQueueStatus;

export const zGetFalAiHunyuanImageV21TextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiHunyuanImageV21TextToImageRequestsByRequestIdResponse =
  zHunyuanImageV21TextToImageOutput;

export const zGetFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiBytedanceSeedreamV4TextToImageData = z.object({
  body: zBytedanceSeedreamV4TextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiBytedanceSeedreamV4TextToImageResponse = zQueueStatus;

export const zGetFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdResponse =
  zBytedanceSeedreamV4TextToImageOutput;

export const zGetFalAiGemini25FlashImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiGemini25FlashImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiGemini25FlashImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiGemini25FlashImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiGemini25FlashImageData = z.object({
  body: zGemini25FlashImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiGemini25FlashImageResponse = zQueueStatus;

export const zGetFalAiGemini25FlashImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiGemini25FlashImageRequestsByRequestIdResponse =
  zGemini25FlashImageOutput;

export const zGetFalAiNanoBananaRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiNanoBananaRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiNanoBananaRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiNanoBananaRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiNanoBananaData = z.object({
  body: zNanoBananaInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiNanoBananaResponse = zQueueStatus;

export const zGetFalAiNanoBananaRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiNanoBananaRequestsByRequestIdResponse = zNanoBananaOutput;

export const zGetFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiBytedanceDreaminaV31TextToImageData = z.object({
  body: zBytedanceDreaminaV31TextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiBytedanceDreaminaV31TextToImageResponse = zQueueStatus;

export const zGetFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdResponse =
  zBytedanceDreaminaV31TextToImageOutput;

export const zGetFalAiWanV22A14bTextToImageLoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiWanV22A14bTextToImageLoraRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiWanV22A14bTextToImageLoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiWanV22A14bTextToImageLoraRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiWanV22A14bTextToImageLoraData = z.object({
  body: zWanV22A14bTextToImageLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiWanV22A14bTextToImageLoraResponse = zQueueStatus;

export const zGetFalAiWanV22A14bTextToImageLoraRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiWanV22A14bTextToImageLoraRequestsByRequestIdResponse =
  zWanV22A14bTextToImageLoraOutput;

export const zGetFalAiWanV225bTextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiWanV225bTextToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiWanV225bTextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiWanV225bTextToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiWanV225bTextToImageData = z.object({
  body: zWanV225bTextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiWanV225bTextToImageResponse = zQueueStatus;

export const zGetFalAiWanV225bTextToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiWanV225bTextToImageRequestsByRequestIdResponse =
  zWanV225bTextToImageOutput;

export const zGetFalAiWanV22A14bTextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiWanV22A14bTextToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiWanV22A14bTextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiWanV22A14bTextToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiWanV22A14bTextToImageData = z.object({
  body: zWanV22A14bTextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiWanV22A14bTextToImageResponse = zQueueStatus;

export const zGetFalAiWanV22A14bTextToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiWanV22A14bTextToImageRequestsByRequestIdResponse =
  zWanV22A14bTextToImageOutput;

export const zGetFalAiQwenImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiQwenImageRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiQwenImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiQwenImageData = z.object({
  body: zQwenImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwenImageResponse = zQueueStatus;

export const zGetFalAiQwenImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageRequestsByRequestIdResponse = zQwenImageOutput;

export const zGetFalAiFluxKreaLoraStreamRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxKreaLoraStreamRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxKreaLoraStreamRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxKreaLoraStreamRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxKreaLoraStreamData = z.object({
  body: zFluxKreaLoraStreamInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxKreaLoraStreamResponse = zQueueStatus;

export const zGetFalAiFluxKreaLoraStreamRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxKreaLoraStreamRequestsByRequestIdResponse =
  zFluxKreaLoraStreamOutput;

export const zGetFalAiFluxKreaLoraRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxKreaLoraRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxKreaLoraRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxKreaLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxKreaLoraData = z.object({
  body: zFluxKreaLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxKreaLoraResponse = zQueueStatus;

export const zGetFalAiFluxKreaLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxKreaLoraRequestsByRequestIdResponse =
  zFluxKreaLoraOutput;

export const zGetFalAiFluxKreaRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxKreaRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiFluxKreaRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxKreaRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxKreaData = z.object({
  body: zFluxKreaInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxKreaResponse = zQueueStatus;

export const zGetFalAiFluxKreaRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxKreaRequestsByRequestIdResponse = zFluxKreaOutput;

export const zGetFalAiFlux1KreaRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux1KreaRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiFlux1KreaRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux1KreaRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux1KreaData = z.object({
  body: zFlux1KreaInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux1KreaResponse = zQueueStatus;

export const zGetFalAiFlux1KreaRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux1KreaRequestsByRequestIdResponse = zFlux1KreaOutput;

export const zGetFalAiSkyRaccoonRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiSkyRaccoonRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiSkyRaccoonRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiSkyRaccoonRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiSkyRaccoonData = z.object({
  body: zSkyRaccoonInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiSkyRaccoonResponse = zQueueStatus;

export const zGetFalAiSkyRaccoonRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiSkyRaccoonRequestsByRequestIdResponse = zSkyRaccoonOutput;

export const zGetFalAiFluxKontextLoraTextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxKontextLoraTextToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxKontextLoraTextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxKontextLoraTextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFluxKontextLoraTextToImageData = z.object({
  body: zFluxKontextLoraTextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxKontextLoraTextToImageResponse = zQueueStatus;

export const zGetFalAiFluxKontextLoraTextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFluxKontextLoraTextToImageRequestsByRequestIdResponse =
  zFluxKontextLoraTextToImageOutput;

export const zGetFalAiOmnigenV2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiOmnigenV2RequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiOmnigenV2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiOmnigenV2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiOmnigenV2Data = z.object({
  body: zOmnigenV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiOmnigenV2Response = zQueueStatus;

export const zGetFalAiOmnigenV2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiOmnigenV2RequestsByRequestIdResponse = zOmnigenV2Output;

export const zGetFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiBytedanceSeedreamV3TextToImageData = z.object({
  body: zBytedanceSeedreamV3TextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiBytedanceSeedreamV3TextToImageResponse = zQueueStatus;

export const zGetFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdResponse =
  zBytedanceSeedreamV3TextToImageOutput;

export const zGetFalAiFlux1SchnellRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux1SchnellRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFlux1SchnellRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux1SchnellRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux1SchnellData = z.object({
  body: zFlux1SchnellInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux1SchnellResponse = zQueueStatus;

export const zGetFalAiFlux1SchnellRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux1SchnellRequestsByRequestIdResponse =
  zFlux1SchnellOutput;

export const zGetFalAiFlux1DevRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFlux1DevRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiFlux1DevRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux1DevRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFlux1DevData = z.object({
  body: zFlux1DevInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFlux1DevResponse = zQueueStatus;

export const zGetFalAiFlux1DevRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFlux1DevRequestsByRequestIdResponse = zFlux1DevOutput;

export const zGetFalAiFluxProKontextMaxTextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxProKontextMaxTextToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxProKontextMaxTextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProKontextMaxTextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFluxProKontextMaxTextToImageData = z.object({
  body: zFluxProKontextMaxTextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxProKontextMaxTextToImageResponse = zQueueStatus;

export const zGetFalAiFluxProKontextMaxTextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFluxProKontextMaxTextToImageRequestsByRequestIdResponse =
  zFluxProKontextMaxTextToImageOutput;

export const zGetFalAiFluxProKontextTextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxProKontextTextToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxProKontextTextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProKontextTextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFluxProKontextTextToImageData = z.object({
  body: zFluxProKontextTextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxProKontextTextToImageResponse = zQueueStatus;

export const zGetFalAiFluxProKontextTextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFluxProKontextTextToImageRequestsByRequestIdResponse =
  zFluxProKontextTextToImageOutput;

export const zGetFalAiBagelRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiBagelRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiBagelRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiBagelRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiBagelData = z.object({
  body: zBagelInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiBagelResponse = zQueueStatus;

export const zGetFalAiBagelRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiBagelRequestsByRequestIdResponse = zBagelOutput;

export const zGetFalAiImagen4PreviewUltraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiImagen4PreviewUltraRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImagen4PreviewUltraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiImagen4PreviewUltraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiImagen4PreviewUltraData = z.object({
  body: zImagen4PreviewUltraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImagen4PreviewUltraResponse = zQueueStatus;

export const zGetFalAiImagen4PreviewUltraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImagen4PreviewUltraRequestsByRequestIdResponse =
  zImagen4PreviewUltraOutput;

export const zGetFalAiDreamoRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiDreamoRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiDreamoRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiDreamoRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiDreamoData = z.object({
  body: zDreamoInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiDreamoResponse = zQueueStatus;

export const zGetFalAiDreamoRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiDreamoRequestsByRequestIdResponse = zDreamoOutput;

export const zGetFalAiFluxLoraStreamRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxLoraStreamRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxLoraStreamRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxLoraStreamRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxLoraStreamData = z.object({
  body: zFluxLoraStreamInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxLoraStreamResponse = zQueueStatus;

export const zGetFalAiFluxLoraStreamRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxLoraStreamRequestsByRequestIdResponse =
  zFluxLoraStreamOutput;

export const zGetFalAiMinimaxImage01RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiMinimaxImage01RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiMinimaxImage01RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiMinimaxImage01RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiMinimaxImage01Data = z.object({
  body: zMinimaxImage01Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiMinimaxImage01Response = zQueueStatus;

export const zGetFalAiMinimaxImage01RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiMinimaxImage01RequestsByRequestIdResponse =
  zMinimaxImage01Output;

export const zGetFalAiPonyV7RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiPonyV7RequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiPonyV7RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiPonyV7RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiPonyV7Data = z.object({
  body: zPonyV7Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPonyV7Response = zQueueStatus;

export const zGetFalAiPonyV7RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiPonyV7RequestsByRequestIdResponse = zPonyV7Output;

export const zGetFalAiIdeogramV3RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiIdeogramV3RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiIdeogramV3RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV3RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiIdeogramV3Data = z.object({
  body: zIdeogramV3Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiIdeogramV3Response = zQueueStatus;

export const zGetFalAiIdeogramV3RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV3RequestsByRequestIdResponse = zIdeogramV3Output;

export const zGetFalAiFLiteStandardRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFLiteStandardRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFLiteStandardRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFLiteStandardRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFLiteStandardData = z.object({
  body: zFLiteStandardInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFLiteStandardResponse = zQueueStatus;

export const zGetFalAiFLiteStandardRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFLiteStandardRequestsByRequestIdResponse =
  zFLiteStandardOutput;

export const zGetFalAiFLiteTextureRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFLiteTextureRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFLiteTextureRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFLiteTextureRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFLiteTextureData = z.object({
  body: zFLiteTextureInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFLiteTextureResponse = zQueueStatus;

export const zGetFalAiFLiteTextureRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFLiteTextureRequestsByRequestIdResponse =
  zFLiteTextureOutput;

export const zGetFalAiGptImage1TextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiGptImage1TextToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiGptImage1TextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiGptImage1TextToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiGptImage1TextToImageData = z.object({
  body: zGptImage1TextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiGptImage1TextToImageResponse = zQueueStatus;

export const zGetFalAiGptImage1TextToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiGptImage1TextToImageRequestsByRequestIdResponse =
  zGptImage1TextToImageOutput;

export const zGetFalAiSanaV1516bRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiSanaV1516bRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiSanaV1516bRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiSanaV1516bRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiSanaV1516bData = z.object({
  body: zSanaV1516bInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiSanaV1516bResponse = zQueueStatus;

export const zGetFalAiSanaV1516bRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiSanaV1516bRequestsByRequestIdResponse = zSanaV1516bOutput;

export const zGetFalAiSanaV1548bRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiSanaV1548bRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiSanaV1548bRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiSanaV1548bRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiSanaV1548bData = z.object({
  body: zSanaV1548bInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiSanaV1548bResponse = zQueueStatus;

export const zGetFalAiSanaV1548bRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiSanaV1548bRequestsByRequestIdResponse = zSanaV1548bOutput;

export const zGetFalAiSanaSprintRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiSanaSprintRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiSanaSprintRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiSanaSprintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiSanaSprintData = z.object({
  body: zSanaSprintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiSanaSprintResponse = zQueueStatus;

export const zGetFalAiSanaSprintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiSanaSprintRequestsByRequestIdResponse = zSanaSprintOutput;

export const zGetRundiffusionFalJuggernautFluxLoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetRundiffusionFalJuggernautFluxLoraRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutRundiffusionFalJuggernautFluxLoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutRundiffusionFalJuggernautFluxLoraRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostRundiffusionFalJuggernautFluxLoraData = z.object({
  body: zJuggernautFluxLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostRundiffusionFalJuggernautFluxLoraResponse = zQueueStatus;

export const zGetRundiffusionFalJuggernautFluxLoraRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetRundiffusionFalJuggernautFluxLoraRequestsByRequestIdResponse =
  zJuggernautFluxLoraOutput;

export const zGetRundiffusionFalJuggernautFluxBaseRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetRundiffusionFalJuggernautFluxBaseRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutRundiffusionFalJuggernautFluxBaseRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutRundiffusionFalJuggernautFluxBaseRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostRundiffusionFalJuggernautFluxBaseData = z.object({
  body: zJuggernautFluxBaseInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostRundiffusionFalJuggernautFluxBaseResponse = zQueueStatus;

export const zGetRundiffusionFalJuggernautFluxBaseRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetRundiffusionFalJuggernautFluxBaseRequestsByRequestIdResponse =
  zJuggernautFluxBaseOutput;

export const zGetRundiffusionFalJuggernautFluxLightningRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetRundiffusionFalJuggernautFluxLightningRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutRundiffusionFalJuggernautFluxLightningRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutRundiffusionFalJuggernautFluxLightningRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostRundiffusionFalJuggernautFluxLightningData = z.object({
  body: zJuggernautFluxLightningInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostRundiffusionFalJuggernautFluxLightningResponse = zQueueStatus;

export const zGetRundiffusionFalJuggernautFluxLightningRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetRundiffusionFalJuggernautFluxLightningRequestsByRequestIdResponse =
  zJuggernautFluxLightningOutput;

export const zGetRundiffusionFalJuggernautFluxProRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetRundiffusionFalJuggernautFluxProRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutRundiffusionFalJuggernautFluxProRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutRundiffusionFalJuggernautFluxProRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostRundiffusionFalJuggernautFluxProData = z.object({
  body: zJuggernautFluxProInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostRundiffusionFalJuggernautFluxProResponse = zQueueStatus;

export const zGetRundiffusionFalJuggernautFluxProRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetRundiffusionFalJuggernautFluxProRequestsByRequestIdResponse =
  zJuggernautFluxProOutput;

export const zGetRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostRundiffusionFalRundiffusionPhotoFluxData = z.object({
  body: zRundiffusionPhotoFluxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostRundiffusionFalRundiffusionPhotoFluxResponse = zQueueStatus;

export const zGetRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdResponse =
  zRundiffusionPhotoFluxOutput;

export const zGetFalAiCogview4RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiCogview4RequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiCogview4RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiCogview4RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiCogview4Data = z.object({
  body: zCogview4Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiCogview4Response = zQueueStatus;

export const zGetFalAiCogview4RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiCogview4RequestsByRequestIdResponse = zCogview4Output;

export const zGetFalAiIdeogramV2aRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiIdeogramV2aRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiIdeogramV2aRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV2aRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiIdeogramV2aData = z.object({
  body: zIdeogramV2aInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiIdeogramV2aResponse = zQueueStatus;

export const zGetFalAiIdeogramV2aRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV2aRequestsByRequestIdResponse =
  zIdeogramV2aOutput;

export const zGetFalAiIdeogramV2aTurboRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiIdeogramV2aTurboRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiIdeogramV2aTurboRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV2aTurboRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiIdeogramV2aTurboData = z.object({
  body: zIdeogramV2aTurboInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiIdeogramV2aTurboResponse = zQueueStatus;

export const zGetFalAiIdeogramV2aTurboRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV2aTurboRequestsByRequestIdResponse =
  zIdeogramV2aTurboOutput;

export const zGetFalAiFluxControlLoraCannyRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxControlLoraCannyRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxControlLoraCannyRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxControlLoraCannyRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxControlLoraCannyData = z.object({
  body: zFluxControlLoraCannyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxControlLoraCannyResponse = zQueueStatus;

export const zGetFalAiFluxControlLoraCannyRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxControlLoraCannyRequestsByRequestIdResponse =
  zFluxControlLoraCannyOutput;

export const zGetFalAiFluxControlLoraDepthRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxControlLoraDepthRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxControlLoraDepthRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxControlLoraDepthRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxControlLoraDepthData = z.object({
  body: zFluxControlLoraDepthInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxControlLoraDepthResponse = zQueueStatus;

export const zGetFalAiFluxControlLoraDepthRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxControlLoraDepthRequestsByRequestIdResponse =
  zFluxControlLoraDepthOutput;

export const zGetFalAiImagen3FastRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiImagen3FastRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiImagen3FastRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiImagen3FastRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiImagen3FastData = z.object({
  body: zImagen3FastInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImagen3FastResponse = zQueueStatus;

export const zGetFalAiImagen3FastRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImagen3FastRequestsByRequestIdResponse =
  zImagen3FastOutput;

export const zGetFalAiImagen3RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiImagen3RequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiImagen3RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiImagen3RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiImagen3Data = z.object({
  body: zImagen3Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiImagen3Response = zQueueStatus;

export const zGetFalAiImagen3RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiImagen3RequestsByRequestIdResponse = zImagen3Output;

export const zGetFalAiLuminaImageV2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiLuminaImageV2RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiLuminaImageV2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiLuminaImageV2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiLuminaImageV2Data = z.object({
  body: zLuminaImageV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiLuminaImageV2Response = zQueueStatus;

export const zGetFalAiLuminaImageV2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiLuminaImageV2RequestsByRequestIdResponse =
  zLuminaImageV2Output;

export const zGetFalAiJanusRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiJanusRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiJanusRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiJanusRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiJanusData = z.object({
  body: zJanusInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiJanusResponse = zQueueStatus;

export const zGetFalAiJanusRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiJanusRequestsByRequestIdResponse = zJanusOutput;

export const zGetFalAiFluxProV11RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxProV11RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxProV11RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProV11RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxProV11Data = z.object({
  body: zFluxProV11Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxProV11Response = zQueueStatus;

export const zGetFalAiFluxProV11RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxProV11RequestsByRequestIdResponse = zFluxProV11Output;

export const zGetFalAiFluxProV11UltraFinetunedRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxProV11UltraFinetunedRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxProV11UltraFinetunedRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProV11UltraFinetunedRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFluxProV11UltraFinetunedData = z.object({
  body: zFluxProV11UltraFinetunedInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxProV11UltraFinetunedResponse = zQueueStatus;

export const zGetFalAiFluxProV11UltraFinetunedRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFluxProV11UltraFinetunedRequestsByRequestIdResponse =
  zFluxProV11UltraFinetunedOutput;

export const zGetFalAiSwittiRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiSwittiRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiSwittiRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiSwittiRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiSwittiData = z.object({
  body: zSwittiInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiSwittiResponse = zQueueStatus;

export const zGetFalAiSwittiRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiSwittiRequestsByRequestIdResponse = zSwittiOutput;

export const zGetFalAiSwitti512RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiSwitti512RequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiSwitti512RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiSwitti512RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiSwitti512Data = z.object({
  body: zSwitti512Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiSwitti512Response = zQueueStatus;

export const zGetFalAiSwitti512RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiSwitti512RequestsByRequestIdResponse = zSwitti512Output;

export const zGetFalAiBriaTextToImageBaseRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiBriaTextToImageBaseRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiBriaTextToImageBaseRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiBriaTextToImageBaseRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiBriaTextToImageBaseData = z.object({
  body: zBriaTextToImageBaseInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiBriaTextToImageBaseResponse = zQueueStatus;

export const zGetFalAiBriaTextToImageBaseRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiBriaTextToImageBaseRequestsByRequestIdResponse =
  zBriaTextToImageBaseOutput;

export const zGetFalAiBriaTextToImageFastRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiBriaTextToImageFastRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiBriaTextToImageFastRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiBriaTextToImageFastRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiBriaTextToImageFastData = z.object({
  body: zBriaTextToImageFastInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiBriaTextToImageFastResponse = zQueueStatus;

export const zGetFalAiBriaTextToImageFastRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiBriaTextToImageFastRequestsByRequestIdResponse =
  zBriaTextToImageFastOutput;

export const zGetFalAiBriaTextToImageHdRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiBriaTextToImageHdRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiBriaTextToImageHdRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiBriaTextToImageHdRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiBriaTextToImageHdData = z.object({
  body: zBriaTextToImageHdInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiBriaTextToImageHdResponse = zQueueStatus;

export const zGetFalAiBriaTextToImageHdRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiBriaTextToImageHdRequestsByRequestIdResponse =
  zBriaTextToImageHdOutput;

export const zGetFalAiRecraft20bRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiRecraft20bRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiRecraft20bRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiRecraft20bRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiRecraft20bData = z.object({
  body: zRecraft20bInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiRecraft20bResponse = zQueueStatus;

export const zGetFalAiRecraft20bRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiRecraft20bRequestsByRequestIdResponse = zRecraft20bOutput;

export const zGetFalAiIdeogramV2TurboRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiIdeogramV2TurboRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiIdeogramV2TurboRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV2TurboRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiIdeogramV2TurboData = z.object({
  body: zIdeogramV2TurboInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiIdeogramV2TurboResponse = zQueueStatus;

export const zGetFalAiIdeogramV2TurboRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV2TurboRequestsByRequestIdResponse =
  zIdeogramV2TurboOutput;

export const zGetFalAiLumaPhotonFlashRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiLumaPhotonFlashRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiLumaPhotonFlashRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiLumaPhotonFlashRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiLumaPhotonFlashData = z.object({
  body: zLumaPhotonFlashInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiLumaPhotonFlashResponse = zQueueStatus;

export const zGetFalAiLumaPhotonFlashRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiLumaPhotonFlashRequestsByRequestIdResponse =
  zLumaPhotonFlashOutput;

export const zGetFalAiAuraFlowRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiAuraFlowRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiAuraFlowRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiAuraFlowRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiAuraFlowData = z.object({
  body: zAuraFlowInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiAuraFlowResponse = zQueueStatus;

export const zGetFalAiAuraFlowRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiAuraFlowRequestsByRequestIdResponse = zAuraFlowOutput;

export const zGetFalAiOmnigenV1RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiOmnigenV1RequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiOmnigenV1RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiOmnigenV1RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiOmnigenV1Data = z.object({
  body: zOmnigenV1Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiOmnigenV1Response = zQueueStatus;

export const zGetFalAiOmnigenV1RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiOmnigenV1RequestsByRequestIdResponse = zOmnigenV1Output;

export const zGetFalAiFluxSchnellRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxSchnellRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxSchnellRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxSchnellRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxSchnellData = z.object({
  body: zFluxSchnellInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxSchnellResponse = zQueueStatus;

export const zGetFalAiFluxSchnellRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxSchnellRequestsByRequestIdResponse =
  zFluxSchnellOutput;

export const zGetFalAiStableDiffusionV35MediumRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiStableDiffusionV35MediumRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiStableDiffusionV35MediumRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiStableDiffusionV35MediumRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiStableDiffusionV35MediumData = z.object({
  body: zStableDiffusionV35MediumInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiStableDiffusionV35MediumResponse = zQueueStatus;

export const zGetFalAiStableDiffusionV35MediumRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiStableDiffusionV35MediumRequestsByRequestIdResponse =
  zStableDiffusionV35MediumOutput;

export const zGetFalAiFluxLoraInpaintingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFluxLoraInpaintingRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxLoraInpaintingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxLoraInpaintingRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxLoraInpaintingData = z.object({
  body: zFluxLoraInpaintingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxLoraInpaintingResponse = zQueueStatus;

export const zGetFalAiFluxLoraInpaintingRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxLoraInpaintingRequestsByRequestIdResponse =
  zFluxLoraInpaintingOutput;

export const zGetFalAiStableDiffusionV3MediumRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiStableDiffusionV3MediumRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiStableDiffusionV3MediumRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiStableDiffusionV3MediumRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiStableDiffusionV3MediumData = z.object({
  body: zStableDiffusionV3MediumInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiStableDiffusionV3MediumResponse = zQueueStatus;

export const zGetFalAiStableDiffusionV3MediumRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * Result of the request.
 */
export const zGetFalAiStableDiffusionV3MediumRequestsByRequestIdResponse =
  zStableDiffusionV3MediumOutput;

export const zGetFalAiFooocusUpscaleOrVaryRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFooocusUpscaleOrVaryRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFooocusUpscaleOrVaryRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFooocusUpscaleOrVaryRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFooocusUpscaleOrVaryData = z.object({
  body: zFooocusUpscaleOrVaryInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFooocusUpscaleOrVaryResponse = zQueueStatus;

export const zGetFalAiFooocusUpscaleOrVaryRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFooocusUpscaleOrVaryRequestsByRequestIdResponse =
  zFooocusUpscaleOrVaryOutput;

export const zGetFalAiSanaRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiSanaRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiSanaRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiSanaRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiSanaData = z.object({
  body: zSanaInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiSanaResponse = zQueueStatus;

export const zGetFalAiSanaRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiSanaRequestsByRequestIdResponse = zSanaOutput;

export const zGetFalAiPixartSigmaRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiPixartSigmaRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiPixartSigmaRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiPixartSigmaRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiPixartSigmaData = z.object({
  body: zPixartSigmaInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPixartSigmaResponse = zQueueStatus;

export const zGetFalAiPixartSigmaRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiPixartSigmaRequestsByRequestIdResponse =
  zPixartSigmaOutput;

export const zGetFalAiFluxSubjectRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFluxSubjectRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFluxSubjectRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxSubjectRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFluxSubjectData = z.object({
  body: zFluxSubjectInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFluxSubjectResponse = zQueueStatus;

export const zGetFalAiFluxSubjectRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFluxSubjectRequestsByRequestIdResponse =
  zFluxSubjectOutput;

export const zGetFalAiSdxlControlnetUnionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiSdxlControlnetUnionRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiSdxlControlnetUnionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiSdxlControlnetUnionRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiSdxlControlnetUnionData = z.object({
  body: zSdxlControlnetUnionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiSdxlControlnetUnionResponse = zQueueStatus;

export const zGetFalAiSdxlControlnetUnionRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiSdxlControlnetUnionRequestsByRequestIdResponse =
  zSdxlControlnetUnionOutput;

export const zGetFalAiKolorsRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiKolorsRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiKolorsRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiKolorsRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiKolorsData = z.object({
  body: zKolorsInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiKolorsResponse = zQueueStatus;

export const zGetFalAiKolorsRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiKolorsRequestsByRequestIdResponse = zKolorsOutput;

export const zGetFalAiStableCascadeRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiStableCascadeRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiStableCascadeRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiStableCascadeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiStableCascadeData = z.object({
  body: zStableCascadeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiStableCascadeResponse = zQueueStatus;

export const zGetFalAiStableCascadeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiStableCascadeRequestsByRequestIdResponse =
  zStableCascadeOutput;

export const zGetFalAiFastSdxlRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFastSdxlRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiFastSdxlRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFastSdxlRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFastSdxlData = z.object({
  body: zFastSdxlInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFastSdxlResponse = zQueueStatus;

export const zGetFalAiFastSdxlRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFastSdxlRequestsByRequestIdResponse = zFastSdxlOutput;

export const zGetFalAiStableCascadeSoteDiffusionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiStableCascadeSoteDiffusionRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiStableCascadeSoteDiffusionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiStableCascadeSoteDiffusionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiStableCascadeSoteDiffusionData = z.object({
  body: zStableCascadeSoteDiffusionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiStableCascadeSoteDiffusionResponse = zQueueStatus;

export const zGetFalAiStableCascadeSoteDiffusionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiStableCascadeSoteDiffusionRequestsByRequestIdResponse =
  zStableCascadeSoteDiffusionOutput;

export const zGetFalAiLumaPhotonRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiLumaPhotonRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiLumaPhotonRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiLumaPhotonRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiLumaPhotonData = z.object({
  body: zLumaPhotonInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiLumaPhotonResponse = zQueueStatus;

export const zGetFalAiLumaPhotonRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiLumaPhotonRequestsByRequestIdResponse = zLumaPhotonOutput;

export const zGetFalAiLightningModelsRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiLightningModelsRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiLightningModelsRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiLightningModelsRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiLightningModelsData = z.object({
  body: zLightningModelsInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiLightningModelsResponse = zQueueStatus;

export const zGetFalAiLightningModelsRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiLightningModelsRequestsByRequestIdResponse =
  zLightningModelsOutput;

export const zGetFalAiPlaygroundV25RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiPlaygroundV25RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiPlaygroundV25RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiPlaygroundV25RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiPlaygroundV25Data = z.object({
  body: zPlaygroundV25Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiPlaygroundV25Response = zQueueStatus;

export const zGetFalAiPlaygroundV25RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiPlaygroundV25RequestsByRequestIdResponse =
  zPlaygroundV25Output;

export const zGetFalAiRealisticVisionRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiRealisticVisionRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiRealisticVisionRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiRealisticVisionRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiRealisticVisionData = z.object({
  body: zRealisticVisionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiRealisticVisionResponse = zQueueStatus;

export const zGetFalAiRealisticVisionRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiRealisticVisionRequestsByRequestIdResponse =
  zRealisticVisionOutput;

export const zGetFalAiDreamshaperRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiDreamshaperRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiDreamshaperRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiDreamshaperRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiDreamshaperData = z.object({
  body: zDreamshaperInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiDreamshaperResponse = zQueueStatus;

export const zGetFalAiDreamshaperRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiDreamshaperRequestsByRequestIdResponse =
  zDreamshaperOutput;

export const zGetFalAiStableDiffusionV15RequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiStableDiffusionV15RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiStableDiffusionV15RequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiStableDiffusionV15RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiStableDiffusionV15Data = z.object({
  body: zStableDiffusionV15Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiStableDiffusionV15Response = zQueueStatus;

export const zGetFalAiStableDiffusionV15RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiStableDiffusionV15RequestsByRequestIdResponse =
  zStableDiffusionV15Output;

export const zGetFalAiLayerDiffusionRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiLayerDiffusionRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiLayerDiffusionRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiLayerDiffusionRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiLayerDiffusionData = z.object({
  body: zLayerDiffusionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiLayerDiffusionResponse = zQueueStatus;

export const zGetFalAiLayerDiffusionRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiLayerDiffusionRequestsByRequestIdResponse =
  zLayerDiffusionOutput;

export const zGetFalAiFastLightningSdxlRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiFastLightningSdxlRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFastLightningSdxlRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiFastLightningSdxlRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFastLightningSdxlData = z.object({
  body: zFastLightningSdxlInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFastLightningSdxlResponse = zQueueStatus;

export const zGetFalAiFastLightningSdxlRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFastLightningSdxlRequestsByRequestIdResponse =
  zFastLightningSdxlOutput;

export const zGetFalAiFastFooocusSdxlImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFastFooocusSdxlImageToImageRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFastFooocusSdxlImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFastFooocusSdxlImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFastFooocusSdxlImageToImageData = z.object({
  body: zFastFooocusSdxlImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFastFooocusSdxlImageToImageResponse = zQueueStatus;

export const zGetFalAiFastFooocusSdxlImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiFastFooocusSdxlImageToImageRequestsByRequestIdResponse =
  zFastFooocusSdxlImageToImageOutput;

export const zGetFalAiFastSdxlControlnetCannyRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFastSdxlControlnetCannyRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFastSdxlControlnetCannyRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFastSdxlControlnetCannyRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiFastSdxlControlnetCannyData = z.object({
  body: zFastSdxlControlnetCannyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFastSdxlControlnetCannyResponse = zQueueStatus;

export const zGetFalAiFastSdxlControlnetCannyRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * Result of the request.
 */
export const zGetFalAiFastSdxlControlnetCannyRequestsByRequestIdResponse =
  zFastSdxlControlnetCannyOutput;

export const zGetFalAiFastLcmDiffusionRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFastLcmDiffusionRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFastLcmDiffusionRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFastLcmDiffusionRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFastLcmDiffusionData = z.object({
  body: zFastLcmDiffusionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFastLcmDiffusionResponse = zQueueStatus;

export const zGetFalAiFastLcmDiffusionRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFastLcmDiffusionRequestsByRequestIdResponse =
  zFastLcmDiffusionOutput;

export const zGetFalAiFastFooocusSdxlRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFastFooocusSdxlRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFastFooocusSdxlRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFastFooocusSdxlRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFastFooocusSdxlData = z.object({
  body: zFastFooocusSdxlInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFastFooocusSdxlResponse = zQueueStatus;

export const zGetFalAiFastFooocusSdxlRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFastFooocusSdxlRequestsByRequestIdResponse =
  zFastFooocusSdxlOutput;

export const zGetFalAiIllusionDiffusionRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  },
);

/**
 * The request status.
 */
export const zGetFalAiIllusionDiffusionRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiIllusionDiffusionRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  },
);

/**
 * The request was cancelled.
 */
export const zPutFalAiIllusionDiffusionRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiIllusionDiffusionData = z.object({
  body: zIllusionDiffusionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiIllusionDiffusionResponse = zQueueStatus;

export const zGetFalAiIllusionDiffusionRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiIllusionDiffusionRequestsByRequestIdResponse =
  zIllusionDiffusionOutput;

export const zGetFalAiFooocusImagePromptRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFooocusImagePromptRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFooocusImagePromptRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFooocusImagePromptRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFooocusImagePromptData = z.object({
  body: zFooocusImagePromptInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFooocusImagePromptResponse = zQueueStatus;

export const zGetFalAiFooocusImagePromptRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFooocusImagePromptRequestsByRequestIdResponse =
  zFooocusImagePromptOutput;

export const zGetFalAiFooocusInpaintRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFooocusInpaintRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFooocusInpaintRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFooocusInpaintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFooocusInpaintData = z.object({
  body: zFooocusInpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFooocusInpaintResponse = zQueueStatus;

export const zGetFalAiFooocusInpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFooocusInpaintRequestsByRequestIdResponse =
  zFooocusInpaintOutput;

export const zGetFalAiLcmRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiLcmRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiLcmRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiLcmRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiLcmData = z.object({
  body: zLcmInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiLcmResponse = zQueueStatus;

export const zGetFalAiLcmRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiLcmRequestsByRequestIdResponse = zLcmOutput;

export const zGetFalAiDiffusionEdgeRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiDiffusionEdgeRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiDiffusionEdgeRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiDiffusionEdgeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiDiffusionEdgeData = z.object({
  body: zDiffusionEdgeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiDiffusionEdgeResponse = zQueueStatus;

export const zGetFalAiDiffusionEdgeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiDiffusionEdgeRequestsByRequestIdResponse =
  zDiffusionEdgeOutput;

export const zGetFalAiFooocusRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiFooocusRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiFooocusRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiFooocusRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFooocusData = z.object({
  body: zFooocusInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFooocusResponse = zQueueStatus;

export const zGetFalAiFooocusRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFooocusRequestsByRequestIdResponse = zFooocusOutput;

export const zGetFalAiLoraRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiLoraRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiLoraRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiLoraData = z.object({
  body: zLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiLoraResponse = zQueueStatus;

export const zGetFalAiLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiLoraRequestsByRequestIdResponse = zLoraOutput;
