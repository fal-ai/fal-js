// This file is auto-generated by @hey-api/openapi-ts

import { z } from "zod";

/**
 * UsageInfo
 */
export const zUsageInfo = z.object({
  completion_tokens: z.optional(z.union([z.int(), z.unknown()])),
  total_tokens: z.optional(z.int()).default(0),
  prompt_tokens: z.optional(z.union([z.int(), z.unknown()])),
  cost: z.number(),
});

/**
 * AudioOutput
 */
export const zRouterAudioOutput = z.object({
  usage: z.union([zUsageInfo, z.unknown()]),
  output: z.string().register(z.globalRegistry, {
    description: "Generated output from audio processing",
  }),
});

/**
 * AudioInput
 */
export const zRouterAudioInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "Prompt to be used for the audio processing",
  }),
  reasoning: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Should reasoning be the part of the final answer.",
      }),
    )
    .default(false),
  system_prompt: z.optional(z.union([z.string(), z.unknown()])),
  model: z.string().register(z.globalRegistry, {
    description:
      "Name of the model to use. Charged based on actual token usage.",
  }),
  max_tokens: z.optional(z.union([z.int().gte(1), z.unknown()])),
  temperature: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description:
          "This setting influences the variety in the model's responses. Lower values lead to more predictable and typical responses, while higher values encourage more diverse and less common responses. At 0, the model always gives the same response for a given input.",
      }),
    )
    .default(1),
  audio_url: z.union([z.string(), z.string()]),
});

/**
 * File
 */
export const zFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The size of the file in bytes.",
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "The name of the file. It will be auto-generated if not provided.",
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The mime type of the file.",
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: "The URL where the file can be downloaded from.",
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: "File data",
    }),
  ),
});

/**
 * Qwen3CloneVoiceOutput
 */
export const zQwen3TtsCloneVoice06bOutput = z.object({
  speaker_embedding: zFile,
});

/**
 * Qwen3CloneVoiceInput
 */
export const zQwen3TtsCloneVoice06bInput = z.object({
  audio_url: z.union([z.string(), z.string()]),
  reference_text: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "Optional reference text that was used when creating the speaker embedding. Providing this can improve synthesis quality when using a cloned voice.",
    }),
  ),
});

/**
 * Qwen3CloneVoiceOutput
 */
export const zQwen3TtsCloneVoice17bOutput = z.object({
  speaker_embedding: zFile,
});

/**
 * Qwen3CloneVoiceInput
 */
export const zQwen3TtsCloneVoice17bInput = z.object({
  audio_url: z.union([z.string(), z.string()]),
  reference_text: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "Optional reference text that was used when creating the speaker embedding. Providing this can improve synthesis quality when using a cloned voice.",
    }),
  ),
});

/**
 * InterleaveVideoOutput
 *
 * Output model for interleaved video
 */
export const zWorkflowUtilitiesInterleaveVideoOutput = z
  .object({
    video: zFile,
  })
  .register(z.globalRegistry, {
    description: "Output model for interleaved video",
  });

/**
 * InterleaveVideoInput
 *
 * Input model for interleaving multiple videos
 */
export const zWorkflowUtilitiesInterleaveVideoInput = z
  .object({
    video_urls: z.array(z.string()).register(z.globalRegistry, {
      description: "List of video URLs to interleave in order",
    }),
  })
  .register(z.globalRegistry, {
    description: "Input model for interleaving multiple videos",
  });

export const zQueueStatus = z.object({
  status: z.enum(["IN_QUEUE", "IN_PROGRESS", "COMPLETED"]),
  request_id: z.string().register(z.globalRegistry, {
    description: "The request id.",
  }),
  response_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The response url.",
    }),
  ),
  status_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The status url.",
    }),
  ),
  cancel_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The cancel url.",
    }),
  ),
  logs: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: "The logs.",
    }),
  ),
  metrics: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: "The metrics.",
    }),
  ),
  queue_position: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The queue position.",
    }),
  ),
});

export const zGetFalAiWorkflowUtilitiesInterleaveVideoRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiWorkflowUtilitiesInterleaveVideoRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiWorkflowUtilitiesInterleaveVideoRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiWorkflowUtilitiesInterleaveVideoRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiWorkflowUtilitiesInterleaveVideoData = z.object({
  body: zWorkflowUtilitiesInterleaveVideoInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiWorkflowUtilitiesInterleaveVideoResponse = zQueueStatus;

export const zGetFalAiWorkflowUtilitiesInterleaveVideoRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiWorkflowUtilitiesInterleaveVideoRequestsByRequestIdResponse =
  zWorkflowUtilitiesInterleaveVideoOutput;

export const zGetFalAiQwen3TtsCloneVoice17bRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwen3TtsCloneVoice17bRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwen3TtsCloneVoice17bRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwen3TtsCloneVoice17bRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiQwen3TtsCloneVoice17bData = z.object({
  body: zQwen3TtsCloneVoice17bInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwen3TtsCloneVoice17bResponse = zQueueStatus;

export const zGetFalAiQwen3TtsCloneVoice17bRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiQwen3TtsCloneVoice17bRequestsByRequestIdResponse =
  zQwen3TtsCloneVoice17bOutput;

export const zGetFalAiQwen3TtsCloneVoice06bRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiQwen3TtsCloneVoice06bRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiQwen3TtsCloneVoice06bRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiQwen3TtsCloneVoice06bRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiQwen3TtsCloneVoice06bData = z.object({
  body: zQwen3TtsCloneVoice06bInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiQwen3TtsCloneVoice06bResponse = zQueueStatus;

export const zGetFalAiQwen3TtsCloneVoice06bRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiQwen3TtsCloneVoice06bRequestsByRequestIdResponse =
  zQwen3TtsCloneVoice06bOutput;

export const zGetOpenrouterRouterAudioRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetOpenrouterRouterAudioRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutOpenrouterRouterAudioRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutOpenrouterRouterAudioRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostOpenrouterRouterAudioData = z.object({
  body: zRouterAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostOpenrouterRouterAudioResponse = zQueueStatus;

export const zGetOpenrouterRouterAudioRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetOpenrouterRouterAudioRequestsByRequestIdResponse =
  zRouterAudioOutput;
