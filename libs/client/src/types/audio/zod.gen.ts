// This file is auto-generated by @hey-api/openapi-ts

import { z } from "zod";

/**
 * Audio
 */
export const zAudio = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: "The URL where the file can be downloaded from.",
  }),
});

/**
 * AudioOutput
 */
export const zSfxV1VideoToAudioOutput = z.object({
  audio: z.array(zAudio).register(z.globalRegistry, {
    description: "The generated sound effects audio",
  }),
});

/**
 * Input
 */
export const zSfxV1VideoToAudioInput = z.object({
  num_samples: z.optional(z.union([z.int().gte(2).lte(8), z.unknown()])),
  video_url: z.union([z.string(), z.string()]),
  duration: z.optional(z.union([z.number().gte(1).lte(10), z.unknown()])),
  seed: z.optional(z.union([z.int().gte(1), z.unknown()])),
  text_prompt: z.optional(z.union([z.string(), z.unknown()])),
});

/**
 * File
 */
export const zFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The size of the file in bytes.",
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "The name of the file. It will be auto-generated if not provided.",
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The mime type of the file.",
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: "The URL where the file can be downloaded from.",
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: "File data",
    }),
  ),
});

/**
 * VideoToAudioOutput
 */
export const zKlingVideoVideoToAudioOutput = z.object({
  video: zFile,
  audio: zFile,
});

/**
 * VideoToAudioInput
 */
export const zKlingVideoVideoToAudioInput = z.object({
  video_url: z.union([z.string(), z.string()]),
  asmr_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Enable ASMR mode. This mode enhances detailed sound effects and is suitable for highly immersive content scenarios.",
      }),
    )
    .default(false),
  background_music_prompt: z
    .optional(
      z.string().max(200).register(z.globalRegistry, {
        description: "Background music prompt. Cannot exceed 200 characters.",
      }),
    )
    .default("intense car race"),
  sound_effect_prompt: z
    .optional(
      z.string().max(200).register(z.globalRegistry, {
        description: "Sound effect prompt. Cannot exceed 200 characters.",
      }),
    )
    .default("Car tires screech as they accelerate in a drag race"),
});

/**
 * Audio
 */
export const zAudioOutput = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: "The URL where the file can be downloaded from.",
  }),
});

/**
 * AudioOutput
 */
export const zSfxV15VideoToAudioOutput = z.object({
  audio: z.array(zAudioOutput).register(z.globalRegistry, {
    description: "The generated sound effects audio",
  }),
});

/**
 * Input
 */
export const zSfxV15VideoToAudioInput = z.object({
  num_samples: z.optional(z.union([z.int().gte(2).lte(8), z.unknown()])),
  duration: z.optional(z.union([z.number().gte(1).lte(10), z.unknown()])),
  start_offset: z.optional(z.union([z.number().gte(0), z.unknown()])),
  video_url: z.union([z.string(), z.string()]),
  seed: z.optional(z.union([z.int().gte(1), z.unknown()])),
  text_prompt: z.optional(z.union([z.string(), z.unknown()])),
});

/**
 * SAMAudioVisualSeparateOutput
 *
 * Output for visual-prompted audio separation.
 */
export const zSamAudioVisualSeparateOutput = z
  .object({
    target: zFile,
    duration: z.number().register(z.globalRegistry, {
      description: "Duration of the output audio in seconds.",
    }),
    sample_rate: z
      .optional(
        z.int().register(z.globalRegistry, {
          description: "Sample rate of the output audio in Hz.",
        }),
      )
      .default(48000),
    residual: zFile,
  })
  .register(z.globalRegistry, {
    description: "Output for visual-prompted audio separation.",
  });

/**
 * SAMAudioVisualInput
 *
 * Input for visual-prompted audio separation.
 */
export const zSamAudioVisualSeparateInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Text prompt to assist with separation. Use natural language to describe the target sound.",
        }),
      )
      .default(""),
    video_url: z.union([z.string(), z.string()]),
    acceleration: z.optional(
      z.enum(["fast", "balanced", "quality"]).register(z.globalRegistry, {
        description: "The acceleration level to use.",
      }),
    ),
    mask_video_url: z.optional(z.union([z.string(), z.string()])),
    output_format: z.optional(
      z.enum(["wav", "mp3"]).register(z.globalRegistry, {
        description: "Output audio format.",
      }),
    ),
    reranking_candidates: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description:
            "Number of candidates to generate and rank. Higher improves quality but increases latency and cost.",
        }),
      )
      .default(1),
  })
  .register(z.globalRegistry, {
    description: "Input for visual-prompted audio separation.",
  });

/**
 * File
 */
export const zFileType2 = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: "The URL where the file can be downloaded from.",
  }),
});

/**
 * Output
 */
export const zStableAudioOutput = z.object({
  audio_file: zFileType2,
});

/**
 * Input
 */
export const zStableAudioInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate audio from",
  }),
  steps: z
    .optional(
      z.int().gte(1).lte(1000).register(z.globalRegistry, {
        description: "The number of steps to denoise the audio for",
      }),
    )
    .default(100),
  seconds_total: z
    .optional(
      z.int().gte(0).lte(47).register(z.globalRegistry, {
        description: "The duration of the audio clip to generate",
      }),
    )
    .default(30),
  seconds_start: z
    .optional(
      z.int().gte(0).lte(47).register(z.globalRegistry, {
        description: "The start point of the audio clip to generate",
      }),
    )
    .default(0),
});

/**
 * AudioFile
 */
export const zAudioFileType2 = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z
    .optional(z.string())
    .default("8535dd59e911496a947daa35c07e67a3_tmplkcy6tut.wav"),
  content_type: z.optional(z.string()).default("audio/wav"),
  url: z.string(),
});

/**
 * TTSOutput
 */
export const zF5TtsOutput = z.object({
  audio_url: zAudioFileType2,
});

/**
 * TTSInput
 */
export const zF5TtsInput = z.object({
  ref_text: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The reference text to be used for TTS. If not provided, an ASR (Automatic Speech Recognition) model will be used to generate the reference text.",
      }),
    )
    .default(""),
  remove_silence: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to remove the silence from the audio file.",
      }),
    )
    .default(true),
  gen_text: z.string().register(z.globalRegistry, {
    description: "The text to be converted to speech.",
  }),
  model_type: z.enum(["F5-TTS", "E2-TTS"]).register(z.globalRegistry, {
    description: "The name of the model to be used for TTS.",
  }),
  ref_audio_url: z.union([z.string(), z.string()]),
});

/**
 * MusicOutput
 */
export const zMinimaxMusicOutput = z.object({
  audio: zFile,
});

/**
 * TextToMusicRequest
 */
export const zMinimaxMusicInput = z.object({
  prompt: z.string().min(1).max(600).register(z.globalRegistry, {
    description:
      "Lyrics with optional formatting. You can use a newline to separate each line of lyrics. You can use two newlines to add a pause between lines. You can use double hash marks (##) at the beginning and end of the lyrics to add accompaniment. Maximum 600 characters.",
  }),
  reference_audio_url: z.union([z.string(), z.string()]),
});

/**
 * AudioOutput
 */
export const zMmaudioV2TextToAudioOutput = z.object({
  audio: zFile,
});

/**
 * AudioInput
 */
export const zMmaudioV2TextToAudioInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate the audio for.",
  }),
  num_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: "The number of steps to generate the audio for.",
      }),
    )
    .default(25),
  duration: z
    .optional(
      z.number().gte(1).lte(30).register(z.globalRegistry, {
        description: "The duration of the audio to generate.",
      }),
    )
    .default(8),
  cfg_strength: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: "The strength of Classifier Free Guidance.",
      }),
    )
    .default(4.5),
  seed: z.optional(
    z.int().gte(0).lte(65535).register(z.globalRegistry, {
      description: "The seed for the random number generator",
    }),
  ),
  mask_away_clip: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to mask away the clip.",
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The negative prompt to generate the audio for.",
      }),
    )
    .default(""),
});

/**
 * Output
 */
export const zYueOutput = z.object({
  audio: zFile,
});

/**
 * TextToMusicInput
 */
export const zYueInput = z.object({
  lyrics: z.string().register(z.globalRegistry, {
    description:
      "The prompt to generate an image from. Must have two sections. Sections start with either [chorus] or a [verse].",
  }),
  genres: z.string().register(z.globalRegistry, {
    description:
      "The genres (separated by a space ' ') to guide the music generation.",
  }),
});

/**
 * SpanishOutput
 */
export const zKokoroSpanishOutput = z.object({
  audio: zFile,
});

/**
 * SpanishRequest
 */
export const zKokoroSpanishInput = z.object({
  prompt: z.string(),
  voice: z.enum(["ef_dora", "em_alex", "em_santa"]).register(z.globalRegistry, {
    description: "Voice ID for the desired voice.",
  }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: "Speed of the generated audio. Default is 1.0.",
      }),
    )
    .default(1),
});

/**
 * MandarinOutput
 */
export const zKokoroMandarinChineseOutput = z.object({
  audio: zFile,
});

/**
 * MandarinRequest
 */
export const zKokoroMandarinChineseInput = z.object({
  prompt: z.string(),
  voice: z
    .enum([
      "zf_xiaobei",
      "zf_xiaoni",
      "zf_xiaoxiao",
      "zf_xiaoyi",
      "zm_yunjian",
      "zm_yunxi",
      "zm_yunxia",
      "zm_yunyang",
    ])
    .register(z.globalRegistry, {
      description: "Voice ID for the desired voice.",
    }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: "Speed of the generated audio. Default is 1.0.",
      }),
    )
    .default(1),
});

/**
 * JapaneseOutput
 */
export const zKokoroJapaneseOutput = z.object({
  audio: zFile,
});

/**
 * JapaneseRequest
 */
export const zKokoroJapaneseInput = z.object({
  prompt: z.string(),
  voice: z
    .enum(["jf_alpha", "jf_gongitsune", "jf_nezumi", "jf_tebukuro", "jm_kumo"])
    .register(z.globalRegistry, {
      description: "Voice ID for the desired voice.",
    }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: "Speed of the generated audio. Default is 1.0.",
      }),
    )
    .default(1),
});

/**
 * FrenchOutput
 */
export const zKokoroFrenchOutput = z.object({
  audio: zFile,
});

/**
 * FrenchRequest
 */
export const zKokoroFrenchInput = z.object({
  prompt: z.string(),
  voice: z.enum(["ff_siwis"]).register(z.globalRegistry, {
    description: "Voice ID for the desired voice.",
  }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: "Speed of the generated audio. Default is 1.0.",
      }),
    )
    .default(1),
});

/**
 * BrPortugeseOutput
 */
export const zKokoroBrazilianPortugueseOutput = z.object({
  audio: zFile,
});

/**
 * BrPortugueseRequest
 */
export const zKokoroBrazilianPortugueseInput = z.object({
  prompt: z.string(),
  voice: z.enum(["pf_dora", "pm_alex", "pm_santa"]).register(z.globalRegistry, {
    description: "Voice ID for the desired voice.",
  }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: "Speed of the generated audio. Default is 1.0.",
      }),
    )
    .default(1),
});

/**
 * ItalianOutput
 */
export const zKokoroItalianOutput = z.object({
  audio: zFile,
});

/**
 * ItalianRequest
 */
export const zKokoroItalianInput = z.object({
  prompt: z.string(),
  voice: z.enum(["if_sara", "im_nicola"]).register(z.globalRegistry, {
    description: "Voice ID for the desired voice.",
  }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: "Speed of the generated audio. Default is 1.0.",
      }),
    )
    .default(1),
});

/**
 * ZonosOutput
 */
export const zZonosOutput = z.object({
  audio: zFile,
});

/**
 * ZonosInput
 */
export const zZonosInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The content generated using cloned voice.",
  }),
  reference_audio_url: z.union([z.string(), z.string()]),
});

/**
 * AmEngOutput
 */
export const zKokoroAmericanEnglishOutput = z.object({
  audio: zFile,
});

/**
 * AmEnglishRequest
 */
export const zKokoroAmericanEnglishInput = z.object({
  prompt: z.optional(z.string()).default(""),
  voice: z.optional(
    z
      .enum([
        "af_heart",
        "af_alloy",
        "af_aoede",
        "af_bella",
        "af_jessica",
        "af_kore",
        "af_nicole",
        "af_nova",
        "af_river",
        "af_sarah",
        "af_sky",
        "am_adam",
        "am_echo",
        "am_eric",
        "am_fenrir",
        "am_liam",
        "am_michael",
        "am_onyx",
        "am_puck",
        "am_santa",
      ])
      .register(z.globalRegistry, {
        description: "Voice ID for the desired voice.",
      }),
  ),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: "Speed of the generated audio. Default is 1.0.",
      }),
    )
    .default(1),
});

/**
 * BrEngOutput
 */
export const zKokoroBritishEnglishOutput = z.object({
  audio: zFile,
});

/**
 * BrEnglishRequest
 */
export const zKokoroBritishEnglishInput = z.object({
  prompt: z.string(),
  voice: z
    .enum([
      "bf_alice",
      "bf_emma",
      "bf_isabella",
      "bf_lily",
      "bm_daniel",
      "bm_fable",
      "bm_george",
      "bm_lewis",
    ])
    .register(z.globalRegistry, {
      description: "Voice ID for the desired voice.",
    }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: "Speed of the generated audio. Default is 1.0.",
      }),
    )
    .default(1),
});

/**
 * HindiOutput
 */
export const zKokoroHindiOutput = z.object({
  audio: zFile,
});

/**
 * HindiRequest
 */
export const zKokoroHindiInput = z.object({
  prompt: z.string(),
  voice: z
    .enum(["hf_alpha", "hf_beta", "hm_omega", "hm_psi"])
    .register(z.globalRegistry, {
      description: "Voice ID for the desired voice.",
    }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: "Speed of the generated audio. Default is 1.0.",
      }),
    )
    .default(1),
});

/**
 * TTSOutput
 */
export const zElevenlabsTtsMultilingualV2Output = z.object({
  audio: zFileType2,
  timestamps: z.optional(z.union([z.array(z.unknown()), z.unknown()])),
});

/**
 * TextToSpeechRequest
 */
export const zElevenlabsTtsMultilingualV2Input = z.object({
  text: z.string().min(1).register(z.globalRegistry, {
    description: "The text to convert to speech",
  }),
  next_text: z.optional(z.union([z.string(), z.unknown()])),
  speed: z
    .optional(
      z.number().gte(0.7).lte(1.2).register(z.globalRegistry, {
        description:
          "Speech speed (0.7-1.2). Values below 1.0 slow down the speech, above 1.0 speed it up. Extreme values may affect quality.",
      }),
    )
    .default(1),
  style: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Style exaggeration (0-1)",
      }),
    )
    .default(0),
  stability: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Voice stability (0-1)",
      }),
    )
    .default(0.5),
  timestamps: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to return timestamps for each word in the generated speech",
      }),
    )
    .default(false),
  similarity_boost: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: "Similarity boost (0-1)",
      }),
    )
    .default(0.75),
  voice: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The voice to use for speech generation",
      }),
    )
    .default("Rachel"),
  language_code: z.optional(z.union([z.string(), z.unknown()])),
  apply_text_normalization: z.optional(
    z.enum(["auto", "on", "off"]).register(z.globalRegistry, {
      description:
        "This parameter controls text normalization with three modes: 'auto', 'on', and 'off'. When set to 'auto', the system will automatically decide whether to apply text normalization (e.g., spelling out numbers). With 'on', text normalization will always be applied, while with 'off', it will be skipped.",
    }),
  ),
  previous_text: z.optional(z.union([z.string(), z.unknown()])),
});

/**
 * Output
 */
export const zDiffrhythmOutput = z.object({
  audio: zFile,
});

/**
 * TextToMusicInput
 */
export const zDiffrhythmInput = z.object({
  lyrics: z.string().register(z.globalRegistry, {
    description:
      "The prompt to generate the song from. Must have two sections. Sections start with either [chorus] or a [verse].",
  }),
  cfg_strength: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: "The CFG strength to use for the music generation.",
      }),
    )
    .default(4),
  reference_audio_url: z.optional(z.union([z.string(), z.string()])),
  music_duration: z.optional(
    z.enum(["95s", "285s"]).register(z.globalRegistry, {
      description: "The duration of the music to generate.",
    }),
  ),
  scheduler: z.optional(
    z
      .enum(["euler", "midpoint", "rk4", "implicit_adams"])
      .register(z.globalRegistry, {
        description: "The scheduler to use for the music generation.",
      }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(100).register(z.globalRegistry, {
        description:
          "The number of inference steps to use for the music generation.",
      }),
    )
    .default(32),
  style_prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The style prompt to use for the music generation.",
    }),
  ),
});

/**
 * Speaker
 */
export const zSpeaker = z.object({
  prompt: z.string(),
  audio_url: z.string(),
  speaker_id: z.int(),
});

/**
 * Turn
 */
export const zTurn = z.object({
  text: z.string(),
  speaker_id: z.int(),
});

/**
 * Output
 */
export const zCsm1bOutput = z.object({
  audio: z.union([zFileType2, z.string()]),
});

/**
 * Input
 */
export const zCsm1bInput = z.object({
  scene: z.array(zTurn).register(z.globalRegistry, {
    description: "The text to generate an audio from.",
  }),
  context: z.optional(
    z.array(zSpeaker).register(z.globalRegistry, {
      description: "The context to generate an audio from.",
    }),
  ),
});

/**
 * AudioOutput
 *
 * Example Pydantic model showing how to include a File in the output.
 */
export const zMusicGeneratorOutput = z
  .object({
    audio_file: zFileType2,
  })
  .register(z.globalRegistry, {
    description:
      "Example Pydantic model showing how to include a File in the output.",
  });

/**
 * Input
 */
export const zMusicGeneratorInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate music from.",
  }),
  duration: z.int().gte(10).lte(180).register(z.globalRegistry, {
    description: "The duration of the generated music in seconds.",
  }),
});

/**
 * AudioOutput
 *
 * Example Pydantic model showing how to include a File in the output.
 */
export const zSoundEffectsGeneratorOutput = z
  .object({
    audio_file: zFileType2,
  })
  .register(z.globalRegistry, {
    description:
      "Example Pydantic model showing how to include a File in the output.",
  });

/**
 * Input
 */
export const zSoundEffectsGeneratorInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate SFX.",
  }),
  duration: z.int().gte(1).lte(30).register(z.globalRegistry, {
    description: "The duration of the generated SFX in seconds.",
  }),
});

/**
 * ACEStepResponse
 */
export const zAceStepOutput = z.object({
  tags: z.string().register(z.globalRegistry, {
    description: "The genre tags used in the generation process.",
  }),
  lyrics: z.string().register(z.globalRegistry, {
    description: "The lyrics used in the generation process.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The random seed used for the generation process.",
  }),
  audio: zFile,
});

/**
 * ACEStepTextToAudioRequest
 */
export const zAceStepInput = z.object({
  number_of_steps: z
    .optional(
      z.int().gte(3).lte(60).register(z.globalRegistry, {
        description: "Number of steps to generate the audio.",
      }),
    )
    .default(27),
  duration: z
    .optional(
      z.number().gte(5).lte(240).register(z.globalRegistry, {
        description: "The duration of the generated audio in seconds.",
      }),
    )
    .default(60),
  tags: z.string().register(z.globalRegistry, {
    description:
      "Comma-separated list of genre tags to control the style of the generated audio.",
  }),
  minimum_guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description:
          "Minimum guidance scale for the generation after the decay.",
      }),
    )
    .default(3),
  lyrics: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Lyrics to be sung in the audio. If not provided or if [inst] or [instrumental] is the content of this field, no lyrics will be sung. Use control structures like [verse], [chorus] and [bridge] to control the structure of the song.",
      }),
    )
    .default(""),
  tag_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: "Tag guidance scale for the generation.",
      }),
    )
    .default(5),
  scheduler: z.optional(
    z.enum(["euler", "heun"]).register(z.globalRegistry, {
      description: "Scheduler to use for the generation process.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description: "Guidance scale for the generation.",
      }),
    )
    .default(15),
  guidance_type: z.optional(
    z.enum(["cfg", "apg", "cfg_star"]).register(z.globalRegistry, {
      description: "Type of CFG to use for the generation process.",
    }),
  ),
  lyric_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: "Lyric guidance scale for the generation.",
      }),
    )
    .default(1.5),
  guidance_interval: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "Guidance interval for the generation. 0.5 means only apply guidance in the middle steps (0.25 * infer_steps to 0.75 * infer_steps)",
      }),
    )
    .default(0.5),
  guidance_interval_decay: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "Guidance interval decay for the generation. Guidance scale will decay from guidance_scale to min_guidance_scale in the interval. 0.0 means no decay.",
      }),
    )
    .default(0),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed for reproducibility. If not provided, a random seed will be used.",
    }),
  ),
  granularity_scale: z
    .optional(
      z.int().gte(-100).lte(100).register(z.globalRegistry, {
        description:
          "Granularity scale for the generation process. Higher values can reduce artifacts.",
      }),
    )
    .default(10),
});

/**
 * ACEStepResponse
 */
export const zAceStepPromptToAudioOutput = z.object({
  tags: z.string().register(z.globalRegistry, {
    description: "The genre tags used in the generation process.",
  }),
  lyrics: z.string().register(z.globalRegistry, {
    description: "The lyrics used in the generation process.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The random seed used for the generation process.",
  }),
  audio: zFile,
});

/**
 * ACEStepPromptToAudioRequest
 */
export const zAceStepPromptToAudioInput = z.object({
  number_of_steps: z
    .optional(
      z.int().gte(3).lte(60).register(z.globalRegistry, {
        description: "Number of steps to generate the audio.",
      }),
    )
    .default(27),
  duration: z
    .optional(
      z.number().gte(5).lte(240).register(z.globalRegistry, {
        description: "The duration of the generated audio in seconds.",
      }),
    )
    .default(60),
  prompt: z.string().register(z.globalRegistry, {
    description:
      "Prompt to control the style of the generated audio. This will be used to generate tags and lyrics.",
  }),
  minimum_guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description:
          "Minimum guidance scale for the generation after the decay.",
      }),
    )
    .default(3),
  tag_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: "Tag guidance scale for the generation.",
      }),
    )
    .default(5),
  scheduler: z.optional(
    z.enum(["euler", "heun"]).register(z.globalRegistry, {
      description: "Scheduler to use for the generation process.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description: "Guidance scale for the generation.",
      }),
    )
    .default(15),
  guidance_type: z.optional(
    z.enum(["cfg", "apg", "cfg_star"]).register(z.globalRegistry, {
      description: "Type of CFG to use for the generation process.",
    }),
  ),
  instrumental: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to generate an instrumental version of the audio.",
      }),
    )
    .default(false),
  lyric_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: "Lyric guidance scale for the generation.",
      }),
    )
    .default(1.5),
  guidance_interval: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "Guidance interval for the generation. 0.5 means only apply guidance in the middle steps (0.25 * infer_steps to 0.75 * infer_steps)",
      }),
    )
    .default(0.5),
  guidance_interval_decay: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "Guidance interval decay for the generation. Guidance scale will decay from guidance_scale to min_guidance_scale in the interval. 0.0 means no decay.",
      }),
    )
    .default(0),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed for reproducibility. If not provided, a random seed will be used.",
    }),
  ),
  granularity_scale: z
    .optional(
      z.int().gte(-100).lte(100).register(z.globalRegistry, {
        description:
          "Granularity scale for the generation process. Higher values can reduce artifacts.",
      }),
    )
    .default(10),
});

/**
 * TextToMusicOutput
 */
export const zLyria2Output = z.object({
  audio: zFile,
});

/**
 * TextToMusicInput
 */
export const zLyria2Input = z.object({
  prompt: z.string().min(1).max(2000).register(z.globalRegistry, {
    description: "The text prompt describing the music you want to generate",
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "A seed for deterministic generation. If provided, the model will attempt to produce the same audio given the same prompt and other parameters.",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "A description of what to exclude from the generated audio",
      }),
    )
    .default("low quality"),
});

/**
 * TTSOutput
 */
export const zElevenlabsTtsElevenV3Output = z.object({
  audio: zFileType2,
  timestamps: z.optional(z.union([z.array(z.unknown()), z.unknown()])),
});

/**
 * TextToSpeechRequestV3
 *
 * Request model for eleven_v3 which doesn't support previous_text/next_text
 */
export const zElevenlabsTtsElevenV3Input = z
  .object({
    text: z.string().min(1).max(5000).register(z.globalRegistry, {
      description: "The text to convert to speech",
    }),
    stability: z
      .optional(
        z.number().gte(0).lte(1).register(z.globalRegistry, {
          description: "Voice stability (0-1)",
        }),
      )
      .default(0.5),
    speed: z
      .optional(
        z.number().gte(0.7).lte(1.2).register(z.globalRegistry, {
          description:
            "Speech speed (0.7-1.2). Values below 1.0 slow down the speech, above 1.0 speed it up. Extreme values may affect quality.",
        }),
      )
      .default(1),
    style: z
      .optional(
        z.number().gte(0).lte(1).register(z.globalRegistry, {
          description: "Style exaggeration (0-1)",
        }),
      )
      .default(0),
    timestamps: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to return timestamps for each word in the generated speech",
        }),
      )
      .default(false),
    similarity_boost: z
      .optional(
        z.number().gte(0).lte(1).register(z.globalRegistry, {
          description: "Similarity boost (0-1)",
        }),
      )
      .default(0.75),
    voice: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: "The voice to use for speech generation",
        }),
      )
      .default("Rachel"),
    language_code: z.optional(z.union([z.string(), z.unknown()])),
    apply_text_normalization: z.optional(
      z.enum(["auto", "on", "off"]).register(z.globalRegistry, {
        description:
          "This parameter controls text normalization with three modes: 'auto', 'on', and 'off'. When set to 'auto', the system will automatically decide whether to apply text normalization (e.g., spelling out numbers). With 'on', text normalization will always be applied, while with 'off', it will be skipped.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description:
      "Request model for eleven_v3 which doesn't support previous_text/next_text",
  });

/**
 * GenerateOutput
 */
export const zV2TextToMusicOutput = z.object({
  tags: z.optional(z.union([z.array(z.string()), z.unknown()])),
  seed: z.int().register(z.globalRegistry, {
    description:
      "The seed used for generation. This can be used to generate an identical song by passing the same parameters with this seed in a future request.",
  }),
  lyrics: z.optional(z.union([z.string(), z.unknown()])),
  audio: z.array(zFileType2).register(z.globalRegistry, {
    description: "The generated audio files.",
  }),
});

/**
 * GenerateInput
 */
export const zV2TextToMusicInput = z.object({
  prompt: z.optional(z.union([z.string(), z.unknown()])),
  lyrics_prompt: z.optional(z.union([z.string(), z.unknown()])),
  tags: z.optional(z.union([z.array(z.string()), z.unknown()])),
  prompt_strength: z
    .optional(
      z.number().gte(1.4).lte(3.1).register(z.globalRegistry, {
        description:
          "Controls how strongly your prompt influences the output. Greater values adhere more to the prompt but sound less natural. (This is CFG.)",
      }),
    )
    .default(2),
  output_bit_rate: z.optional(
    z.union([
      z.union([z.literal(128), z.literal(192), z.literal(256), z.literal(320)]),
      z.unknown(),
    ]),
  ),
  num_songs: z
    .optional(
      z.int().gte(1).lte(2).register(z.globalRegistry, {
        description:
          "Generating 2 songs costs 1.5x the price of generating 1 song. Also, note that using the same seed may not result in identical songs if the number of songs generated is changed.",
      }),
    )
    .default(1),
  output_format: z.optional(z.enum(["flac", "mp3", "wav", "ogg", "m4a"])),
  bpm: z.optional(z.union([z.int(), z.string(), z.unknown()])),
  balance_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "Greater means more natural vocals. Lower means sharper instrumentals. We recommend 0.7.",
      }),
    )
    .default(0.7),
  seed: z.optional(
    z.union([
      z.int().gte(-9223372036854776000).lte(9223372036854776000),
      z.unknown(),
    ]),
  ),
});

/**
 * InpaintSection
 */
export const zInpaintSection = z.object({
  end: z.number().register(z.globalRegistry, {
    description: "End time in seconds of the section to inpaint.",
  }),
  start: z.number().gte(0).register(z.globalRegistry, {
    description: "Start time in seconds of the section to inpaint.",
  }),
});

/**
 * InpaintOutput
 */
export const zV2InpaintOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description:
      "The seed used for generation. This can be used to generate an identical song by passing the same parameters with this seed in a future request.",
  }),
  audio: z.array(zFileType2).register(z.globalRegistry, {
    description: "The generated audio files.",
  }),
});

/**
 * InpaintInput
 */
export const zV2InpaintInput = z.object({
  lyrics_prompt: z.string().register(z.globalRegistry, {
    description:
      "The lyrics sung in the generated song. An empty string will generate an instrumental track.",
  }),
  tags: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        "Tags/styles of the music to generate. You can view a list of all available tags at https://sonauto.ai/tag-explorer.",
    }),
  ),
  prompt_strength: z
    .optional(
      z.number().gte(1.4).lte(3.1).register(z.globalRegistry, {
        description:
          "Controls how strongly your prompt influences the output. Greater values adhere more to the prompt but sound less natural. (This is CFG.)",
      }),
    )
    .default(2),
  output_bit_rate: z.optional(
    z.union([
      z.union([z.literal(128), z.literal(192), z.literal(256), z.literal(320)]),
      z.unknown(),
    ]),
  ),
  num_songs: z
    .optional(
      z.int().gte(1).lte(2).register(z.globalRegistry, {
        description:
          "Generating 2 songs costs 1.5x the price of generating 1 song. Also, note that using the same seed may not result in identical songs if the number of songs generated is changed.",
      }),
    )
    .default(1),
  output_format: z.optional(z.enum(["flac", "mp3", "wav", "ogg", "m4a"])),
  selection_crop: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Crop to the selected region",
      }),
    )
    .default(false),
  sections: z.array(zInpaintSection).register(z.globalRegistry, {
    description:
      "List of sections to inpaint. Currently, only one section is supported so the list length must be 1.",
  }),
  balance_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "Greater means more natural vocals. Lower means sharper instrumentals. We recommend 0.7.",
      }),
    )
    .default(0.7),
  audio_url: z.union([z.string(), z.string()]),
  seed: z.optional(
    z.union([
      z.int().gte(-9223372036854776000).lte(9223372036854776000),
      z.unknown(),
    ]),
  ),
});

/**
 * SoundEffectOutput
 *
 * Output format for generated sound effects
 */
export const zElevenlabsSoundEffectsV2Output = z
  .object({
    audio: zFileType2,
  })
  .register(z.globalRegistry, {
    description: "Output format for generated sound effects",
  });

/**
 * SoundEffectRequestV2
 */
export const zElevenlabsSoundEffectsV2Input = z.object({
  text: z.string().register(z.globalRegistry, {
    description: "The text describing the sound effect to generate",
  }),
  loop: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to create a sound effect that loops smoothly.",
      }),
    )
    .default(false),
  prompt_influence: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "How closely to follow the prompt (0-1). Higher values mean less variation.",
      }),
    )
    .default(0.3),
  output_format: z.optional(
    z
      .enum([
        "mp3_22050_32",
        "mp3_44100_32",
        "mp3_44100_64",
        "mp3_44100_96",
        "mp3_44100_128",
        "mp3_44100_192",
        "pcm_8000",
        "pcm_16000",
        "pcm_22050",
        "pcm_24000",
        "pcm_44100",
        "pcm_48000",
        "ulaw_8000",
        "alaw_8000",
        "opus_48000_32",
        "opus_48000_64",
        "opus_48000_96",
        "opus_48000_128",
        "opus_48000_192",
      ])
      .register(z.globalRegistry, {
        description:
          "Output format of the generated audio. Formatted as codec_sample_rate_bitrate.",
      }),
  ),
  duration_seconds: z.optional(
    z.union([z.number().gte(0.5).lte(22), z.unknown()]),
  ),
});

/**
 * PronunciationDictionaryLocator
 */
export const zPronunciationDictionaryLocator = z.object({
  version_id: z.optional(z.union([z.string(), z.unknown()])),
  pronunciation_dictionary_id: z.union([z.string(), z.unknown()]),
});

/**
 * DialogueBlock
 */
export const zDialogueBlock = z.object({
  text: z.string().register(z.globalRegistry, {
    description: "The dialogue text",
  }),
  voice: z.string().register(z.globalRegistry, {
    description:
      "The name or the ID of the voice to be used for the generation.",
  }),
});

/**
 * TextToDialogueOutput
 */
export const zElevenlabsTextToDialogueElevenV3Output = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: "Random seed for reproducibility.",
  }),
  audio: zFileType2,
});

/**
 * TextToDialogueRequest
 */
export const zElevenlabsTextToDialogueElevenV3Input = z.object({
  stability: z.optional(z.union([z.number().gte(0).lte(1), z.unknown()])),
  inputs: z.array(zDialogueBlock).register(z.globalRegistry, {
    description:
      "A list of dialogue inputs, each containing text and a voice ID which will be converted into speech.",
  }),
  language_code: z.optional(z.union([z.string(), z.unknown()])),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  use_speaker_boost: z.optional(z.union([z.boolean(), z.unknown()])),
  pronunciation_dictionary_locators: z
    .optional(
      z.array(zPronunciationDictionaryLocator).register(z.globalRegistry, {
        description:
          "A list of pronunciation dictionary locators (id, version_id) to be applied to the text. They will be applied in order. You may have up to 3 locators per request",
      }),
    )
    .default([]),
});

/**
 * TextToAudioOutput
 */
export const zStableAudio25TextToAudioOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: "The random seed used for generation",
  }),
  audio: zFile,
});

/**
 * TextToAudioInput
 */
export const zStableAudio25TextToAudioInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to generate audio from",
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seconds_total: z
    .optional(
      z.int().gte(1).lte(190).register(z.globalRegistry, {
        description: "The duration of the audio clip to generate",
      }),
    )
    .default(190),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(8).register(z.globalRegistry, {
        description: "The number of steps to denoise the audio for",
      }),
    )
    .default(8),
  guidance_scale: z
    .optional(
      z.int().gte(1).lte(25).register(z.globalRegistry, {
        description:
          "How strictly the diffusion process adheres to the prompt text (higher values make your audio closer to your prompt).",
      }),
    )
    .default(1),
  seed: z.optional(z.int()),
});

/**
 * MusicV15Output
 */
export const zMinimaxMusicV15Output = z.object({
  audio: zFile,
});

/**
 * AudioSetting
 */
export const zAudioSetting = z.object({
  format: z.optional(
    z.enum(["mp3", "pcm", "flac"]).register(z.globalRegistry, {
      description: "Audio format",
    }),
  ),
  sample_rate: z.optional(
    z
      .union([
        z.literal(8000),
        z.literal(16000),
        z.literal(22050),
        z.literal(24000),
        z.literal(32000),
        z.literal(44100),
      ])
      .register(z.globalRegistry, {
        description: "Sample rate of generated audio",
      }),
  ),
  bitrate: z.optional(
    z
      .union([
        z.literal(32000),
        z.literal(64000),
        z.literal(128000),
        z.literal(256000),
      ])
      .register(z.globalRegistry, {
        description: "Bitrate of generated audio",
      }),
  ),
});

/**
 * TextToMusic15Request
 */
export const zMinimaxMusicV15Input = z.object({
  prompt: z.string().min(10).max(600).register(z.globalRegistry, {
    description:
      "Lyrics, supports [intro][verse][chorus][bridge][outro] sections. 10-600 characters.",
  }),
  lyrics_prompt: z.string().min(10).max(3000).register(z.globalRegistry, {
    description: "Control music generation. 10-3000 characters.",
  }),
  audio_setting: z.optional(zAudioSetting),
});

/**
 * MusicGenerationOutput
 *
 * Output schema for music generation.
 */
export const zMusicGenerationOutput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: "The processed prompt used for generation",
    }),
    metadata: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description:
        "Generation metadata including duration, sample rate, and parameters",
    }),
    audio: zFileType2,
  })
  .register(z.globalRegistry, {
    description: "Output schema for music generation.",
  });

/**
 * MusicGenerationInput
 *
 * Input schema for music generation with form controls for the playground.
 */
export const zMusicGenerationInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: "Describe the music you want to generate",
    }),
    duration: z
      .optional(
        z.number().gte(5).lte(150).register(z.globalRegistry, {
          description: "Length of the generated music in seconds",
        }),
      )
      .default(90),
    refinement: z
      .optional(
        z.int().gte(10).lte(200).register(z.globalRegistry, {
          description:
            "Refinement level - higher values may improve quality but take longer",
        }),
      )
      .default(100),
    seed: z.optional(z.union([z.int().gte(0).lte(2147483647), z.unknown()])),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Describe what you want to avoid in the music (instruments, styles, moods). Leave blank for none.",
        }),
      )
      .default(""),
    creativity: z
      .optional(
        z.number().gte(1).lte(20).register(z.globalRegistry, {
          description:
            "Creativity level - higher values allow more creative interpretation of the prompt",
        }),
      )
      .default(16),
  })
  .register(z.globalRegistry, {
    description:
      "Input schema for music generation with form controls for the playground.",
  });

/**
 * SoundEffectGenerationOutput
 *
 * Output schema for sound effect generation.
 */
export const zSoundEffectGenerationOutput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: "The processed prompt used for generation",
    }),
    metadata: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description:
        "Generation metadata including duration, sample rate, and parameters",
    }),
    audio: zFileType2,
  })
  .register(z.globalRegistry, {
    description: "Output schema for sound effect generation.",
  });

/**
 * SoundEffectGenerationInput
 *
 * Input schema for sound effect generation with form controls for the playground.
 */
export const zSoundEffectGenerationInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: "Describe the sound effect you want to generate",
    }),
    duration: z
      .optional(
        z.number().gte(1).lte(35).register(z.globalRegistry, {
          description: "Length of the generated sound effect in seconds",
        }),
      )
      .default(5),
    refinement: z
      .optional(
        z.int().gte(10).lte(200).register(z.globalRegistry, {
          description:
            "Refinement level - Higher values may improve quality but take longer",
        }),
      )
      .default(40),
    seed: z.optional(z.union([z.int().gte(0).lte(2147483647), z.unknown()])),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Describe the types of sounds you don't want to generate in the output, avoid double-negatives, compare with positive prompts",
        }),
      )
      .default(""),
    creativity: z
      .optional(
        z.number().gte(1).lte(20).register(z.globalRegistry, {
          description:
            "Creativity level - higher values allow more creative interpretation of the prompt",
        }),
      )
      .default(16),
  })
  .register(z.globalRegistry, {
    description:
      "Input schema for sound effect generation with form controls for the playground.",
  });

/**
 * MusicV15Output
 */
export const zMinimaxMusicV2Output = z.object({
  audio: zFile,
});

/**
 * TextToMusic20Request
 */
export const zMinimaxMusicV2Input = z.object({
  prompt: z.string().min(10).max(2000).register(z.globalRegistry, {
    description:
      "A description of the music, specifying style, mood, and scenario. 10-300 characters.",
  }),
  lyrics_prompt: z.string().min(10).max(3000).register(z.globalRegistry, {
    description:
      "Lyrics of the song. Use n to separate lines. You may add structure tags like [Intro], [Verse], [Chorus], [Bridge], [Outro] to enhance the arrangement. 10-3000 characters.",
  }),
  audio_setting: z.optional(zAudioSetting),
});

/**
 * MusicSection
 */
export const zMusicSection = z.object({
  positive_local_styles: z.array(z.string()).register(z.globalRegistry, {
    description: "The styles that should be present in this section.",
  }),
  lines: z.array(z.string()).register(z.globalRegistry, {
    description:
      "The lyrics of the section. Each line must be at most 200 characters long.",
  }),
  negative_local_styles: z.array(z.string()).register(z.globalRegistry, {
    description: "The styles that should not be present in this section.",
  }),
  duration_ms: z.int().gte(3000).lte(120000).register(z.globalRegistry, {
    description:
      "The duration of the section in milliseconds. Must be between 3000ms and 120000ms.",
  }),
  section_name: z.string().min(1).max(100).register(z.globalRegistry, {
    description:
      "The name of the section. Must be between 1 and 100 characters.",
  }),
});

/**
 * MusicCompositionPlan
 */
export const zMusicCompositionPlan = z.object({
  negative_global_styles: z.array(z.string()).register(z.globalRegistry, {
    description: "The styles that should not be present in the entire song.",
  }),
  sections: z.array(zMusicSection).register(z.globalRegistry, {
    description: "The sections of the song.",
  }),
  positive_global_styles: z.array(z.string()).register(z.globalRegistry, {
    description: "The styles that should be present in the entire song.",
  }),
});

/**
 * MusicOutput
 */
export const zElevenlabsMusicOutput = z.object({
  audio: zFileType2,
});

/**
 * MusicRequest
 *
 * Request format for Elevenlabs Music API
 */
export const zElevenlabsMusicInput = z
  .object({
    prompt: z.optional(z.union([z.string(), z.unknown()])),
    composition_plan: z.optional(z.union([zMusicCompositionPlan, z.unknown()])),
    music_length_ms: z.optional(
      z.union([z.int().gte(3000).lte(600000), z.unknown()]),
    ),
    output_format: z.optional(
      z
        .enum([
          "mp3_22050_32",
          "mp3_44100_32",
          "mp3_44100_64",
          "mp3_44100_96",
          "mp3_44100_128",
          "mp3_44100_192",
          "pcm_8000",
          "pcm_16000",
          "pcm_22050",
          "pcm_24000",
          "pcm_44100",
          "pcm_48000",
          "ulaw_8000",
          "alaw_8000",
          "opus_48000_32",
          "opus_48000_64",
          "opus_48000_96",
          "opus_48000_128",
          "opus_48000_192",
        ])
        .register(z.globalRegistry, {
          description:
            "Output format of the generated audio. Formatted as codec_sample_rate_bitrate. So an mp3 with 22.05kHz sample rate at 32kbs is represented as mp3_22050_32. MP3 with 192kbps bitrate requires you to be subscribed to Creator tier or above. PCM with 44.1kHz sample rate requires you to be subscribed to Pro tier or above. Note that the -law format (sometimes written mu-law, often approximated as u-law) is commonly used for Twilio audio inputs.",
        }),
    ),
    respect_sections_durations: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Controls how strictly section durations in the composition_plan are enforced. It will only have an effect if it is used with composition_plan. When set to true, the model will precisely respect each section's duration_ms from the plan. When set to false, the model may adjust individual section durations which will generally lead to better generation quality and improved latency, while always preserving the total song duration from the plan.",
        }),
      )
      .default(true),
    force_instrumental: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If true, guarantees that the generated song will be instrumental. If false, the song may or may not be instrumental depending on the prompt. Can only be used with prompt.",
        }),
      )
      .default(false),
  })
  .register(z.globalRegistry, {
    description: "Request format for Elevenlabs Music API",
  });

/**
 * TTSOutput
 */
export const zElevenlabsAudioIsolationOutput = z.object({
  audio: zFileType2,
  timestamps: z.optional(z.union([z.array(z.unknown()), z.unknown()])),
});

/**
 * AudioIsolationRequest
 */
export const zElevenlabsAudioIsolationInput = z.object({
  video_url: z.optional(z.union([z.string(), z.unknown()])),
  audio_url: z.optional(z.union([z.string(), z.unknown()])),
});

/**
 * DiaCloneOutput
 */
export const zDiaTtsVoiceCloneOutput = z.object({
  audio: zFileType2,
});

/**
 * CloneRequest
 */
export const zDiaTtsVoiceCloneInput = z.object({
  text: z.string().register(z.globalRegistry, {
    description: "The text to be converted to speech.",
  }),
  ref_text: z.string().register(z.globalRegistry, {
    description: "The reference text to be used for TTS.",
  }),
  ref_audio_url: z.union([z.string(), z.string()]),
});

/**
 * ACEStepAudioToAudioResponse
 */
export const zAceStepAudioToAudioOutput = z.object({
  tags: z.string().register(z.globalRegistry, {
    description: "The genre tags used in the generation process.",
  }),
  lyrics: z.string().register(z.globalRegistry, {
    description: "The lyrics used in the generation process.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The random seed used for the generation process.",
  }),
  audio: zFile,
});

/**
 * ACEStepAudioToAudioRequest
 */
export const zAceStepAudioToAudioInput = z.object({
  number_of_steps: z
    .optional(
      z.int().gte(3).lte(60).register(z.globalRegistry, {
        description: "Number of steps to generate the audio.",
      }),
    )
    .default(27),
  tags: z.string().register(z.globalRegistry, {
    description:
      "Comma-separated list of genre tags to control the style of the generated audio.",
  }),
  minimum_guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description:
          "Minimum guidance scale for the generation after the decay.",
      }),
    )
    .default(3),
  lyrics: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Lyrics to be sung in the audio. If not provided or if [inst] or [instrumental] is the content of this field, no lyrics will be sung. Use control structures like [verse], [chorus] and [bridge] to control the structure of the song.",
      }),
    )
    .default(""),
  tag_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: "Tag guidance scale for the generation.",
      }),
    )
    .default(5),
  original_lyrics: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Original lyrics of the audio file.",
      }),
    )
    .default(""),
  scheduler: z.optional(
    z.enum(["euler", "heun"]).register(z.globalRegistry, {
      description: "Scheduler to use for the generation process.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description: "Guidance scale for the generation.",
      }),
    )
    .default(15),
  guidance_type: z.optional(
    z.enum(["cfg", "apg", "cfg_star"]).register(z.globalRegistry, {
      description: "Type of CFG to use for the generation process.",
    }),
  ),
  lyric_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: "Lyric guidance scale for the generation.",
      }),
    )
    .default(1.5),
  guidance_interval: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "Guidance interval for the generation. 0.5 means only apply guidance in the middle steps (0.25 * infer_steps to 0.75 * infer_steps)",
      }),
    )
    .default(0.5),
  edit_mode: z.optional(
    z.enum(["lyrics", "remix"]).register(z.globalRegistry, {
      description: "Whether to edit the lyrics only or remix the audio.",
    }),
  ),
  guidance_interval_decay: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "Guidance interval decay for the generation. Guidance scale will decay from guidance_scale to min_guidance_scale in the interval. 0.0 means no decay.",
      }),
    )
    .default(0),
  audio_url: z.union([z.string(), z.string()]),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed for reproducibility. If not provided, a random seed will be used.",
    }),
  ),
  granularity_scale: z
    .optional(
      z.int().gte(-100).lte(100).register(z.globalRegistry, {
        description:
          "Granularity scale for the generation process. Higher values can reduce artifacts.",
      }),
    )
    .default(10),
  original_tags: z.string().register(z.globalRegistry, {
    description: "Original tags of the audio file.",
  }),
  original_seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Original seed of the audio file.",
    }),
  ),
});

/**
 * ACEStepAudioInpaintResponse
 */
export const zAceStepAudioInpaintOutput = z.object({
  tags: z.string().register(z.globalRegistry, {
    description: "The genre tags used in the generation process.",
  }),
  lyrics: z.string().register(z.globalRegistry, {
    description: "The lyrics used in the generation process.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The random seed used for the generation process.",
  }),
  audio: zFile,
});

/**
 * ACEStepAudioInpaintRequest
 */
export const zAceStepAudioInpaintInput = z.object({
  number_of_steps: z
    .optional(
      z.int().gte(3).lte(60).register(z.globalRegistry, {
        description: "Number of steps to generate the audio.",
      }),
    )
    .default(27),
  start_time: z
    .optional(
      z.number().gte(0).lte(240).register(z.globalRegistry, {
        description: "start time in seconds for the inpainting process.",
      }),
    )
    .default(0),
  tags: z.string().register(z.globalRegistry, {
    description:
      "Comma-separated list of genre tags to control the style of the generated audio.",
  }),
  minimum_guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description:
          "Minimum guidance scale for the generation after the decay.",
      }),
    )
    .default(3),
  lyrics: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Lyrics to be sung in the audio. If not provided or if [inst] or [instrumental] is the content of this field, no lyrics will be sung. Use control structures like [verse], [chorus] and [bridge] to control the structure of the song.",
      }),
    )
    .default(""),
  end_time_relative_to: z.optional(
    z.enum(["start", "end"]).register(z.globalRegistry, {
      description:
        "Whether the end time is relative to the start or end of the audio.",
    }),
  ),
  tag_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: "Tag guidance scale for the generation.",
      }),
    )
    .default(5),
  scheduler: z.optional(
    z.enum(["euler", "heun"]).register(z.globalRegistry, {
      description: "Scheduler to use for the generation process.",
    }),
  ),
  end_time: z
    .optional(
      z.number().gte(0).lte(240).register(z.globalRegistry, {
        description: "end time in seconds for the inpainting process.",
      }),
    )
    .default(30),
  guidance_type: z.optional(
    z.enum(["cfg", "apg", "cfg_star"]).register(z.globalRegistry, {
      description: "Type of CFG to use for the generation process.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description: "Guidance scale for the generation.",
      }),
    )
    .default(15),
  lyric_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: "Lyric guidance scale for the generation.",
      }),
    )
    .default(1.5),
  guidance_interval: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "Guidance interval for the generation. 0.5 means only apply guidance in the middle steps (0.25 * infer_steps to 0.75 * infer_steps)",
      }),
    )
    .default(0.5),
  variance: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "Variance for the inpainting process. Higher values can lead to more diverse results.",
      }),
    )
    .default(0.5),
  guidance_interval_decay: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "Guidance interval decay for the generation. Guidance scale will decay from guidance_scale to min_guidance_scale in the interval. 0.0 means no decay.",
      }),
    )
    .default(0),
  start_time_relative_to: z.optional(
    z.enum(["start", "end"]).register(z.globalRegistry, {
      description:
        "Whether the start time is relative to the start or end of the audio.",
    }),
  ),
  audio_url: z.union([z.string(), z.string()]),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed for reproducibility. If not provided, a random seed will be used.",
    }),
  ),
  granularity_scale: z
    .optional(
      z.int().gte(-100).lte(100).register(z.globalRegistry, {
        description:
          "Granularity scale for the generation process. Higher values can reduce artifacts.",
      }),
    )
    .default(10),
});

/**
 * ACEStepResponse
 */
export const zAceStepAudioOutpaintOutput = z.object({
  tags: z.string().register(z.globalRegistry, {
    description: "The genre tags used in the generation process.",
  }),
  lyrics: z.string().register(z.globalRegistry, {
    description: "The lyrics used in the generation process.",
  }),
  seed: z.int().register(z.globalRegistry, {
    description: "The random seed used for the generation process.",
  }),
  audio: zFile,
});

/**
 * ACEStepAudioOutpaintRequest
 */
export const zAceStepAudioOutpaintInput = z.object({
  number_of_steps: z
    .optional(
      z.int().gte(3).lte(60).register(z.globalRegistry, {
        description: "Number of steps to generate the audio.",
      }),
    )
    .default(27),
  tags: z.string().register(z.globalRegistry, {
    description:
      "Comma-separated list of genre tags to control the style of the generated audio.",
  }),
  minimum_guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description:
          "Minimum guidance scale for the generation after the decay.",
      }),
    )
    .default(3),
  extend_after_duration: z
    .optional(
      z.number().gte(0).lte(240).register(z.globalRegistry, {
        description: "Duration in seconds to extend the audio from the end.",
      }),
    )
    .default(30),
  lyrics: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Lyrics to be sung in the audio. If not provided or if [inst] or [instrumental] is the content of this field, no lyrics will be sung. Use control structures like [verse], [chorus] and [bridge] to control the structure of the song.",
      }),
    )
    .default(""),
  tag_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: "Tag guidance scale for the generation.",
      }),
    )
    .default(5),
  scheduler: z.optional(
    z.enum(["euler", "heun"]).register(z.globalRegistry, {
      description: "Scheduler to use for the generation process.",
    }),
  ),
  extend_before_duration: z
    .optional(
      z.number().gte(0).lte(240).register(z.globalRegistry, {
        description: "Duration in seconds to extend the audio from the start.",
      }),
    )
    .default(0),
  guidance_type: z.optional(
    z.enum(["cfg", "apg", "cfg_star"]).register(z.globalRegistry, {
      description: "Type of CFG to use for the generation process.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description: "Guidance scale for the generation.",
      }),
    )
    .default(15),
  lyric_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: "Lyric guidance scale for the generation.",
      }),
    )
    .default(1.5),
  guidance_interval: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "Guidance interval for the generation. 0.5 means only apply guidance in the middle steps (0.25 * infer_steps to 0.75 * infer_steps)",
      }),
    )
    .default(0.5),
  guidance_interval_decay: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "Guidance interval decay for the generation. Guidance scale will decay from guidance_scale to min_guidance_scale in the interval. 0.0 means no decay.",
      }),
    )
    .default(0),
  audio_url: z.union([z.string(), z.string()]),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        "Random seed for reproducibility. If not provided, a random seed will be used.",
    }),
  ),
  granularity_scale: z
    .optional(
      z.int().gte(-100).lte(100).register(z.globalRegistry, {
        description:
          "Granularity scale for the generation process. Higher values can reduce artifacts.",
      }),
    )
    .default(10),
});

/**
 * ExtendOutput
 */
export const zV2ExtendOutput = z.object({
  tags: z.optional(z.union([z.array(z.string()), z.unknown()])),
  seed: z.int().register(z.globalRegistry, {
    description:
      "The seed used for generation. This can be used to generate an identical song by passing the same parameters with this seed in a future request.",
  }),
  extend_duration: z.number().register(z.globalRegistry, {
    description: "The duration in seconds that the song was extended by.",
  }),
  audio: z.array(zFileType2).register(z.globalRegistry, {
    description: "The generated audio files.",
  }),
  lyrics: z.optional(z.union([z.string(), z.unknown()])),
});

/**
 * ExtendInput
 */
export const zV2ExtendInput = z.object({
  prompt: z.optional(z.union([z.string(), z.unknown()])),
  lyrics_prompt: z.optional(z.union([z.string(), z.unknown()])),
  tags: z.optional(z.union([z.array(z.string()), z.unknown()])),
  prompt_strength: z
    .optional(
      z.number().gte(1.4).lte(3.1).register(z.globalRegistry, {
        description:
          "Controls how strongly your prompt influences the output. Greater values adhere more to the prompt but sound less natural. (This is CFG.)",
      }),
    )
    .default(1.8),
  output_bit_rate: z.optional(
    z.union([
      z.union([z.literal(128), z.literal(192), z.literal(256), z.literal(320)]),
      z.unknown(),
    ]),
  ),
  num_songs: z
    .optional(
      z.int().gte(1).lte(2).register(z.globalRegistry, {
        description:
          "Generating 2 songs costs 1.5x the price of generating 1 song. Also, note that using the same seed may not result in identical songs if the number of songs generated is changed.",
      }),
    )
    .default(1),
  output_format: z.optional(z.enum(["flac", "mp3", "wav", "ogg", "m4a"])),
  side: z.enum(["left", "right"]).register(z.globalRegistry, {
    description: "Add more to the beginning (left) or end (right) of the song",
  }),
  balance_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "Greater means more natural vocals. Lower means sharper instrumentals. We recommend 0.7.",
      }),
    )
    .default(0.7),
  crop_duration: z
    .optional(
      z.number().register(z.globalRegistry, {
        description:
          "Duration in seconds to crop from the selected side before extending from that side.",
      }),
    )
    .default(0),
  audio_url: z.union([z.string(), z.string()]),
  seed: z.optional(
    z.union([
      z.int().gte(-9223372036854776000).lte(9223372036854776000),
      z.unknown(),
    ]),
  ),
  extend_duration: z.optional(z.union([z.number().lte(85), z.unknown()])),
});

/**
 * InpaintOutput
 */
export const zStableAudio25InpaintOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: "The random seed used for generation",
  }),
  audio: zFile,
});

/**
 * InpaintInput
 */
export const zStableAudio25InpaintInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to guide the audio generation",
  }),
  guidance_scale: z
    .optional(
      z.int().gte(1).lte(25).register(z.globalRegistry, {
        description:
          "How strictly the diffusion process adheres to the prompt text (higher values make your audio closer to your prompt). ",
      }),
    )
    .default(1),
  mask_end: z
    .optional(
      z.int().gte(0).lte(190).register(z.globalRegistry, {
        description: "The end point of the audio mask",
      }),
    )
    .default(190),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  audio_url: z.union([z.string(), z.string()]),
  seed: z.optional(z.int()),
  seconds_total: z
    .optional(
      z.int().gte(1).lte(190).register(z.globalRegistry, {
        description:
          "The duration of the audio clip to generate. If not provided, it will be set to the duration of the input audio.",
      }),
    )
    .default(190),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(8).register(z.globalRegistry, {
        description: "The number of steps to denoise the audio for",
      }),
    )
    .default(8),
  mask_start: z
    .optional(
      z.int().gte(0).lte(190).register(z.globalRegistry, {
        description: "The start point of the audio mask",
      }),
    )
    .default(30),
});

/**
 * AudioToAudioOutput
 */
export const zStableAudio25AudioToAudioOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: "The random seed used for generation",
  }),
  audio: zFile,
});

/**
 * AudioToAudioInput
 */
export const zStableAudio25AudioToAudioInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: "The prompt to guide the audio generation",
  }),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          "Sometimes referred to as denoising, this parameter controls how much influence the `audio_url` parameter has on the generated audio. A value of 0 would yield audio that is identical to the input. A value of 1 would be as if you passed in no audio at all.",
      }),
    )
    .default(0.8),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  audio_url: z.union([z.string(), z.string()]),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(8).register(z.globalRegistry, {
        description: "The number of steps to denoise the audio for",
      }),
    )
    .default(8),
  guidance_scale: z
    .optional(
      z.int().gte(1).lte(25).register(z.globalRegistry, {
        description:
          "How strictly the diffusion process adheres to the prompt text (higher values make your audio closer to your prompt). ",
      }),
    )
    .default(1),
  seed: z.optional(z.int()),
  total_seconds: z.optional(
    z.int().gte(1).lte(190).register(z.globalRegistry, {
      description:
        "The duration of the audio clip to generate. If not provided, it will be set to the duration of the input audio.",
    }),
  ),
});

/**
 * AudioUnderstandingOutput
 */
export const zAudioUnderstandingOutput = z.object({
  output: z.string().register(z.globalRegistry, {
    description: "The analysis of the audio content based on the prompt",
  }),
});

/**
 * AudioUnderstandingInput
 */
export const zAudioUnderstandingInput = z.object({
  prompt: z.string().min(1).max(10000).register(z.globalRegistry, {
    description: "The question or prompt about the audio content.",
  }),
  detailed_analysis: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to request a more detailed analysis of the audio",
      }),
    )
    .default(false),
  audio_url: z.union([z.string(), z.string()]),
});

/**
 * DemucsOutput
 */
export const zDemucsOutput = z.object({
  vocals: z.optional(z.union([zFileType2, z.unknown()])),
  guitar: z.optional(z.union([zFileType2, z.unknown()])),
  bass: z.optional(z.union([zFileType2, z.unknown()])),
  piano: z.optional(z.union([zFileType2, z.unknown()])),
  other: z.optional(z.union([zFileType2, z.unknown()])),
  drums: z.optional(z.union([zFileType2, z.unknown()])),
});

/**
 * DemucsInput
 */
export const zDemucsInput = z.object({
  segment_length: z.optional(z.union([z.int(), z.unknown()])),
  output_format: z.optional(
    z.enum(["wav", "mp3"]).register(z.globalRegistry, {
      description: "Output audio format for the separated stems",
    }),
  ),
  stems: z.optional(
    z.union([
      z.array(z.enum(["vocals", "drums", "bass", "other", "guitar", "piano"])),
      z.unknown(),
    ]),
  ),
  overlap: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          "Overlap between segments (0.0 to 1.0). Higher values may improve quality but increase processing time.",
      }),
    )
    .default(0.25),
  model: z.optional(
    z
      .enum([
        "htdemucs",
        "htdemucs_ft",
        "htdemucs_6s",
        "hdemucs_mmi",
        "mdx",
        "mdx_extra",
        "mdx_q",
        "mdx_extra_q",
      ])
      .register(z.globalRegistry, {
        description: "Demucs model to use for separation",
      }),
  ),
  audio_url: z.union([z.string(), z.string()]),
  shifts: z
    .optional(
      z.int().gte(1).lte(10).register(z.globalRegistry, {
        description:
          "Number of random shifts for equivariant stabilization. Higher values improve quality but increase processing time.",
      }),
    )
    .default(1),
});

/**
 * CreateVoiceOutput
 *
 * Response model for creating a custom voice.
 */
export const zKlingVideoCreateVoiceOutput = z
  .object({
    voice_id: z.string().register(z.globalRegistry, {
      description: "Unique identifier for the created voice",
    }),
  })
  .register(z.globalRegistry, {
    description: "Response model for creating a custom voice.",
  });

/**
 * CreateVoiceInput
 *
 * Request model for creating a custom voice.
 */
export const zKlingVideoCreateVoiceInput = z
  .object({
    voice_url: z.union([z.string(), z.string()]),
  })
  .register(z.globalRegistry, {
    description: "Request model for creating a custom voice.",
  });

/**
 * MergeAudiosOutput
 */
export const zFfmpegApiMergeAudiosOutput = z.object({
  audio: zFileType2,
});

/**
 * MergeAudiosInput
 */
export const zFfmpegApiMergeAudiosInput = z.object({
  audio_urls: z.array(z.string()).min(2).max(5).register(z.globalRegistry, {
    description:
      "List of audio URLs to merge in order. The 0th stream of the audio will be considered as the merge candidate.",
  }),
  output_format: z.optional(
    z.union([
      z.enum([
        "mp3_22050_32",
        "mp3_44100_32",
        "mp3_44100_64",
        "mp3_44100_96",
        "mp3_44100_128",
        "mp3_44100_192",
        "pcm_8000",
        "pcm_16000",
        "pcm_22050",
        "pcm_24000",
        "pcm_44100",
        "pcm_48000",
        "ulaw_8000",
        "alaw_8000",
        "opus_48000_32",
        "opus_48000_64",
        "opus_48000_96",
        "opus_48000_128",
        "opus_48000_192",
      ]),
      z.unknown(),
    ]),
  ),
});

/**
 * AudioTimeSpan
 *
 * A time span indicating where the target sound occurs.
 */
export const zAudioTimeSpan = z
  .object({
    end: z.number().gte(0).register(z.globalRegistry, {
      description: "End time of the span in seconds",
    }),
    start: z.number().gte(0).register(z.globalRegistry, {
      description: "Start time of the span in seconds",
    }),
    include: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Whether to include (True) or exclude (False) sounds in this span",
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: "A time span indicating where the target sound occurs.",
  });

/**
 * SAMAudioSpanSeparateOutput
 *
 * Output for span-based audio separation.
 */
export const zSamAudioSpanSeparateOutput = z
  .object({
    target: zFile,
    duration: z.number().register(z.globalRegistry, {
      description: "Duration of the output audio in seconds.",
    }),
    sample_rate: z
      .optional(
        z.int().register(z.globalRegistry, {
          description: "Sample rate of the output audio in Hz.",
        }),
      )
      .default(48000),
    residual: zFile,
  })
  .register(z.globalRegistry, {
    description: "Output for span-based audio separation.",
  });

/**
 * SAMAudioSpanInput
 *
 * Input for temporal span-based audio separation.
 */
export const zSamAudioSpanSeparateInput = z
  .object({
    prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          "Text prompt describing the sound to isolate. Optional but recommended - helps the model identify what type of sound to extract from the span.",
      }),
    ),
    acceleration: z.optional(
      z.enum(["fast", "balanced", "quality"]).register(z.globalRegistry, {
        description: "The acceleration level to use.",
      }),
    ),
    spans: z.array(zAudioTimeSpan).register(z.globalRegistry, {
      description:
        "Time spans where the target sound occurs which should be isolated.",
    }),
    output_format: z.optional(
      z.enum(["wav", "mp3"]).register(z.globalRegistry, {
        description: "Output audio format.",
      }),
    ),
    trim_to_span: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Trim output audio to only include the specified span time range. If False, returns the full audio length with the target sound isolated throughout.",
        }),
      )
      .default(false),
    audio_url: z.union([z.string(), z.string()]),
    reranking_candidates: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description:
            "Number of candidates to generate and rank. Higher improves quality but increases latency and cost. Requires text prompt; ignored for span-only separation.",
        }),
      )
      .default(1),
  })
  .register(z.globalRegistry, {
    description: "Input for temporal span-based audio separation.",
  });

/**
 * SAMAudioSeparateOutput
 *
 * Output for text-based audio separation.
 */
export const zSamAudioSeparateOutput = z
  .object({
    target: zFile,
    duration: z.number().register(z.globalRegistry, {
      description: "Duration of the output audio in seconds.",
    }),
    sample_rate: z
      .optional(
        z.int().register(z.globalRegistry, {
          description: "Sample rate of the output audio in Hz.",
        }),
      )
      .default(48000),
    residual: zFile,
  })
  .register(z.globalRegistry, {
    description: "Output for text-based audio separation.",
  });

/**
 * SAMAudioInput
 *
 * Input for text-based audio separation.
 */
export const zSamAudioSeparateInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: "Text prompt describing the sound to isolate.",
    }),
    acceleration: z.optional(
      z.enum(["fast", "balanced", "quality"]).register(z.globalRegistry, {
        description: "The acceleration level to use.",
      }),
    ),
    audio_url: z.union([z.string(), z.string()]),
    predict_spans: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Automatically predict temporal spans where the target sound occurs.",
        }),
      )
      .default(false),
    output_format: z.optional(
      z.enum(["wav", "mp3"]).register(z.globalRegistry, {
        description: "Output audio format.",
      }),
    ),
    reranking_candidates: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description:
            "Number of candidates to generate and rank. Higher improves quality but increases latency and cost.",
        }),
      )
      .default(1),
  })
  .register(z.globalRegistry, {
    description: "Input for text-based audio separation.",
  });

/**
 * DeepFilterNetTimings
 */
export const zDeepFilterNetTimings = z.object({
  postprocess: z.number().register(z.globalRegistry, {
    description: "Postprocessing time.",
  }),
  inference: z.number().register(z.globalRegistry, {
    description: "Inference time.",
  }),
  preprocess: z.number().register(z.globalRegistry, {
    description: "Preprocessing time.",
  }),
});

/**
 * AudioFile
 */
export const zAudioFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The size of the file in bytes.",
    }),
  ),
  duration: z.optional(
    z.number().register(z.globalRegistry, {
      description: "The duration of the audio",
    }),
  ),
  channels: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The number of channels in the audio",
    }),
  ),
  bitrate: z.optional(z.union([z.string(), z.int()])),
  url: z.string().register(z.globalRegistry, {
    description: "The URL where the file can be downloaded from.",
  }),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "The name of the file. It will be auto-generated if not provided.",
    }),
  ),
  sample_rate: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The sample rate of the audio",
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The mime type of the file.",
    }),
  ),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: "File data",
    }),
  ),
});

/**
 * DeepFilterNet3Output
 */
export const zDeepfilternet3Output = z.object({
  timings: zDeepFilterNetTimings,
  audio_file: zAudioFile,
});

/**
 * DeepFilterNet3Input
 */
export const zDeepfilternet3Input = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  audio_format: z.optional(
    z
      .enum(["mp3", "aac", "m4a", "ogg", "opus", "flac", "wav"])
      .register(z.globalRegistry, {
        description: "The format for the output audio.",
      }),
  ),
  audio_url: z.union([z.string(), z.string()]),
  bitrate: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The bitrate of the output audio.",
      }),
    )
    .default("192k"),
});

/**
 * NovaSRTimings
 */
export const zNovaSrTimings = z.object({
  postprocess: z.number().register(z.globalRegistry, {
    description: "Time taken to postprocess the audio in seconds.",
  }),
  inference: z.number().register(z.globalRegistry, {
    description: "Time taken to run the inference in seconds.",
  }),
  preprocess: z.number().register(z.globalRegistry, {
    description: "Time taken to preprocess the audio in seconds.",
  }),
});

/**
 * NovaSROutput
 */
export const zNovaSrOutput = z.object({
  timings: zNovaSrTimings,
  audio: zAudioFile,
});

/**
 * NovaSRInput
 */
export const zNovaSrInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  bitrate: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The bitrate of the output audio.",
      }),
    )
    .default("192k"),
  audio_url: z.union([z.string(), z.string()]),
  audio_format: z.optional(
    z
      .enum(["mp3", "aac", "m4a", "ogg", "opus", "flac", "wav"])
      .register(z.globalRegistry, {
        description: "The format for the output audio.",
      }),
  ),
});

/**
 * VoiceChangerOutput
 */
export const zElevenlabsVoiceChangerOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: "Random seed for reproducibility.",
  }),
  audio: zFileType2,
});

/**
 * VoiceChangerRequest
 */
export const zElevenlabsVoiceChangerInput = z.object({
  voice: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "The voice to use for speech generation",
      }),
    )
    .default("Rachel"),
  audio_url: z.union([z.string(), z.string()]),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: "Random seed for reproducibility.",
    }),
  ),
  output_format: z.optional(
    z
      .enum([
        "mp3_22050_32",
        "mp3_44100_32",
        "mp3_44100_64",
        "mp3_44100_96",
        "mp3_44100_128",
        "mp3_44100_192",
        "pcm_8000",
        "pcm_16000",
        "pcm_22050",
        "pcm_24000",
        "pcm_44100",
        "pcm_48000",
        "ulaw_8000",
        "alaw_8000",
        "opus_48000_32",
        "opus_48000_64",
        "opus_48000_96",
        "opus_48000_128",
        "opus_48000_192",
      ])
      .register(z.globalRegistry, {
        description:
          "Output format of the generated audio. Formatted as codec_sample_rate_bitrate.",
      }),
  ),
  remove_background_noise: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If set, will remove the background noise from your audio input using our audio isolation model.",
      }),
    )
    .default(false),
});

export const zQueueStatus = z.object({
  status: z.enum(["IN_QUEUE", "IN_PROGRESS", "COMPLETED"]),
  request_id: z.string().register(z.globalRegistry, {
    description: "The request id.",
  }),
  response_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The response url.",
    }),
  ),
  status_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The status url.",
    }),
  ),
  cancel_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: "The cancel url.",
    }),
  ),
  logs: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: "The logs.",
    }),
  ),
  metrics: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: "The metrics.",
    }),
  ),
  queue_position: z.optional(
    z.int().register(z.globalRegistry, {
      description: "The queue position.",
    }),
  ),
});

export const zGetFalAiElevenlabsVoiceChangerRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiElevenlabsVoiceChangerRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiElevenlabsVoiceChangerRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiElevenlabsVoiceChangerRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiElevenlabsVoiceChangerData = z.object({
  body: zElevenlabsVoiceChangerInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiElevenlabsVoiceChangerResponse = zQueueStatus;

export const zGetFalAiElevenlabsVoiceChangerRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiElevenlabsVoiceChangerRequestsByRequestIdResponse =
  zElevenlabsVoiceChangerOutput;

export const zGetFalAiNovaSrRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiNovaSrRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiNovaSrRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiNovaSrRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiNovaSrData = z.object({
  body: zNovaSrInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiNovaSrResponse = zQueueStatus;

export const zGetFalAiNovaSrRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiNovaSrRequestsByRequestIdResponse = zNovaSrOutput;

export const zGetFalAiDeepfilternet3RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiDeepfilternet3RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiDeepfilternet3RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiDeepfilternet3RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiDeepfilternet3Data = z.object({
  body: zDeepfilternet3Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiDeepfilternet3Response = zQueueStatus;

export const zGetFalAiDeepfilternet3RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiDeepfilternet3RequestsByRequestIdResponse =
  zDeepfilternet3Output;

export const zGetFalAiSamAudioSeparateRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiSamAudioSeparateRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiSamAudioSeparateRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiSamAudioSeparateRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiSamAudioSeparateData = z.object({
  body: zSamAudioSeparateInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiSamAudioSeparateResponse = zQueueStatus;

export const zGetFalAiSamAudioSeparateRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiSamAudioSeparateRequestsByRequestIdResponse =
  zSamAudioSeparateOutput;

export const zGetFalAiSamAudioSpanSeparateRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiSamAudioSpanSeparateRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiSamAudioSpanSeparateRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiSamAudioSpanSeparateRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiSamAudioSpanSeparateData = z.object({
  body: zSamAudioSpanSeparateInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiSamAudioSpanSeparateResponse = zQueueStatus;

export const zGetFalAiSamAudioSpanSeparateRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiSamAudioSpanSeparateRequestsByRequestIdResponse =
  zSamAudioSpanSeparateOutput;

export const zGetFalAiFfmpegApiMergeAudiosRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiFfmpegApiMergeAudiosRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiFfmpegApiMergeAudiosRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiFfmpegApiMergeAudiosRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiFfmpegApiMergeAudiosData = z.object({
  body: zFfmpegApiMergeAudiosInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiFfmpegApiMergeAudiosResponse = zQueueStatus;

export const zGetFalAiFfmpegApiMergeAudiosRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiFfmpegApiMergeAudiosRequestsByRequestIdResponse =
  zFfmpegApiMergeAudiosOutput;

export const zGetFalAiKlingVideoCreateVoiceRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiKlingVideoCreateVoiceRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiKlingVideoCreateVoiceRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiKlingVideoCreateVoiceRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiKlingVideoCreateVoiceData = z.object({
  body: zKlingVideoCreateVoiceInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiKlingVideoCreateVoiceResponse = zQueueStatus;

export const zGetFalAiKlingVideoCreateVoiceRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiKlingVideoCreateVoiceRequestsByRequestIdResponse =
  zKlingVideoCreateVoiceOutput;

export const zGetFalAiDemucsRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiDemucsRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiDemucsRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiDemucsRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiDemucsData = z.object({
  body: zDemucsInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiDemucsResponse = zQueueStatus;

export const zGetFalAiDemucsRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiDemucsRequestsByRequestIdResponse = zDemucsOutput;

export const zGetFalAiAudioUnderstandingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiAudioUnderstandingRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiAudioUnderstandingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiAudioUnderstandingRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiAudioUnderstandingData = z.object({
  body: zAudioUnderstandingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiAudioUnderstandingResponse = zQueueStatus;

export const zGetFalAiAudioUnderstandingRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiAudioUnderstandingRequestsByRequestIdResponse =
  zAudioUnderstandingOutput;

export const zGetFalAiStableAudio25AudioToAudioRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiStableAudio25AudioToAudioRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiStableAudio25AudioToAudioRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiStableAudio25AudioToAudioRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiStableAudio25AudioToAudioData = z.object({
  body: zStableAudio25AudioToAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiStableAudio25AudioToAudioResponse = zQueueStatus;

export const zGetFalAiStableAudio25AudioToAudioRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiStableAudio25AudioToAudioRequestsByRequestIdResponse =
  zStableAudio25AudioToAudioOutput;

export const zGetFalAiStableAudio25InpaintRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiStableAudio25InpaintRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiStableAudio25InpaintRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiStableAudio25InpaintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiStableAudio25InpaintData = z.object({
  body: zStableAudio25InpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiStableAudio25InpaintResponse = zQueueStatus;

export const zGetFalAiStableAudio25InpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiStableAudio25InpaintRequestsByRequestIdResponse =
  zStableAudio25InpaintOutput;

export const zGetSonautoV2ExtendRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetSonautoV2ExtendRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutSonautoV2ExtendRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutSonautoV2ExtendRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostSonautoV2ExtendData = z.object({
  body: zV2ExtendInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostSonautoV2ExtendResponse = zQueueStatus;

export const zGetSonautoV2ExtendRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetSonautoV2ExtendRequestsByRequestIdResponse = zV2ExtendOutput;

export const zGetFalAiAceStepAudioOutpaintRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiAceStepAudioOutpaintRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiAceStepAudioOutpaintRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiAceStepAudioOutpaintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiAceStepAudioOutpaintData = z.object({
  body: zAceStepAudioOutpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiAceStepAudioOutpaintResponse = zQueueStatus;

export const zGetFalAiAceStepAudioOutpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiAceStepAudioOutpaintRequestsByRequestIdResponse =
  zAceStepAudioOutpaintOutput;

export const zGetFalAiAceStepAudioInpaintRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiAceStepAudioInpaintRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiAceStepAudioInpaintRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiAceStepAudioInpaintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiAceStepAudioInpaintData = z.object({
  body: zAceStepAudioInpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiAceStepAudioInpaintResponse = zQueueStatus;

export const zGetFalAiAceStepAudioInpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiAceStepAudioInpaintRequestsByRequestIdResponse =
  zAceStepAudioInpaintOutput;

export const zGetFalAiAceStepAudioToAudioRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiAceStepAudioToAudioRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiAceStepAudioToAudioRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiAceStepAudioToAudioRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiAceStepAudioToAudioData = z.object({
  body: zAceStepAudioToAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiAceStepAudioToAudioResponse = zQueueStatus;

export const zGetFalAiAceStepAudioToAudioRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiAceStepAudioToAudioRequestsByRequestIdResponse =
  zAceStepAudioToAudioOutput;

export const zGetFalAiDiaTtsVoiceCloneRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiDiaTtsVoiceCloneRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiDiaTtsVoiceCloneRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiDiaTtsVoiceCloneRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiDiaTtsVoiceCloneData = z.object({
  body: zDiaTtsVoiceCloneInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiDiaTtsVoiceCloneResponse = zQueueStatus;

export const zGetFalAiDiaTtsVoiceCloneRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiDiaTtsVoiceCloneRequestsByRequestIdResponse =
  zDiaTtsVoiceCloneOutput;

export const zGetFalAiElevenlabsAudioIsolationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiElevenlabsAudioIsolationRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiElevenlabsAudioIsolationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiElevenlabsAudioIsolationRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiElevenlabsAudioIsolationData = z.object({
  body: zElevenlabsAudioIsolationInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiElevenlabsAudioIsolationResponse = zQueueStatus;

export const zGetFalAiElevenlabsAudioIsolationRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiElevenlabsAudioIsolationRequestsByRequestIdResponse =
  zElevenlabsAudioIsolationOutput;

export const zGetFalAiElevenlabsMusicRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiElevenlabsMusicRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiElevenlabsMusicRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiElevenlabsMusicRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiElevenlabsMusicData = z.object({
  body: zElevenlabsMusicInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiElevenlabsMusicResponse = zQueueStatus;

export const zGetFalAiElevenlabsMusicRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiElevenlabsMusicRequestsByRequestIdResponse =
  zElevenlabsMusicOutput;

export const zGetFalAiMinimaxMusicV2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiMinimaxMusicV2RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiMinimaxMusicV2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiMinimaxMusicV2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiMinimaxMusicV2Data = z.object({
  body: zMinimaxMusicV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiMinimaxMusicV2Response = zQueueStatus;

export const zGetFalAiMinimaxMusicV2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiMinimaxMusicV2RequestsByRequestIdResponse =
  zMinimaxMusicV2Output;

export const zGetBeatovenSoundEffectGenerationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetBeatovenSoundEffectGenerationRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutBeatovenSoundEffectGenerationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutBeatovenSoundEffectGenerationRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostBeatovenSoundEffectGenerationData = z.object({
  body: zSoundEffectGenerationInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostBeatovenSoundEffectGenerationResponse = zQueueStatus;

export const zGetBeatovenSoundEffectGenerationRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetBeatovenSoundEffectGenerationRequestsByRequestIdResponse =
  zSoundEffectGenerationOutput;

export const zGetBeatovenMusicGenerationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetBeatovenMusicGenerationRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutBeatovenMusicGenerationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutBeatovenMusicGenerationRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostBeatovenMusicGenerationData = z.object({
  body: zMusicGenerationInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostBeatovenMusicGenerationResponse = zQueueStatus;

export const zGetBeatovenMusicGenerationRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetBeatovenMusicGenerationRequestsByRequestIdResponse =
  zMusicGenerationOutput;

export const zGetFalAiMinimaxMusicV15RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiMinimaxMusicV15RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiMinimaxMusicV15RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiMinimaxMusicV15RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiMinimaxMusicV15Data = z.object({
  body: zMinimaxMusicV15Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiMinimaxMusicV15Response = zQueueStatus;

export const zGetFalAiMinimaxMusicV15RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiMinimaxMusicV15RequestsByRequestIdResponse =
  zMinimaxMusicV15Output;

export const zGetFalAiStableAudio25TextToAudioRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiStableAudio25TextToAudioRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiStableAudio25TextToAudioRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiStableAudio25TextToAudioRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiStableAudio25TextToAudioData = z.object({
  body: zStableAudio25TextToAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiStableAudio25TextToAudioResponse = zQueueStatus;

export const zGetFalAiStableAudio25TextToAudioRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiStableAudio25TextToAudioRequestsByRequestIdResponse =
  zStableAudio25TextToAudioOutput;

export const zGetFalAiElevenlabsTextToDialogueElevenV3RequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiElevenlabsTextToDialogueElevenV3RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiElevenlabsTextToDialogueElevenV3RequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiElevenlabsTextToDialogueElevenV3RequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiElevenlabsTextToDialogueElevenV3Data = z.object({
  body: zElevenlabsTextToDialogueElevenV3Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiElevenlabsTextToDialogueElevenV3Response = zQueueStatus;

export const zGetFalAiElevenlabsTextToDialogueElevenV3RequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiElevenlabsTextToDialogueElevenV3RequestsByRequestIdResponse =
  zElevenlabsTextToDialogueElevenV3Output;

export const zGetFalAiElevenlabsSoundEffectsV2RequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiElevenlabsSoundEffectsV2RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiElevenlabsSoundEffectsV2RequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiElevenlabsSoundEffectsV2RequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiElevenlabsSoundEffectsV2Data = z.object({
  body: zElevenlabsSoundEffectsV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiElevenlabsSoundEffectsV2Response = zQueueStatus;

export const zGetFalAiElevenlabsSoundEffectsV2RequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiElevenlabsSoundEffectsV2RequestsByRequestIdResponse =
  zElevenlabsSoundEffectsV2Output;

export const zGetSonautoV2InpaintRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetSonautoV2InpaintRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutSonautoV2InpaintRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutSonautoV2InpaintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostSonautoV2InpaintData = z.object({
  body: zV2InpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostSonautoV2InpaintResponse = zQueueStatus;

export const zGetSonautoV2InpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetSonautoV2InpaintRequestsByRequestIdResponse = zV2InpaintOutput;

export const zGetSonautoV2TextToMusicRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetSonautoV2TextToMusicRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutSonautoV2TextToMusicRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutSonautoV2TextToMusicRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostSonautoV2TextToMusicData = z.object({
  body: zV2TextToMusicInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostSonautoV2TextToMusicResponse = zQueueStatus;

export const zGetSonautoV2TextToMusicRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetSonautoV2TextToMusicRequestsByRequestIdResponse =
  zV2TextToMusicOutput;

export const zGetFalAiElevenlabsTtsElevenV3RequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiElevenlabsTtsElevenV3RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiElevenlabsTtsElevenV3RequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiElevenlabsTtsElevenV3RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiElevenlabsTtsElevenV3Data = z.object({
  body: zElevenlabsTtsElevenV3Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiElevenlabsTtsElevenV3Response = zQueueStatus;

export const zGetFalAiElevenlabsTtsElevenV3RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiElevenlabsTtsElevenV3RequestsByRequestIdResponse =
  zElevenlabsTtsElevenV3Output;

export const zGetFalAiLyria2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiLyria2RequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiLyria2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiLyria2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiLyria2Data = z.object({
  body: zLyria2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiLyria2Response = zQueueStatus;

export const zGetFalAiLyria2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiLyria2RequestsByRequestIdResponse = zLyria2Output;

export const zGetFalAiAceStepPromptToAudioRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiAceStepPromptToAudioRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiAceStepPromptToAudioRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiAceStepPromptToAudioRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiAceStepPromptToAudioData = z.object({
  body: zAceStepPromptToAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiAceStepPromptToAudioResponse = zQueueStatus;

export const zGetFalAiAceStepPromptToAudioRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiAceStepPromptToAudioRequestsByRequestIdResponse =
  zAceStepPromptToAudioOutput;

export const zGetFalAiAceStepRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiAceStepRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiAceStepRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiAceStepRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiAceStepData = z.object({
  body: zAceStepInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiAceStepResponse = zQueueStatus;

export const zGetFalAiAceStepRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiAceStepRequestsByRequestIdResponse = zAceStepOutput;

export const zGetCassetteaiSoundEffectsGeneratorRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetCassetteaiSoundEffectsGeneratorRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutCassetteaiSoundEffectsGeneratorRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutCassetteaiSoundEffectsGeneratorRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostCassetteaiSoundEffectsGeneratorData = z.object({
  body: zSoundEffectsGeneratorInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostCassetteaiSoundEffectsGeneratorResponse = zQueueStatus;

export const zGetCassetteaiSoundEffectsGeneratorRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetCassetteaiSoundEffectsGeneratorRequestsByRequestIdResponse =
  zSoundEffectsGeneratorOutput;

export const zGetCassetteaiMusicGeneratorRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetCassetteaiMusicGeneratorRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutCassetteaiMusicGeneratorRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutCassetteaiMusicGeneratorRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostCassetteaiMusicGeneratorData = z.object({
  body: zMusicGeneratorInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostCassetteaiMusicGeneratorResponse = zQueueStatus;

export const zGetCassetteaiMusicGeneratorRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetCassetteaiMusicGeneratorRequestsByRequestIdResponse =
  zMusicGeneratorOutput;

export const zGetFalAiCsm1bRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiCsm1bRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiCsm1bRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiCsm1bRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiCsm1bData = z.object({
  body: zCsm1bInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiCsm1bResponse = zQueueStatus;

export const zGetFalAiCsm1bRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiCsm1bRequestsByRequestIdResponse = zCsm1bOutput;

export const zGetFalAiDiffrhythmRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiDiffrhythmRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiDiffrhythmRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiDiffrhythmRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiDiffrhythmData = z.object({
  body: zDiffrhythmInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiDiffrhythmResponse = zQueueStatus;

export const zGetFalAiDiffrhythmRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiDiffrhythmRequestsByRequestIdResponse = zDiffrhythmOutput;

export const zGetFalAiElevenlabsTtsMultilingualV2RequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiElevenlabsTtsMultilingualV2RequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiElevenlabsTtsMultilingualV2RequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiElevenlabsTtsMultilingualV2RequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiElevenlabsTtsMultilingualV2Data = z.object({
  body: zElevenlabsTtsMultilingualV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiElevenlabsTtsMultilingualV2Response = zQueueStatus;

export const zGetFalAiElevenlabsTtsMultilingualV2RequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiElevenlabsTtsMultilingualV2RequestsByRequestIdResponse =
  zElevenlabsTtsMultilingualV2Output;

export const zGetFalAiKokoroHindiRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiKokoroHindiRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiKokoroHindiRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroHindiRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiKokoroHindiData = z.object({
  body: zKokoroHindiInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiKokoroHindiResponse = zQueueStatus;

export const zGetFalAiKokoroHindiRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiKokoroHindiRequestsByRequestIdResponse =
  zKokoroHindiOutput;

export const zGetFalAiKokoroBritishEnglishRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiKokoroBritishEnglishRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiKokoroBritishEnglishRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroBritishEnglishRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiKokoroBritishEnglishData = z.object({
  body: zKokoroBritishEnglishInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiKokoroBritishEnglishResponse = zQueueStatus;

export const zGetFalAiKokoroBritishEnglishRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiKokoroBritishEnglishRequestsByRequestIdResponse =
  zKokoroBritishEnglishOutput;

export const zGetFalAiKokoroAmericanEnglishRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiKokoroAmericanEnglishRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiKokoroAmericanEnglishRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroAmericanEnglishRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiKokoroAmericanEnglishData = z.object({
  body: zKokoroAmericanEnglishInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiKokoroAmericanEnglishResponse = zQueueStatus;

export const zGetFalAiKokoroAmericanEnglishRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiKokoroAmericanEnglishRequestsByRequestIdResponse =
  zKokoroAmericanEnglishOutput;

export const zGetFalAiZonosRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiZonosRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiZonosRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiZonosRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiZonosData = z.object({
  body: zZonosInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiZonosResponse = zQueueStatus;

export const zGetFalAiZonosRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiZonosRequestsByRequestIdResponse = zZonosOutput;

export const zGetFalAiKokoroItalianRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiKokoroItalianRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiKokoroItalianRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroItalianRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiKokoroItalianData = z.object({
  body: zKokoroItalianInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiKokoroItalianResponse = zQueueStatus;

export const zGetFalAiKokoroItalianRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiKokoroItalianRequestsByRequestIdResponse =
  zKokoroItalianOutput;

export const zGetFalAiKokoroBrazilianPortugueseRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiKokoroBrazilianPortugueseRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiKokoroBrazilianPortugueseRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroBrazilianPortugueseRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiKokoroBrazilianPortugueseData = z.object({
  body: zKokoroBrazilianPortugueseInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiKokoroBrazilianPortugueseResponse = zQueueStatus;

export const zGetFalAiKokoroBrazilianPortugueseRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * Result of the request.
 */
export const zGetFalAiKokoroBrazilianPortugueseRequestsByRequestIdResponse =
  zKokoroBrazilianPortugueseOutput;

export const zGetFalAiKokoroFrenchRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiKokoroFrenchRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiKokoroFrenchRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroFrenchRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiKokoroFrenchData = z.object({
  body: zKokoroFrenchInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiKokoroFrenchResponse = zQueueStatus;

export const zGetFalAiKokoroFrenchRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiKokoroFrenchRequestsByRequestIdResponse =
  zKokoroFrenchOutput;

export const zGetFalAiKokoroJapaneseRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiKokoroJapaneseRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiKokoroJapaneseRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroJapaneseRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiKokoroJapaneseData = z.object({
  body: zKokoroJapaneseInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiKokoroJapaneseResponse = zQueueStatus;

export const zGetFalAiKokoroJapaneseRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiKokoroJapaneseRequestsByRequestIdResponse =
  zKokoroJapaneseOutput;

export const zGetFalAiKokoroMandarinChineseRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiKokoroMandarinChineseRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiKokoroMandarinChineseRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroMandarinChineseRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiKokoroMandarinChineseData = z.object({
  body: zKokoroMandarinChineseInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiKokoroMandarinChineseResponse = zQueueStatus;

export const zGetFalAiKokoroMandarinChineseRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiKokoroMandarinChineseRequestsByRequestIdResponse =
  zKokoroMandarinChineseOutput;

export const zGetFalAiKokoroSpanishRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiKokoroSpanishRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiKokoroSpanishRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroSpanishRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiKokoroSpanishData = z.object({
  body: zKokoroSpanishInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiKokoroSpanishResponse = zQueueStatus;

export const zGetFalAiKokoroSpanishRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiKokoroSpanishRequestsByRequestIdResponse =
  zKokoroSpanishOutput;

export const zGetFalAiYueRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiYueRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiYueRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiYueRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiYueData = z.object({
  body: zYueInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiYueResponse = zQueueStatus;

export const zGetFalAiYueRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiYueRequestsByRequestIdResponse = zYueOutput;

export const zGetFalAiMmaudioV2TextToAudioRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiMmaudioV2TextToAudioRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiMmaudioV2TextToAudioRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiMmaudioV2TextToAudioRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiMmaudioV2TextToAudioData = z.object({
  body: zMmaudioV2TextToAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiMmaudioV2TextToAudioResponse = zQueueStatus;

export const zGetFalAiMmaudioV2TextToAudioRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiMmaudioV2TextToAudioRequestsByRequestIdResponse =
  zMmaudioV2TextToAudioOutput;

export const zGetFalAiMinimaxMusicRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiMinimaxMusicRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiMinimaxMusicRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiMinimaxMusicRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiMinimaxMusicData = z.object({
  body: zMinimaxMusicInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiMinimaxMusicResponse = zQueueStatus;

export const zGetFalAiMinimaxMusicRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiMinimaxMusicRequestsByRequestIdResponse =
  zMinimaxMusicOutput;

export const zGetFalAiF5TtsRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiF5TtsRequestsByRequestIdStatusResponse = zQueueStatus;

export const zPutFalAiF5TtsRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiF5TtsRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiF5TtsData = z.object({
  body: zF5TtsInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiF5TtsResponse = zQueueStatus;

export const zGetFalAiF5TtsRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiF5TtsRequestsByRequestIdResponse = zF5TtsOutput;

export const zGetFalAiStableAudioRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            "Whether to include logs (`1`) in the response or not (`0`).",
        }),
      ),
    }),
  ),
});

/**
 * The request status.
 */
export const zGetFalAiStableAudioRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiStableAudioRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * The request was cancelled.
 */
export const zPutFalAiStableAudioRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostFalAiStableAudioData = z.object({
  body: zStableAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiStableAudioResponse = zQueueStatus;

export const zGetFalAiStableAudioRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiStableAudioRequestsByRequestIdResponse =
  zStableAudioOutput;

export const zGetFalAiSamAudioVisualSeparateRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiSamAudioVisualSeparateRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiSamAudioVisualSeparateRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiSamAudioVisualSeparateRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiSamAudioVisualSeparateData = z.object({
  body: zSamAudioVisualSeparateInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiSamAudioVisualSeparateResponse = zQueueStatus;

export const zGetFalAiSamAudioVisualSeparateRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiSamAudioVisualSeparateRequestsByRequestIdResponse =
  zSamAudioVisualSeparateOutput;

export const zGetMireloAiSfxV15VideoToAudioRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetMireloAiSfxV15VideoToAudioRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutMireloAiSfxV15VideoToAudioRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutMireloAiSfxV15VideoToAudioRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostMireloAiSfxV15VideoToAudioData = z.object({
  body: zSfxV15VideoToAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostMireloAiSfxV15VideoToAudioResponse = zQueueStatus;

export const zGetMireloAiSfxV15VideoToAudioRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetMireloAiSfxV15VideoToAudioRequestsByRequestIdResponse =
  zSfxV15VideoToAudioOutput;

export const zGetFalAiKlingVideoVideoToAudioRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetFalAiKlingVideoVideoToAudioRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutFalAiKlingVideoVideoToAudioRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutFalAiKlingVideoVideoToAudioRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: "Whether the request was cancelled successfully.",
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: "The request was cancelled.",
    });

export const zPostFalAiKlingVideoVideoToAudioData = z.object({
  body: zKlingVideoVideoToAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostFalAiKlingVideoVideoToAudioResponse = zQueueStatus;

export const zGetFalAiKlingVideoVideoToAudioRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetFalAiKlingVideoVideoToAudioRequestsByRequestIdResponse =
  zKlingVideoVideoToAudioOutput;

export const zGetMireloAiSfxV1VideoToAudioRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              "Whether to include logs (`1`) in the response or not (`0`).",
          }),
        ),
      }),
    ),
  });

/**
 * The request status.
 */
export const zGetMireloAiSfxV1VideoToAudioRequestsByRequestIdStatusResponse =
  zQueueStatus;

export const zPutMireloAiSfxV1VideoToAudioRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: "Request ID",
      }),
    }),
    query: z.optional(z.never()),
  });

/**
 * The request was cancelled.
 */
export const zPutMireloAiSfxV1VideoToAudioRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether the request was cancelled successfully.",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: "The request was cancelled.",
  });

export const zPostMireloAiSfxV1VideoToAudioData = z.object({
  body: zSfxV1VideoToAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request status.
 */
export const zPostMireloAiSfxV1VideoToAudioResponse = zQueueStatus;

export const zGetMireloAiSfxV1VideoToAudioRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: "Request ID",
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Result of the request.
 */
export const zGetMireloAiSfxV1VideoToAudioRequestsByRequestIdResponse =
  zSfxV1VideoToAudioOutput;
